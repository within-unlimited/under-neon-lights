THREE.neonShader = {}

THREE.neonShader.loadTextFile = function(url) {
  var result;
  var req = new XMLHttpRequest();
  req.onerror = function() {
    console.log("Error: request error on " + url);
  };
  req.onload = function() {
    result = this.responseText;
  };
  req.open("GET", url, false);
  req.send();
  return result;
};

THREE.neonShader.loadTextFileInject = function(url) {
  var regex = /#inject .+/g;
  var fileStr = THREE.neonShader.loadTextFile(url);
  var matches = fileStr.match(regex);
  if (!matches) return fileStr;
  for (var i = 0; i < matches.length; i++) {
    var injectLine = matches[i];
    var injectUrl = injectLine.split(" ")[1];
    var injectFileStr = THREE.neonShader.loadTextFileInject(injectUrl);
    fileStr = fileStr.replace(injectLine, injectFileStr);
  }
  return fileStr;
};

THREE.neonShader.load = function(url) {
  var src = THREE.neonShader.loadTextFileInject(url);

  console.log('\n', url, ':\n\n', src.replace(/(?:\r\n|\r|\n)/g, '\\n'));
  return src;
}

THREE.neonShader.backdropShader = new THREE.ShaderMaterial({
  uniforms: {
    offset: { type: 'f', value: 0.5 },
    color: { type: 'c', value: new THREE.Color( 0xffffff ) },
    fogColor: { type: 'c', value: new THREE.Color( 0x333333 ) },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 1 },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'varying vec2 vUv;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n  vUv = uv;\n  mPosition = modelMatrix * vec4( position, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nuniform vec3 color;\n/* uniform float offset; */\n/* uniform vec3 fog; */\n\nvoid main() {\n\n  /* float t = smoothstep( offset, 1.0, vUv.y ); */\n  /* vec3 blend = mix( fog, color, pow( t, 3.0 ) ); */\n  /* vec3 factor = neonFactor(mvPosition.xyz); */\n  /* vec3 col = neonColor(blend, factor); */\n\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(color, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/backdrop.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/backdrop.frag.glsl')
});

THREE.neonShader.floorShader = new THREE.ShaderMaterial({
  uniforms: {
    size: { type: 'f', value: 1 },
    color: { type: 'c', value: new THREE.Color( 0xffffff ) },
    fogColor: { type: 'c', value: new THREE.Color( 0x333333 ) },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 1 },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'varying vec2 vUv;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n  vUv = uv;\n  mPosition = modelMatrix * vec4( position, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nuniform vec3 color;\n\nvoid main() {\n\n  /* float dist = distance( vec2( 0.5 ), vUv ) * 2.0; */\n  /* dist = clamp( dist, 0.0, 1.0 ); */\n  /* float shadow = smoothstep( 0.09, 0.15, pow( dist, 0.5 ) ); */\n  /* vec3 blend = mix( color, fogColor, pow( dist, 0.75 ) ); */\n  /* blend = mix( color * 0.75, blend, shadow ); */\n\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(color, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n    gl_FragColor = vec4(col, 1.0);\n  } else {\n    if (factor.x < 0.75 || length(col.rgb - fogColor) < 0.1) discard;\n    gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n  }\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/floor.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/floor.frag.glsl')
});

THREE.neonShader.grassShader = new THREE.ShaderMaterial({
  uniforms: {
    size: { type: 'f', value: 1 },
    base: { type: 'c', value: new THREE.Color( 0xffffff ) },
    color: { type: 'c', value: new THREE.Color( 0x8cc63f ) },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    fogColor: { type: 'c', value: new THREE.Color() },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 1 },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'float PI = 3.141592653589793;\n\nvarying vec2 vUv;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n  vec3 pos = vec3( position );\n  float pct = clamp( pos.y, 0.0, 1.0 );\n  float taper = sin( pow( pct, 0.5 ) * PI );\n\n  pos.x *= taper;\n  pos.z *= taper;\n\n  mPosition = modelMatrix * vec4( pos, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n\n  vUv = uv;\n\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nuniform vec3 color;\n\nvoid main() {\n\n  /*float dist = distance( vec2( 0.5 ), mvPosition.xz / size + 0.5 ) * 2.0;*/\n  /*dist = clamp( abs( dist ), 0.0, 1.0 );*/\n  /*vec3 col = mix( blend, fogColor, dist );*/\n\n  vec3 blend = mix( base, color, abs( vUv.y ) );\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(blend, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/grass.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/grass.frag.glsl')
});

THREE.neonShader.neonBasicShader = new THREE.ShaderMaterial({
  side: THREE.DoubleSide,
  vertexColors: THREE.VertexColors,
  uniforms: {
    fogColor: { type: 'c', value: new THREE.Color('#333') },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 50 },
    neon: { type: "f", value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    saturation: { type: "f", value: 1 }
  },
  vertexShader: 'varying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\nvoid main() {\n\n  vertexColor = color;\n  mPosition = modelMatrix * vec4( position, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nvoid main() {\n\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(vertexColor, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/neonBasic.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/neonBasic.frag.glsl')
});

THREE.neonShader.particleShader = new THREE.ShaderMaterial({
  blending: THREE.AdditiveBlending,
  transparent: true,
  defines: {
    POINT_SIZE: "3.0"
  },
  uniforms: {
    tCurrPos: { type: "t", value: null },
    tCurrCol: { type: "t", value: null },
    fogColor: { type: 'c', value: new THREE.Color('#333') },
    isParticle: { type: 'f', value: 0 },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 50 }
  },
  vertexShader: 'uniform sampler2D tCurrPos;\nuniform sampler2D tCurrCol;\n\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\nvarying float fLife;\n\nvoid main() {\n  gl_PointSize = POINT_SIZE;\n  vec4 pos = texture2D(tCurrPos, position.yx);\n  fLife = pos.a;\n  vertexColor = texture2D(tCurrCol, position.yx).rgb;\n  mPosition = modelMatrix * vec4(pos.xyz, 1.0);\n  mvPosition = viewMatrix * mPosition;\n  // mvPosition.z += 0.001;\n  gl_Position = projectionMatrix * mvPosition;\n}\n',
  fragmentShader: 'varying vec3 vertexColor;\nvarying float fLife;\nvarying vec4 mvPosition;\n\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float isParticle;\n\n/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\n\nvoid main() {\n  if (fLife < 0.0) {\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    discard;\n  } else {\n    float fogDepth = - mvPosition.z;\n    float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n    // if (length(gl_PointCoord.xy - vec2(0.5)) > 0.5) discard;\n    gl_FragColor = vec4(vertexColor, (1.0 - fogFactor) * 0.5);\n  }\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/particle.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/particle.frag.glsl')
});

THREE.neonShader.roadShader = new THREE.ShaderMaterial({
  uniforms: {
    subdivisions: { type: 'f', value: 32 },
    curvature: { type: 'f', value: 1 },
    size: { type: 'f', value: 1 },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    median: { type: 'c', value: new THREE.Color( 'red' ) },
    color: { type: 'c', value: new THREE.Color( 0xffffff ) },
    fogColor: { type: 'c', value: new THREE.Color( 0x333333 ) },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 1 },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'uniform float curvature;\nuniform float size;\n\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n\n  vec3 pos = vec3( position );\n  float x = pos.x / size;\n  float y = pos.y / size;\n  float x2 = x * 2.0;\n  float y2 = y * 2.0;\n  float dist = curvature * sqrt( x2 * x2 + y2 * y2 );\n  pos.z = size * ( dist * dist ) / 2.0;\n\n  mPosition = modelMatrix * vec4( pos, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nfloat PI = 3.141592653589793;\n\nuniform float subdivisions;\n\nuniform vec3 median;\nuniform vec3 fog;\nuniform vec3 color;\n\nvoid main() {\n  float threshold = 6.0 / size;\n  vec2 pos = vec2( cursor.x + vUv.x, - cursor.y + vUv.y );\n  pos = mod( subdivisions * pos, 1.0 );\n\n  vec2 isMedian = vec2( sin( pos * PI ) );\n  vec2 isIntersection = vec2( 1.0 - isMedian.y, 1.0 - isMedian.x );\n\n  isMedian = step( vec2( threshold ), isMedian );\n  isIntersection = step( vec2( 0.66 ), isIntersection );\n\n  float t = clamp( isMedian.x + isIntersection.x, 0.0, 1.0 );\n  vec3 layer = mix( median, color, t );\n\n  t = clamp( isMedian.y + isIntersection.y, 0.0, 1.0 );\n  layer = mix( median, layer, t );\n\n  float dist = distance( vec2( 0.5 ), vUv ) * 2.0;\n  t = clamp( dist, 0.0, 1.0 );\n\n  layer = mix( layer, fog, pow( t, 0.5 ) );\n  float shadow = smoothstep( 0.0006, 0.0012, t );\n\n  vec3 col = mix( layer * 0.66, layer, shadow );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 factor = neonFactor();\n  col = neonColor(col, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/road.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/road.frag.glsl'),
});

THREE.neonShader.sepiaShader = new THREE.ShaderMaterial({
  uniforms: {
    opacist: { type: 'f', value: 1 }
  },
  vertexShader: 'varying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n\n}\n',
  fragmentShader: 'uniform float opacity;\n\nfloat t;\n\nconst vec3 b = vec3( 0.0, 69.0, 116.0 );\nconst vec3 a = vec3( 89.0, 188.0, 255.0 );\n\n/*\nconst vec3 a = vec3( 61.0, 44.0, 32.00 );\nconst vec3 b = vec3( 79.0, 54.0, 33.0 );\nconst vec3 c = vec3( 155.0, 121.0, 68.0 );\nconst vec3 d = vec3( 208.0, 174.0, 111.0 );\nconst vec3 e = vec3( 250.0, 244.0, 205.0 );\n*/\n\nvarying vec2 vUv;\n\nfloat average ( vec3 v ) {\n    return ( v.x + v.y + v.z ) / 3.0;\n}\n\nvoid main () {\n\n    float reduction = 1.4;\n    float amount = 2.0;\n    float radius = length( vUv - 0.5 ) * reduction;\n\n    float magnitude = ( 1.0 - radius ) * ( amount - 1.0 );\n\n    float space = 255.0;\n    vec3 layer = a.xyz / space;\n\n    t = magnitude;\n    layer = mix( layer, b.xyz / space, clamp( t, 0.0, 1.0 ) );\n\n/*\n    t = magnitude - 1.0;\n    layer = mix( layer, c.xyz / space, clamp( t, 0.0, 1.0 ) );\n\n    t = magnitude - 2.0;\n    layer = mix( layer, d.xyz / space, clamp( t, 0.0, 1.0 ) );\n\n    t = magnitude - 3.0;\n    layer = mix( layer, e.xyz / space, clamp( t, 0.0, 1.0 ) );\n*/\n\n    gl_FragColor = vec4( layer * opacity, 1.0 );\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/sepia.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/sepia.frag.glsl'),
});

THREE.neonShader.simulationShader = new THREE.ShaderMaterial({
  defines: {
    SIZE: "0.0",
    TAIL_SIZE: "0.0"
  },
  uniforms: {
    tInit: { type: "t", value: null },
    tPrevPos: { type: "t", value: null },
    tPrevCol: { type: "t", value: null },
    fPass: { type: "f", value: 0 },
    fTarget: { type: "f", value: 0 },
    fTime: { type: "f", value: 0 },
    fTimeDelta: { type: "f", value: 0 },
    fScale: { type: "f", value: 1 },
    fEmissionRate: { type: "f", value: 1 },
    vMotionVector: { type: "v3", value: new THREE.Vector3() },
    mProjectionMatrix: { type: "m", value: null },
    mModelViewMatrix: { type: "m", value: null }
  },
  vertexShader: 'varying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}\n',
  fragmentShader: 'varying vec2 vUv;\n\nuniform sampler2D tInit;\nuniform sampler2D tPrevPos;\nuniform sampler2D tPrevCol;\nuniform float fPass;\nuniform float fTarget;\nuniform vec3 vMotionVector;\nuniform mat4 mProjectionMatrix;\nuniform mat4 mModelViewMatrix;\n\nuniform float fTime;\nuniform float fTimeDelta;\nuniform float fScale;\nuniform float fEmissionRate;\n\n/* source: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl */\nfloat rand(vec2 seed) {\n  return fract(sin(dot(seed.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nvoid main() {\n  float d = fTimeDelta;\n\n  vec2 uv = vUv;\n  float tail = mod(uv.y * SIZE * TAIL_SIZE, TAIL_SIZE) / TAIL_SIZE;\n  uv.y = uv.y - tail / SIZE;\n\n  vec4 pos = texture2D(tPrevPos, vUv);\n  vec4 col = texture2D(tPrevCol, vUv);\n  vec4 pos0 = texture2D(tPrevPos, uv);\n\n  float tailNorm = 2.0 - tail;\n  vec2 uvRandomized = vec2(\n    0.5 + 2.0 * abs(uv.x - 0.5) * (rand(100.0 * (uv.xy + vec2(fTime, fTimeDelta))) - 0.5),\n    0.5 + 2.0 * abs(uv.y - 0.5) * (rand(100.0 * (uv.yx + vec2(fTimeDelta, fTime))) - 0.5)\n  );\n\n  vec4 posInit = texture2D(tInit, uvRandomized);\n  if (length(posInit.xyz) <= 0.01) {\n    posInit.a = 0.0;\n  }\n\n  float speed = 0.04;\n  float len = fScale * 50.0;\n\n  if (pos0.a <= 0.0 && posInit.a != 0.0 && uv.x < fEmissionRate) {\n    pos = posInit;\n    col = floatToVec4(pos.a);\n    col.rgb *= 0.5 + 1.2 * rand(vec2(uv.y, col.b));\n    pos.a = tailNorm - rand(uv.yx) * 1.0;\n  } else if (pos.a < (tailNorm) && pos.a > 1.0) {\n    float dist = max(1.0, 0.05 * length(pos.xyz));\n    vec3 force = curlNoise((pos.xyz + vec3(0.0, fTime * 0.5, 0.0)) * 0.3 / fScale / dist) * d * speed * len;\n    pos.xyz += force * dist;\n    pos.xyz -= vMotionVector * d * 2.0;\n  }\n\n  pos.xyz += snoiseVec3((pos.xyz + vec3(0.0, fTime * 0.3, 0.0)) * 0.4 / fScale) * d * speed;\n  pos.xyz += vMotionVector;\n  pos.a -= 0.5 * speed;\n\n  gl_FragColor = (fTarget == 0.0) ? pos : col;\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/simulation.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/simulation.frag.glsl')
});

THREE.neonShader.skinnedShader = new THREE.ShaderMaterial({
  uniforms: {
    fogColor: { type: 'c', value: new THREE.Color() },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 50 },
    clipy: { type: 'v2', value: new THREE.Vector2(-1e10, 1e10) },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'varying vec4 mPosition;\nvarying vec4 mvPosition;\nvarying vec3 vertexColor;\n\nuniform mat4 bindMatrix;\nuniform mat4 bindMatrixInverse;\n#ifdef BONE_TEXTURE\n  uniform sampler2D boneTexture;\n  uniform int boneTextureSize;\n  mat4 getBoneMatrix( const in float i ) {\n    float j = i * 4.0;\n    float x = mod( j, float( boneTextureSize ) );\n    float y = floor( j / float( boneTextureSize ) );\n    float dx = 1.0 / float( boneTextureSize );\n    float dy = 1.0 / float( boneTextureSize );\n    y = dy * ( y + 0.5 );\n    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n    mat4 bone = mat4( v1, v2, v3, v4 );\n    return bone;\n  }\n#else\n  uniform mat4 boneMatrices[ MAX_BONES ];\n  mat4 getBoneMatrix( const in float i ) {\n    mat4 bone = boneMatrices[ int(i) ];\n    return bone;\n  }\n#endif\n\n\nvoid main() {\n\n  vertexColor = color;\n  vec4 skinned = vec4( 0.0 );\n\n  /* skinbase_vertex */\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n/* skinning_vertex */\nvec4 skinVertex = bindMatrix * vec4( position.xyz, 1.0 );\n\nskinned += boneMatX * skinVertex * skinWeight.x;\nskinned += boneMatY * skinVertex * skinWeight.y;\nskinned += boneMatZ * skinVertex * skinWeight.z;\nskinned += boneMatW * skinVertex * skinWeight.w;\nskinned  = bindMatrixInverse * skinned;\n\n\n  mPosition = modelMatrix * skinned;\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nuniform vec2 clipy;\n\nvoid main() {\n  if (mPosition.y < clipy.x || mPosition.y > clipy.y) discard;\n\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(vertexColor, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/skinned.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/skinned.frag.glsl')
});

THREE.neonShader.waveShader = new THREE.ShaderMaterial({
  uniforms: {
    fogColor: { type: 'c', value: new THREE.Color() },
    fogNear: { type: 'f', value: 0 },
    fogFar: { type: 'f', value: 1 },
    neon: { type: 'f', value: 0 },
    time: { type: 'f', value: 0 },
    cursor: { type: "v2", value: new THREE.Vector2() },
    saturation: { type: 'f', value: 1 }
  },
  vertexShader: 'float PI = 3.141592653589793;\n\nuniform float time;\n\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\nvarying vec3 vertexColor;\n\nvoid main() {\n\n  vec3 pos = vec3( position );\n  vec4 t = projectionMatrix * vec4( 1.0 );\n\n  float osc = ( 1.0 + sin( time + PI * ( t.x + t.y + t.z ) / 3.0 ) ) / 2.0;\n  float sway = pow( pos.y, 2.0 ) * osc;\n\n  pos.x += sway / 100.0;\n\n  vertexColor = color;\n\n  mPosition = modelMatrix * vec4( pos, 1.0 );\n  mvPosition = viewMatrix * mPosition;\n  gl_Position = projectionMatrix * mvPosition;\n\n}\n',
  fragmentShader: '/* Pack float4 into single float */\n\n/* http://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab */\n\nfloat vec4ToFloat(vec4 c) {\n  return 1.0/255.0 * (floor(c.r*255.0/64.0)*64.0 + floor(c.g*255.0/64.0)*16.0 + floor(c.b*255.0/64.0)*4.0 + floor(c.a*255.0/64.0));\n}\n\nvec4 floatToVec4(float x) {\n  float a = floor(x * 255.0 / 64.0) * 64.0 / 255.0;\n  x -= a;\n  float b = floor(x * 255.0 / 16.0) * 16.0 / 255.0;\n  x -= b;\n  b *= 4.0;\n  float c = floor(x * 255.0 / 4.0) * 4.0 / 255.0;\n  x -= c;\n  c *= 16.0;\n  float d = x * 255.0 * 64.0 / 255.0;\n  return vec4(a, b, c, d);\n}\n\nuniform vec3 sepia;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\nuniform float saturation;\nuniform float neon;\nuniform float time;\nuniform float size;\nuniform vec3 base;\nuniform vec2 cursor;\n\nvarying vec2 vUv;\nvarying vec3 vertexColor;\nvarying vec4 mPosition;\nvarying vec4 mvPosition;\n\n/*\n * Description : Array and textureless GLSL 2D/3D/4D simplex noise functions.\n *      Author : Ian McEwan, Ashima Arts.\n *  Maintainer : ijm\n *     Lastmod : 20110822 (ijm)\n *     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n *               Distributed under the MIT License. See LICENSE file.\n *               https://github.com/ashima/webgl-noise\n */\n\nvec4 _mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 _mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 _mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nfloat _mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 _permute(vec4 x) { return _mod289(((x*34.0)+1.0)*x); }\nvec3 _permute(vec3 x) { return _mod289(((x*34.0)+1.0)*x); }\nfloat _permute(float x) { return _mod289(((x*34.0)+1.0)*x); }\nvec4 _taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat _taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 _grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n  return p;\n}\n/*\n * Implemented by Ian McEwan, Ashima Arts, and distributed under the MIT License.  {@link https://github.com/ashima/webgl-noise}\n */\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(\n    0.211324865405187,\n    0.366025403784439,\n   -0.577350269189626,\n    0.024390243902439);\n\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n  i = _mod289(i);\n  vec3 p = _permute( _permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy;\n  vec3 x3 = x0 - D.yyy;\n\n  i = _mod289(i);\n  vec4 p = _permute( _permute( _permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857;\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = _taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 snoiseVec3( vec3 x ) {\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p ) {\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\n\nfloat neonNoise(vec3 pos, float phase) {\n  float noise = snoise(pos * 0.1);\n  noise = max(0.0, sin(noise * 16.0 + time * 0.0) + phase);\n  return noise;\n}\n\nvec3 neonFactor() {\n  vec3 p = mPosition.xyz + vec3(cursor.y, 0.0, cursor.x);\n  // p.y += time;\n  return vec3(\n    neonNoise(p, 0.3),\n    neonNoise(p, 0.0),\n    neonNoise(p, -0.3)\n  );\n}\n\nvec3 neonColor( vec3 c, vec3 neonFactor, vec3 pos ) {\n\n  float fogDepth = length(pos.xz) * 0.50;\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n  vec3 col = mix( c, fogColor, fogFactor );\n  col = mix( col.rrr, col, saturation );\n\n  vec3 nCol = mix( mix( vec3(0.0), fogColor, fogFactor ), col, neonFactor );\n  nCol = clamp(nCol, fogColor, vec3(1.0));\n\n  return mix(col, nCol, neon);\n}\n\n\nvoid main() {\n\n  vec3 factor = neonFactor();\n  vec3 col = neonColor(vertexColor, factor, mPosition.xyz);\n\n  if (neon <= 1.0) {\n  gl_FragColor = vec4(col, 1.0);\n} else {\n  if (factor.x < 0.75  || length(col.rgb - fogColor) < 0.01) discard;\n  gl_FragColor = vec4(mPosition.xyz, vec4ToFloat(vec4(col.rgb, 1.0)));\n}\n\n\n}\n',
  // vertexShader: THREE.neonShader.load('../release/src/shaders/wave.vert.glsl'),
  // fragmentShader: THREE.neonShader.load('../release/src/shaders/wave.frag.glsl')
});

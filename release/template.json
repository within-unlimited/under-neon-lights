{
	"config": {},
	"includes": [
		[
			"Three.js",
			"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.THREE = global.THREE || {})));\n}(this, (function (exports) { 'use strict';\n\n  // Polyfills\n\n  if ( Number.EPSILON === undefined ) {\n\n    Number.EPSILON = Math.pow( 2, - 52 );\n\n  }\n\n  //\n\n  if ( Math.sign === undefined ) {\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n    Math.sign = function ( x ) {\n\n      return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n    };\n\n  }\n\n  if ( Function.prototype.name === undefined ) {\n\n    // Missing in IE9-11.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n    Object.defineProperty( Function.prototype, 'name', {\n\n      get: function () {\n\n        return this.toString().match( /^\\s*function\\s*([^\\(\\s]*)/ )[ 1 ];\n\n      }\n\n    } );\n\n  }\n\n  if ( Object.assign === undefined ) {\n\n    // Missing in IE.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n    ( function () {\n\n      Object.assign = function ( target ) {\n\n        'use strict';\n\n        if ( target === undefined || target === null ) {\n\n          throw new TypeError( 'Cannot convert undefined or null to object' );\n\n        }\n\n        var output = Object( target );\n\n        for ( var index = 1; index < arguments.length; index ++ ) {\n\n          var source = arguments[ index ];\n\n          if ( source !== undefined && source !== null ) {\n\n            for ( var nextKey in source ) {\n\n              if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n                output[ nextKey ] = source[ nextKey ];\n\n              }\n\n            }\n\n          }\n\n        }\n\n        return output;\n\n      };\n\n    } )();\n\n  }\n\n  /**\n   * https://github.com/mrdoob/eventdispatcher.js/\n   */\n\n  function EventDispatcher() {}\n\n  Object.assign( EventDispatcher.prototype, {\n\n    addEventListener: function ( type, listener ) {\n\n      if ( this._listeners === undefined ) this._listeners = {};\n\n      var listeners = this._listeners;\n\n      if ( listeners[ type ] === undefined ) {\n\n        listeners[ type ] = [];\n\n      }\n\n      if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n        listeners[ type ].push( listener );\n\n      }\n\n    },\n\n    hasEventListener: function ( type, listener ) {\n\n      if ( this._listeners === undefined ) return false;\n\n      var listeners = this._listeners;\n\n      return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n    },\n\n    removeEventListener: function ( type, listener ) {\n\n      if ( this._listeners === undefined ) return;\n\n      var listeners = this._listeners;\n      var listenerArray = listeners[ type ];\n\n      if ( listenerArray !== undefined ) {\n\n        var index = listenerArray.indexOf( listener );\n\n        if ( index !== - 1 ) {\n\n          listenerArray.splice( index, 1 );\n\n        }\n\n      }\n\n    },\n\n    dispatchEvent: function ( event ) {\n\n      if ( this._listeners === undefined ) return;\n\n      var listeners = this._listeners;\n      var listenerArray = listeners[ event.type ];\n\n      if ( listenerArray !== undefined ) {\n\n        event.target = this;\n\n        var array = [], i = 0;\n        var length = listenerArray.length;\n\n        for ( i = 0; i < length; i ++ ) {\n\n          array[ i ] = listenerArray[ i ];\n\n        }\n\n        for ( i = 0; i < length; i ++ ) {\n\n          array[ i ].call( this, event );\n\n        }\n\n      }\n\n    }\n\n  } );\n\n  var REVISION = '85dev';\n  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n  var CullFaceNone = 0;\n  var CullFaceBack = 1;\n  var CullFaceFront = 2;\n  var CullFaceFrontBack = 3;\n  var FrontFaceDirectionCW = 0;\n  var FrontFaceDirectionCCW = 1;\n  var BasicShadowMap = 0;\n  var PCFShadowMap = 1;\n  var PCFSoftShadowMap = 2;\n  var FrontSide = 0;\n  var BackSide = 1;\n  var DoubleSide = 2;\n  var FlatShading = 1;\n  var SmoothShading = 2;\n  var NoColors = 0;\n  var FaceColors = 1;\n  var VertexColors = 2;\n  var NoBlending = 0;\n  var NormalBlending = 1;\n  var AdditiveBlending = 2;\n  var SubtractiveBlending = 3;\n  var MultiplyBlending = 4;\n  var CustomBlending = 5;\n  var AddEquation = 100;\n  var SubtractEquation = 101;\n  var ReverseSubtractEquation = 102;\n  var MinEquation = 103;\n  var MaxEquation = 104;\n  var ZeroFactor = 200;\n  var OneFactor = 201;\n  var SrcColorFactor = 202;\n  var OneMinusSrcColorFactor = 203;\n  var SrcAlphaFactor = 204;\n  var OneMinusSrcAlphaFactor = 205;\n  var DstAlphaFactor = 206;\n  var OneMinusDstAlphaFactor = 207;\n  var DstColorFactor = 208;\n  var OneMinusDstColorFactor = 209;\n  var SrcAlphaSaturateFactor = 210;\n  var NeverDepth = 0;\n  var AlwaysDepth = 1;\n  var LessDepth = 2;\n  var LessEqualDepth = 3;\n  var EqualDepth = 4;\n  var GreaterEqualDepth = 5;\n  var GreaterDepth = 6;\n  var NotEqualDepth = 7;\n  var MultiplyOperation = 0;\n  var MixOperation = 1;\n  var AddOperation = 2;\n  var NoToneMapping = 0;\n  var LinearToneMapping = 1;\n  var ReinhardToneMapping = 2;\n  var Uncharted2ToneMapping = 3;\n  var CineonToneMapping = 4;\n  var UVMapping = 300;\n  var CubeReflectionMapping = 301;\n  var CubeRefractionMapping = 302;\n  var EquirectangularReflectionMapping = 303;\n  var EquirectangularRefractionMapping = 304;\n  var SphericalReflectionMapping = 305;\n  var CubeUVReflectionMapping = 306;\n  var CubeUVRefractionMapping = 307;\n  var RepeatWrapping = 1000;\n  var ClampToEdgeWrapping = 1001;\n  var MirroredRepeatWrapping = 1002;\n  var NearestFilter = 1003;\n  var NearestMipMapNearestFilter = 1004;\n  var NearestMipMapLinearFilter = 1005;\n  var LinearFilter = 1006;\n  var LinearMipMapNearestFilter = 1007;\n  var LinearMipMapLinearFilter = 1008;\n  var UnsignedByteType = 1009;\n  var ByteType = 1010;\n  var ShortType = 1011;\n  var UnsignedShortType = 1012;\n  var IntType = 1013;\n  var UnsignedIntType = 1014;\n  var FloatType = 1015;\n  var HalfFloatType = 1016;\n  var UnsignedShort4444Type = 1017;\n  var UnsignedShort5551Type = 1018;\n  var UnsignedShort565Type = 1019;\n  var UnsignedInt248Type = 1020;\n  var AlphaFormat = 1021;\n  var RGBFormat = 1022;\n  var RGBAFormat = 1023;\n  var LuminanceFormat = 1024;\n  var LuminanceAlphaFormat = 1025;\n  var RGBEFormat = RGBAFormat;\n  var DepthFormat = 1026;\n  var DepthStencilFormat = 1027;\n  var RGB_S3TC_DXT1_Format = 2001;\n  var RGBA_S3TC_DXT1_Format = 2002;\n  var RGBA_S3TC_DXT3_Format = 2003;\n  var RGBA_S3TC_DXT5_Format = 2004;\n  var RGB_PVRTC_4BPPV1_Format = 2100;\n  var RGB_PVRTC_2BPPV1_Format = 2101;\n  var RGBA_PVRTC_4BPPV1_Format = 2102;\n  var RGBA_PVRTC_2BPPV1_Format = 2103;\n  var RGB_ETC1_Format = 2151;\n  var LoopOnce = 2200;\n  var LoopRepeat = 2201;\n  var LoopPingPong = 2202;\n  var InterpolateDiscrete = 2300;\n  var InterpolateLinear = 2301;\n  var InterpolateSmooth = 2302;\n  var ZeroCurvatureEnding = 2400;\n  var ZeroSlopeEnding = 2401;\n  var WrapAroundEnding = 2402;\n  var TrianglesDrawMode = 0;\n  var TriangleStripDrawMode = 1;\n  var TriangleFanDrawMode = 2;\n  var LinearEncoding = 3000;\n  var sRGBEncoding = 3001;\n  var GammaEncoding = 3007;\n  var RGBEEncoding = 3002;\n  var LogLuvEncoding = 3003;\n  var RGBM7Encoding = 3004;\n  var RGBM16Encoding = 3005;\n  var RGBDEncoding = 3006;\n  var BasicDepthPacking = 3200;\n  var RGBADepthPacking = 3201;\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  var _Math = {\n\n    DEG2RAD: Math.PI / 180,\n    RAD2DEG: 180 / Math.PI,\n\n    generateUUID: function () {\n\n      // http://www.broofa.com/Tools/Math.uuid.htm\n\n      var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n      var uuid = new Array( 36 );\n      var rnd = 0, r;\n\n      return function generateUUID() {\n\n        for ( var i = 0; i < 36; i ++ ) {\n\n          if ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n            uuid[ i ] = '-';\n\n          } else if ( i === 14 ) {\n\n            uuid[ i ] = '4';\n\n          } else {\n\n            if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n            r = rnd & 0xf;\n            rnd = rnd >> 4;\n            uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n          }\n\n        }\n\n        return uuid.join( '' );\n\n      };\n\n    }(),\n\n    clamp: function ( value, min, max ) {\n\n      return Math.max( min, Math.min( max, value ) );\n\n    },\n\n    // compute euclidian modulo of m % n\n    // https://en.wikipedia.org/wiki/Modulo_operation\n\n    euclideanModulo: function ( n, m ) {\n\n      return ( ( n % m ) + m ) % m;\n\n    },\n\n    // Linear mapping from range <a1, a2> to range <b1, b2>\n\n    mapLinear: function ( x, a1, a2, b1, b2 ) {\n\n      return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n    },\n\n    // https://en.wikipedia.org/wiki/Linear_interpolation\n\n    lerp: function ( x, y, t ) {\n\n      return ( 1 - t ) * x + t * y;\n\n    },\n\n    // http://en.wikipedia.org/wiki/Smoothstep\n\n    smoothstep: function ( x, min, max ) {\n\n      if ( x <= min ) return 0;\n      if ( x >= max ) return 1;\n\n      x = ( x - min ) / ( max - min );\n\n      return x * x * ( 3 - 2 * x );\n\n    },\n\n    smootherstep: function ( x, min, max ) {\n\n      if ( x <= min ) return 0;\n      if ( x >= max ) return 1;\n\n      x = ( x - min ) / ( max - min );\n\n      return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n    },\n\n    // Random integer from <low, high> interval\n\n    randInt: function ( low, high ) {\n\n      return low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n    },\n\n    // Random float from <low, high> interval\n\n    randFloat: function ( low, high ) {\n\n      return low + Math.random() * ( high - low );\n\n    },\n\n    // Random float from <-range/2, range/2> interval\n\n    randFloatSpread: function ( range ) {\n\n      return range * ( 0.5 - Math.random() );\n\n    },\n\n    degToRad: function ( degrees ) {\n\n      return degrees * _Math.DEG2RAD;\n\n    },\n\n    radToDeg: function ( radians ) {\n\n      return radians * _Math.RAD2DEG;\n\n    },\n\n    isPowerOfTwo: function ( value ) {\n\n      return ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n    },\n\n    nearestPowerOfTwo: function ( value ) {\n\n      return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n    },\n\n    nextPowerOfTwo: function ( value ) {\n\n      value --;\n      value |= value >> 1;\n      value |= value >> 2;\n      value |= value >> 4;\n      value |= value >> 8;\n      value |= value >> 16;\n      value ++;\n\n      return value;\n\n    }\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author philogb / http://blog.thejit.org/\n   * @author egraether / http://egraether.com/\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   */\n\n  function Vector2( x, y ) {\n\n    this.x = x || 0;\n    this.y = y || 0;\n\n  }\n\n  Object.defineProperties( Vector2.prototype, {\n\n    \"width\" : {\n\n      get: function () {\n\n        return this.x;\n\n      },\n\n      set: function ( value ) {\n\n        this.x = value;\n\n      }\n\n    },\n\n    \"height\" : {\n\n      get: function () {\n\n        return this.y;\n\n      },\n\n      set: function ( value ) {\n\n        this.y = value;\n\n      }\n\n    }\n\n  } );\n\n  Object.assign( Vector2.prototype, {\n\n    isVector2: true,\n\n    set: function ( x, y ) {\n\n      this.x = x;\n      this.y = y;\n\n      return this;\n\n    },\n\n    setScalar: function ( scalar ) {\n\n      this.x = scalar;\n      this.y = scalar;\n\n      return this;\n\n    },\n\n    setX: function ( x ) {\n\n      this.x = x;\n\n      return this;\n\n    },\n\n    setY: function ( y ) {\n\n      this.y = y;\n\n      return this;\n\n    },\n\n    setComponent: function ( index, value ) {\n\n      switch ( index ) {\n\n        case 0: this.x = value; break;\n        case 1: this.y = value; break;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n      return this;\n\n    },\n\n    getComponent: function ( index ) {\n\n      switch ( index ) {\n\n        case 0: return this.x;\n        case 1: return this.y;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this.x, this.y );\n\n    },\n\n    copy: function ( v ) {\n\n      this.x = v.x;\n      this.y = v.y;\n\n      return this;\n\n    },\n\n    add: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n        return this.addVectors( v, w );\n\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n\n      return this;\n\n    },\n\n    addScalar: function ( s ) {\n\n      this.x += s;\n      this.y += s;\n\n      return this;\n\n    },\n\n    addVectors: function ( a, b ) {\n\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n\n      return this;\n\n    },\n\n    addScaledVector: function ( v, s ) {\n\n      this.x += v.x * s;\n      this.y += v.y * s;\n\n      return this;\n\n    },\n\n    sub: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n        return this.subVectors( v, w );\n\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n\n      return this;\n\n    },\n\n    subScalar: function ( s ) {\n\n      this.x -= s;\n      this.y -= s;\n\n      return this;\n\n    },\n\n    subVectors: function ( a, b ) {\n\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n\n      return this;\n\n    },\n\n    multiply: function ( v ) {\n\n      this.x *= v.x;\n      this.y *= v.y;\n\n      return this;\n\n    },\n\n    multiplyScalar: function ( scalar ) {\n\n      if ( isFinite( scalar ) ) {\n\n        this.x *= scalar;\n        this.y *= scalar;\n\n      } else {\n\n        this.x = 0;\n        this.y = 0;\n\n      }\n\n      return this;\n\n    },\n\n    divide: function ( v ) {\n\n      this.x /= v.x;\n      this.y /= v.y;\n\n      return this;\n\n    },\n\n    divideScalar: function ( scalar ) {\n\n      return this.multiplyScalar( 1 / scalar );\n\n    },\n\n    min: function ( v ) {\n\n      this.x = Math.min( this.x, v.x );\n      this.y = Math.min( this.y, v.y );\n\n      return this;\n\n    },\n\n    max: function ( v ) {\n\n      this.x = Math.max( this.x, v.x );\n      this.y = Math.max( this.y, v.y );\n\n      return this;\n\n    },\n\n    clamp: function ( min, max ) {\n\n      // This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n      this.x = Math.max( min.x, Math.min( max.x, this.x ) );\n      this.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n      return this;\n\n    },\n\n    clampScalar: function () {\n\n      var min = new Vector2();\n      var max = new Vector2();\n\n      return function clampScalar( minVal, maxVal ) {\n\n        min.set( minVal, minVal );\n        max.set( maxVal, maxVal );\n\n        return this.clamp( min, max );\n\n      };\n\n    }(),\n\n    clampLength: function ( min, max ) {\n\n      var length = this.length();\n\n      return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n    },\n\n    floor: function () {\n\n      this.x = Math.floor( this.x );\n      this.y = Math.floor( this.y );\n\n      return this;\n\n    },\n\n    ceil: function () {\n\n      this.x = Math.ceil( this.x );\n      this.y = Math.ceil( this.y );\n\n      return this;\n\n    },\n\n    round: function () {\n\n      this.x = Math.round( this.x );\n      this.y = Math.round( this.y );\n\n      return this;\n\n    },\n\n    roundToZero: function () {\n\n      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n      return this;\n\n    },\n\n    negate: function () {\n\n      this.x = - this.x;\n      this.y = - this.y;\n\n      return this;\n\n    },\n\n    dot: function ( v ) {\n\n      return this.x * v.x + this.y * v.y;\n\n    },\n\n    lengthSq: function () {\n\n      return this.x * this.x + this.y * this.y;\n\n    },\n\n    length: function () {\n\n      return Math.sqrt( this.x * this.x + this.y * this.y );\n\n    },\n\n    lengthManhattan: function() {\n\n      return Math.abs( this.x ) + Math.abs( this.y );\n\n    },\n\n    normalize: function () {\n\n      return this.divideScalar( this.length() );\n\n    },\n\n    angle: function () {\n\n      // computes the angle in radians with respect to the positive x-axis\n\n      var angle = Math.atan2( this.y, this.x );\n\n      if ( angle < 0 ) angle += 2 * Math.PI;\n\n      return angle;\n\n    },\n\n    distanceTo: function ( v ) {\n\n      return Math.sqrt( this.distanceToSquared( v ) );\n\n    },\n\n    distanceToSquared: function ( v ) {\n\n      var dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n\n    },\n\n    distanceToManhattan: function ( v ) {\n\n      return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n    },\n\n    setLength: function ( length ) {\n\n      return this.multiplyScalar( length / this.length() );\n\n    },\n\n    lerp: function ( v, alpha ) {\n\n      this.x += ( v.x - this.x ) * alpha;\n      this.y += ( v.y - this.y ) * alpha;\n\n      return this;\n\n    },\n\n    lerpVectors: function ( v1, v2, alpha ) {\n\n      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n    },\n\n    equals: function ( v ) {\n\n      return ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.x = array[ offset ];\n      this.y = array[ offset + 1 ];\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this.x;\n      array[ offset + 1 ] = this.y;\n\n      return array;\n\n    },\n\n    fromBufferAttribute: function ( attribute, index, offset ) {\n\n      if ( offset !== undefined ) {\n\n        console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n      }\n\n      this.x = attribute.getX( index );\n      this.y = attribute.getY( index );\n\n      return this;\n\n    },\n\n    rotateAround: function ( center, angle ) {\n\n      var c = Math.cos( angle ), s = Math.sin( angle );\n\n      var x = this.x - center.x;\n      var y = this.y - center.y;\n\n      this.x = x * c - y * s + center.x;\n      this.y = x * s + y * c + center.y;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   * @author szimek / https://github.com/szimek/\n   */\n\n  var textureId = 0;\n\n  function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n    Object.defineProperty( this, 'id', { value: textureId ++ } );\n\n    this.uuid = _Math.generateUUID();\n\n    this.name = '';\n\n    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\n    this.mipmaps = [];\n\n    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\n\n    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\n    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\n\n    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\n\n    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n    this.format = format !== undefined ? format : RGBAFormat;\n    this.type = type !== undefined ? type : UnsignedByteType;\n\n    this.offset = new Vector2( 0, 0 );\n    this.repeat = new Vector2( 1, 1 );\n\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n    this.encoding = encoding !== undefined ? encoding : LinearEncoding;\n\n    this.version = 0;\n    this.onUpdate = null;\n\n  }\n\n  Texture.DEFAULT_IMAGE = undefined;\n  Texture.DEFAULT_MAPPING = UVMapping;\n\n  Object.defineProperty( Texture.prototype, \"needsUpdate\", {\n\n    set: function ( value ) {\n\n      if ( value === true ) this.version ++;\n\n    }\n\n  } );\n\n  Object.assign( Texture.prototype, EventDispatcher.prototype, {\n\n    constructor: Texture,\n\n    isTexture: true,\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      this.name = source.name;\n\n      this.image = source.image;\n      this.mipmaps = source.mipmaps.slice( 0 );\n\n      this.mapping = source.mapping;\n\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n\n      this.anisotropy = source.anisotropy;\n\n      this.format = source.format;\n      this.type = source.type;\n\n      this.offset.copy( source.offset );\n      this.repeat.copy( source.repeat );\n\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.encoding = source.encoding;\n\n      return this;\n\n    },\n\n    toJSON: function ( meta ) {\n\n      if ( meta.textures[ this.uuid ] !== undefined ) {\n\n        return meta.textures[ this.uuid ];\n\n      }\n\n      function getDataURL( image ) {\n\n        var canvas;\n\n        if ( image.toDataURL !== undefined ) {\n\n          canvas = image;\n\n        } else {\n\n          canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n          canvas.width = image.width;\n          canvas.height = image.height;\n\n          canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n        }\n\n        if ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n          return canvas.toDataURL( 'image/jpeg', 0.6 );\n\n        } else {\n\n          return canvas.toDataURL( 'image/png' );\n\n        }\n\n      }\n\n      var output = {\n        metadata: {\n          version: 4.4,\n          type: 'Texture',\n          generator: 'Texture.toJSON'\n        },\n\n        uuid: this.uuid,\n        name: this.name,\n\n        mapping: this.mapping,\n\n        repeat: [ this.repeat.x, this.repeat.y ],\n        offset: [ this.offset.x, this.offset.y ],\n        wrap: [ this.wrapS, this.wrapT ],\n\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n\n        flipY: this.flipY\n      };\n\n      if ( this.image !== undefined ) {\n\n        // TODO: Move to THREE.Image\n\n        var image = this.image;\n\n        if ( image.uuid === undefined ) {\n\n          image.uuid = _Math.generateUUID(); // UGH\n\n        }\n\n        if ( meta.images[ image.uuid ] === undefined ) {\n\n          meta.images[ image.uuid ] = {\n            uuid: image.uuid,\n            url: getDataURL( image )\n          };\n\n        }\n\n        output.image = image.uuid;\n\n      }\n\n      meta.textures[ this.uuid ] = output;\n\n      return output;\n\n    },\n\n    dispose: function () {\n\n      this.dispatchEvent( { type: 'dispose' } );\n\n    },\n\n    transformUv: function ( uv ) {\n\n      if ( this.mapping !== UVMapping ) return;\n\n      uv.multiply( this.repeat );\n      uv.add( this.offset );\n\n      if ( uv.x < 0 || uv.x > 1 ) {\n\n        switch ( this.wrapS ) {\n\n          case RepeatWrapping:\n\n            uv.x = uv.x - Math.floor( uv.x );\n            break;\n\n          case ClampToEdgeWrapping:\n\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n\n          case MirroredRepeatWrapping:\n\n            if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n              uv.x = Math.ceil( uv.x ) - uv.x;\n\n            } else {\n\n              uv.x = uv.x - Math.floor( uv.x );\n\n            }\n            break;\n\n        }\n\n      }\n\n      if ( uv.y < 0 || uv.y > 1 ) {\n\n        switch ( this.wrapT ) {\n\n          case RepeatWrapping:\n\n            uv.y = uv.y - Math.floor( uv.y );\n            break;\n\n          case ClampToEdgeWrapping:\n\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n\n          case MirroredRepeatWrapping:\n\n            if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n              uv.y = Math.ceil( uv.y ) - uv.y;\n\n            } else {\n\n              uv.y = uv.y - Math.floor( uv.y );\n\n            }\n            break;\n\n        }\n\n      }\n\n      if ( this.flipY ) {\n\n        uv.y = 1 - uv.y;\n\n      }\n\n    }\n\n  } );\n\n  /**\n   * @author supereggbert / http://www.paulbrunt.co.uk/\n   * @author philogb / http://blog.thejit.org/\n   * @author mikael emtinger / http://gomo.se/\n   * @author egraether / http://egraether.com/\n   * @author WestLangley / http://github.com/WestLangley\n   */\n\n  function Vector4( x, y, z, w ) {\n\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n    this.w = ( w !== undefined ) ? w : 1;\n\n  }\n\n  Object.assign( Vector4.prototype, {\n\n    isVector4: true,\n\n    set: function ( x, y, z, w ) {\n\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n\n      return this;\n\n    },\n\n    setScalar: function ( scalar ) {\n\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n\n      return this;\n\n    },\n\n    setX: function ( x ) {\n\n      this.x = x;\n\n      return this;\n\n    },\n\n    setY: function ( y ) {\n\n      this.y = y;\n\n      return this;\n\n    },\n\n    setZ: function ( z ) {\n\n      this.z = z;\n\n      return this;\n\n    },\n\n    setW: function ( w ) {\n\n      this.w = w;\n\n      return this;\n\n    },\n\n    setComponent: function ( index, value ) {\n\n      switch ( index ) {\n\n        case 0: this.x = value; break;\n        case 1: this.y = value; break;\n        case 2: this.z = value; break;\n        case 3: this.w = value; break;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n      return this;\n\n    },\n\n    getComponent: function ( index ) {\n\n      switch ( index ) {\n\n        case 0: return this.x;\n        case 1: return this.y;\n        case 2: return this.z;\n        case 3: return this.w;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this.x, this.y, this.z, this.w );\n\n    },\n\n    copy: function ( v ) {\n\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = ( v.w !== undefined ) ? v.w : 1;\n\n      return this;\n\n    },\n\n    add: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n        return this.addVectors( v, w );\n\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n\n      return this;\n\n    },\n\n    addScalar: function ( s ) {\n\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n\n      return this;\n\n    },\n\n    addVectors: function ( a, b ) {\n\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n\n      return this;\n\n    },\n\n    addScaledVector: function ( v, s ) {\n\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n\n      return this;\n\n    },\n\n    sub: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n        return this.subVectors( v, w );\n\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n\n      return this;\n\n    },\n\n    subScalar: function ( s ) {\n\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n\n      return this;\n\n    },\n\n    subVectors: function ( a, b ) {\n\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n\n      return this;\n\n    },\n\n    multiplyScalar: function ( scalar ) {\n\n      if ( isFinite( scalar ) ) {\n\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        this.w *= scalar;\n\n      } else {\n\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n\n      }\n\n      return this;\n\n    },\n\n    applyMatrix4: function ( m ) {\n\n      var x = this.x, y = this.y, z = this.z, w = this.w;\n      var e = m.elements;\n\n      this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n      this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n      this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n      this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n      return this;\n\n    },\n\n    divideScalar: function ( scalar ) {\n\n      return this.multiplyScalar( 1 / scalar );\n\n    },\n\n    setAxisAngleFromQuaternion: function ( q ) {\n\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n      // q is assumed to be normalized\n\n      this.w = 2 * Math.acos( q.w );\n\n      var s = Math.sqrt( 1 - q.w * q.w );\n\n      if ( s < 0.0001 ) {\n\n         this.x = 1;\n         this.y = 0;\n         this.z = 0;\n\n      } else {\n\n         this.x = q.x / s;\n         this.y = q.y / s;\n         this.z = q.z / s;\n\n      }\n\n      return this;\n\n    },\n\n    setAxisAngleFromRotationMatrix: function ( m ) {\n\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n      var angle, x, y, z,   // variables for result\n        epsilon = 0.01,   // margin to allow for rounding errors\n        epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees\n\n        te = m.elements,\n\n        m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n        m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n        m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n      if ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n           ( Math.abs( m13 - m31 ) < epsilon ) &&\n           ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n        // singularity found\n        // first check for identity matrix which must have +1 for all terms\n        // in leading diagonal and zero in other terms\n\n        if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n             ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n             ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n             ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n          // this singularity is identity matrix so angle = 0\n\n          this.set( 1, 0, 0, 0 );\n\n          return this; // zero angle, arbitrary axis\n\n        }\n\n        // otherwise this singularity is angle = 180\n\n        angle = Math.PI;\n\n        var xx = ( m11 + 1 ) / 2;\n        var yy = ( m22 + 1 ) / 2;\n        var zz = ( m33 + 1 ) / 2;\n        var xy = ( m12 + m21 ) / 4;\n        var xz = ( m13 + m31 ) / 4;\n        var yz = ( m23 + m32 ) / 4;\n\n        if ( ( xx > yy ) && ( xx > zz ) ) {\n\n          // m11 is the largest diagonal term\n\n          if ( xx < epsilon ) {\n\n            x = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n\n          } else {\n\n            x = Math.sqrt( xx );\n            y = xy / x;\n            z = xz / x;\n\n          }\n\n        } else if ( yy > zz ) {\n\n          // m22 is the largest diagonal term\n\n          if ( yy < epsilon ) {\n\n            x = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n\n          } else {\n\n            y = Math.sqrt( yy );\n            x = xy / y;\n            z = yz / y;\n\n          }\n\n        } else {\n\n          // m33 is the largest diagonal term so base result on this\n\n          if ( zz < epsilon ) {\n\n            x = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n\n          } else {\n\n            z = Math.sqrt( zz );\n            x = xz / z;\n            y = yz / z;\n\n          }\n\n        }\n\n        this.set( x, y, z, angle );\n\n        return this; // return 180 deg rotation\n\n      }\n\n      // as we have reached here there are no singularities so we can handle normally\n\n      var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n                         ( m13 - m31 ) * ( m13 - m31 ) +\n                         ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n      if ( Math.abs( s ) < 0.001 ) s = 1;\n\n      // prevent divide by zero, should not happen if matrix is orthogonal and should be\n      // caught by singularity test above, but I've left it in just in case\n\n      this.x = ( m32 - m23 ) / s;\n      this.y = ( m13 - m31 ) / s;\n      this.z = ( m21 - m12 ) / s;\n      this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n      return this;\n\n    },\n\n    min: function ( v ) {\n\n      this.x = Math.min( this.x, v.x );\n      this.y = Math.min( this.y, v.y );\n      this.z = Math.min( this.z, v.z );\n      this.w = Math.min( this.w, v.w );\n\n      return this;\n\n    },\n\n    max: function ( v ) {\n\n      this.x = Math.max( this.x, v.x );\n      this.y = Math.max( this.y, v.y );\n      this.z = Math.max( this.z, v.z );\n      this.w = Math.max( this.w, v.w );\n\n      return this;\n\n    },\n\n    clamp: function ( min, max ) {\n\n      // This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n      this.x = Math.max( min.x, Math.min( max.x, this.x ) );\n      this.y = Math.max( min.y, Math.min( max.y, this.y ) );\n      this.z = Math.max( min.z, Math.min( max.z, this.z ) );\n      this.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n      return this;\n\n    },\n\n    clampScalar: function () {\n\n      var min = new Vector4();\n      var max = new Vector4();\n\n      return function clampScalar( minVal, maxVal ) {\n\n        min.set( minVal, minVal, minVal, minVal );\n        max.set( maxVal, maxVal, maxVal, maxVal );\n\n        return this.clamp( min, max );\n\n      };\n\n    }(),\n\n    floor: function () {\n\n      this.x = Math.floor( this.x );\n      this.y = Math.floor( this.y );\n      this.z = Math.floor( this.z );\n      this.w = Math.floor( this.w );\n\n      return this;\n\n    },\n\n    ceil: function () {\n\n      this.x = Math.ceil( this.x );\n      this.y = Math.ceil( this.y );\n      this.z = Math.ceil( this.z );\n      this.w = Math.ceil( this.w );\n\n      return this;\n\n    },\n\n    round: function () {\n\n      this.x = Math.round( this.x );\n      this.y = Math.round( this.y );\n      this.z = Math.round( this.z );\n      this.w = Math.round( this.w );\n\n      return this;\n\n    },\n\n    roundToZero: function () {\n\n      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n      this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n      this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n      return this;\n\n    },\n\n    negate: function () {\n\n      this.x = - this.x;\n      this.y = - this.y;\n      this.z = - this.z;\n      this.w = - this.w;\n\n      return this;\n\n    },\n\n    dot: function ( v ) {\n\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n    },\n\n    lengthSq: function () {\n\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n    },\n\n    length: function () {\n\n      return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n    },\n\n    lengthManhattan: function () {\n\n      return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n    },\n\n    normalize: function () {\n\n      return this.divideScalar( this.length() );\n\n    },\n\n    setLength: function ( length ) {\n\n      return this.multiplyScalar( length / this.length() );\n\n    },\n\n    lerp: function ( v, alpha ) {\n\n      this.x += ( v.x - this.x ) * alpha;\n      this.y += ( v.y - this.y ) * alpha;\n      this.z += ( v.z - this.z ) * alpha;\n      this.w += ( v.w - this.w ) * alpha;\n\n      return this;\n\n    },\n\n    lerpVectors: function ( v1, v2, alpha ) {\n\n      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n    },\n\n    equals: function ( v ) {\n\n      return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.x = array[ offset ];\n      this.y = array[ offset + 1 ];\n      this.z = array[ offset + 2 ];\n      this.w = array[ offset + 3 ];\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this.x;\n      array[ offset + 1 ] = this.y;\n      array[ offset + 2 ] = this.z;\n      array[ offset + 3 ] = this.w;\n\n      return array;\n\n    },\n\n    fromBufferAttribute: function ( attribute, index, offset ) {\n\n      if ( offset !== undefined ) {\n\n        console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\n\n      }\n\n      this.x = attribute.getX( index );\n      this.y = attribute.getY( index );\n      this.z = attribute.getZ( index );\n      this.w = attribute.getW( index );\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author szimek / https://github.com/szimek/\n   * @author alteredq / http://alteredqualia.com/\n   * @author Marius Kintel / https://github.com/kintel\n   */\n\n  /*\n   In options, we can specify:\n   * Texture parameters for an auto-generated target texture\n   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n  */\n  function WebGLRenderTarget( width, height, options ) {\n\n    this.uuid = _Math.generateUUID();\n\n    this.width = width;\n    this.height = height;\n\n    this.scissor = new Vector4( 0, 0, width, height );\n    this.scissorTest = false;\n\n    this.viewport = new Vector4( 0, 0, width, height );\n\n    options = options || {};\n\n    if ( options.minFilter === undefined ) options.minFilter = LinearFilter;\n\n    this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n  }\n\n  Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {\n\n    isWebGLRenderTarget: true,\n\n    setSize: function ( width, height ) {\n\n      if ( this.width !== width || this.height !== height ) {\n\n        this.width = width;\n        this.height = height;\n\n        this.dispose();\n\n      }\n\n      this.viewport.set( 0, 0, width, height );\n      this.scissor.set( 0, 0, width, height );\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      this.width = source.width;\n      this.height = source.height;\n\n      this.viewport.copy( source.viewport );\n\n      this.texture = source.texture.clone();\n\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.depthTexture = source.depthTexture;\n\n      return this;\n\n    },\n\n    dispose: function () {\n\n      this.dispatchEvent( { type: 'dispose' } );\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com\n   */\n\n  function WebGLRenderTargetCube( width, height, options ) {\n\n    WebGLRenderTarget.call( this, width, height, options );\n\n    this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n    this.activeMipMapLevel = 0;\n\n  }\n\n  WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\n  WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\n\n  WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author bhouston / http://clara.io\n   */\n\n  function Quaternion( x, y, z, w ) {\n\n    this._x = x || 0;\n    this._y = y || 0;\n    this._z = z || 0;\n    this._w = ( w !== undefined ) ? w : 1;\n\n  }\n\n  Object.assign( Quaternion, {\n\n    slerp: function( qa, qb, qm, t ) {\n\n      return qm.copy( qa ).slerp( qb, t );\n\n    },\n\n    slerpFlat: function(\n        dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n      // fuzz-free, array-based Quaternion SLERP operation\n\n      var x0 = src0[ srcOffset0 + 0 ],\n        y0 = src0[ srcOffset0 + 1 ],\n        z0 = src0[ srcOffset0 + 2 ],\n        w0 = src0[ srcOffset0 + 3 ],\n\n        x1 = src1[ srcOffset1 + 0 ],\n        y1 = src1[ srcOffset1 + 1 ],\n        z1 = src1[ srcOffset1 + 2 ],\n        w1 = src1[ srcOffset1 + 3 ];\n\n      if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n        var s = 1 - t,\n\n          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n          dir = ( cos >= 0 ? 1 : - 1 ),\n          sqrSin = 1 - cos * cos;\n\n        // Skip the Slerp for tiny steps to avoid numeric problems:\n        if ( sqrSin > Number.EPSILON ) {\n\n          var sin = Math.sqrt( sqrSin ),\n            len = Math.atan2( sin, cos * dir );\n\n          s = Math.sin( s * len ) / sin;\n          t = Math.sin( t * len ) / sin;\n\n        }\n\n        var tDir = t * dir;\n\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n\n        // Normalize in case we just did a lerp:\n        if ( s === 1 - t ) {\n\n          var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n\n        }\n\n      }\n\n      dst[ dstOffset ] = x0;\n      dst[ dstOffset + 1 ] = y0;\n      dst[ dstOffset + 2 ] = z0;\n      dst[ dstOffset + 3 ] = w0;\n\n    }\n\n  } );\n\n  Object.defineProperties( Quaternion.prototype, {\n\n    \"x\" : {\n\n      get: function () {\n\n        return this._x;\n\n      },\n\n      set: function ( value ) {\n\n        this._x = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"y\" : {\n\n      get: function () {\n\n        return this._y;\n\n      },\n\n      set: function ( value ) {\n\n        this._y = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"z\" : {\n\n      get: function () {\n\n        return this._z;\n\n      },\n\n      set: function ( value ) {\n\n        this._z = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"w\" : {\n\n      get: function () {\n\n        return this._w;\n\n      },\n\n      set: function ( value ) {\n\n        this._w = value;\n        this.onChangeCallback();\n\n      }\n\n    }\n\n  });\n\n  Object.assign( Quaternion.prototype, {\n\n    set: function ( x, y, z, w ) {\n\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this._x, this._y, this._z, this._w );\n\n    },\n\n    copy: function ( quaternion ) {\n\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromEuler: function ( euler, update ) {\n\n      if ( (euler && euler.isEuler) === false ) {\n\n        throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n      }\n\n      // http://www.mathworks.com/matlabcentral/fileexchange/\n      //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n      //  content/SpinCalc.m\n\n      var c1 = Math.cos( euler._x / 2 );\n      var c2 = Math.cos( euler._y / 2 );\n      var c3 = Math.cos( euler._z / 2 );\n      var s1 = Math.sin( euler._x / 2 );\n      var s2 = Math.sin( euler._y / 2 );\n      var s3 = Math.sin( euler._z / 2 );\n\n      var order = euler.order;\n\n      if ( order === 'XYZ' ) {\n\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n      } else if ( order === 'YXZ' ) {\n\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n      } else if ( order === 'ZXY' ) {\n\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n      } else if ( order === 'ZYX' ) {\n\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n      } else if ( order === 'YZX' ) {\n\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n      } else if ( order === 'XZY' ) {\n\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n      }\n\n      if ( update !== false ) this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromAxisAngle: function ( axis, angle ) {\n\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n      // assumes axis is normalized\n\n      var halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos( halfAngle );\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromRotationMatrix: function ( m ) {\n\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n      var te = m.elements,\n\n        m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n        m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n        m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n        trace = m11 + m22 + m33,\n        s;\n\n      if ( trace > 0 ) {\n\n        s = 0.5 / Math.sqrt( trace + 1.0 );\n\n        this._w = 0.25 / s;\n        this._x = ( m32 - m23 ) * s;\n        this._y = ( m13 - m31 ) * s;\n        this._z = ( m21 - m12 ) * s;\n\n      } else if ( m11 > m22 && m11 > m33 ) {\n\n        s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n        this._w = ( m32 - m23 ) / s;\n        this._x = 0.25 * s;\n        this._y = ( m12 + m21 ) / s;\n        this._z = ( m13 + m31 ) / s;\n\n      } else if ( m22 > m33 ) {\n\n        s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n        this._w = ( m13 - m31 ) / s;\n        this._x = ( m12 + m21 ) / s;\n        this._y = 0.25 * s;\n        this._z = ( m23 + m32 ) / s;\n\n      } else {\n\n        s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n        this._w = ( m21 - m12 ) / s;\n        this._x = ( m13 + m31 ) / s;\n        this._y = ( m23 + m32 ) / s;\n        this._z = 0.25 * s;\n\n      }\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromUnitVectors: function () {\n\n      // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n      // assumes direction vectors vFrom and vTo are normalized\n\n      var v1 = new Vector3();\n      var r;\n\n      var EPS = 0.000001;\n\n      return function setFromUnitVectors( vFrom, vTo ) {\n\n        if ( v1 === undefined ) v1 = new Vector3();\n\n        r = vFrom.dot( vTo ) + 1;\n\n        if ( r < EPS ) {\n\n          r = 0;\n\n          if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n            v1.set( - vFrom.y, vFrom.x, 0 );\n\n          } else {\n\n            v1.set( 0, - vFrom.z, vFrom.y );\n\n          }\n\n        } else {\n\n          v1.crossVectors( vFrom, vTo );\n\n        }\n\n        this._x = v1.x;\n        this._y = v1.y;\n        this._z = v1.z;\n        this._w = r;\n\n        return this.normalize();\n\n      };\n\n    }(),\n\n    inverse: function () {\n\n      return this.conjugate().normalize();\n\n    },\n\n    conjugate: function () {\n\n      this._x *= - 1;\n      this._y *= - 1;\n      this._z *= - 1;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    dot: function ( v ) {\n\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n    },\n\n    lengthSq: function () {\n\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n    },\n\n    length: function () {\n\n      return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n    },\n\n    normalize: function () {\n\n      var l = this.length();\n\n      if ( l === 0 ) {\n\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n\n      } else {\n\n        l = 1 / l;\n\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n\n      }\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    multiply: function ( q, p ) {\n\n      if ( p !== undefined ) {\n\n        console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n        return this.multiplyQuaternions( q, p );\n\n      }\n\n      return this.multiplyQuaternions( this, q );\n\n    },\n\n    premultiply: function ( q ) {\n\n      return this.multiplyQuaternions( q, this );\n\n    },\n\n    multiplyQuaternions: function ( a, b ) {\n\n      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n      var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    slerp: function ( qb, t ) {\n\n      if ( t === 0 ) return this;\n      if ( t === 1 ) return this.copy( qb );\n\n      var x = this._x, y = this._y, z = this._z, w = this._w;\n\n      // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n      if ( cosHalfTheta < 0 ) {\n\n        this._w = - qb._w;\n        this._x = - qb._x;\n        this._y = - qb._y;\n        this._z = - qb._z;\n\n        cosHalfTheta = - cosHalfTheta;\n\n      } else {\n\n        this.copy( qb );\n\n      }\n\n      if ( cosHalfTheta >= 1.0 ) {\n\n        this._w = w;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n\n        return this;\n\n      }\n\n      var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n      if ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n        this._w = 0.5 * ( w + this._w );\n        this._x = 0.5 * ( x + this._x );\n        this._y = 0.5 * ( y + this._y );\n        this._z = 0.5 * ( z + this._z );\n\n        return this;\n\n      }\n\n      var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n      var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n        ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n      this._w = ( w * ratioA + this._w * ratioB );\n      this._x = ( x * ratioA + this._x * ratioB );\n      this._y = ( y * ratioA + this._y * ratioB );\n      this._z = ( z * ratioA + this._z * ratioB );\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    equals: function ( quaternion ) {\n\n      return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this._x = array[ offset ];\n      this._y = array[ offset + 1 ];\n      this._z = array[ offset + 2 ];\n      this._w = array[ offset + 3 ];\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this._x;\n      array[ offset + 1 ] = this._y;\n      array[ offset + 2 ] = this._z;\n      array[ offset + 3 ] = this._w;\n\n      return array;\n\n    },\n\n    onChange: function ( callback ) {\n\n      this.onChangeCallback = callback;\n\n      return this;\n\n    },\n\n    onChangeCallback: function () {}\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author *kile / http://kile.stravaganza.org/\n   * @author philogb / http://blog.thejit.org/\n   * @author mikael emtinger / http://gomo.se/\n   * @author egraether / http://egraether.com/\n   * @author WestLangley / http://github.com/WestLangley\n   */\n\n  function Vector3( x, y, z ) {\n\n    this.x = x || 0;\n    this.y = y || 0;\n    this.z = z || 0;\n\n  }\n\n  Object.assign( Vector3.prototype, {\n\n    isVector3: true,\n\n    set: function ( x, y, z ) {\n\n      this.x = x;\n      this.y = y;\n      this.z = z;\n\n      return this;\n\n    },\n\n    setScalar: function ( scalar ) {\n\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n\n      return this;\n\n    },\n\n    setX: function ( x ) {\n\n      this.x = x;\n\n      return this;\n\n    },\n\n    setY: function ( y ) {\n\n      this.y = y;\n\n      return this;\n\n    },\n\n    setZ: function ( z ) {\n\n      this.z = z;\n\n      return this;\n\n    },\n\n    setComponent: function ( index, value ) {\n\n      switch ( index ) {\n\n        case 0: this.x = value; break;\n        case 1: this.y = value; break;\n        case 2: this.z = value; break;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n      return this;\n\n    },\n\n    getComponent: function ( index ) {\n\n      switch ( index ) {\n\n        case 0: return this.x;\n        case 1: return this.y;\n        case 2: return this.z;\n        default: throw new Error( 'index is out of range: ' + index );\n\n      }\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this.x, this.y, this.z );\n\n    },\n\n    copy: function ( v ) {\n\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n\n      return this;\n\n    },\n\n    add: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n        return this.addVectors( v, w );\n\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n\n      return this;\n\n    },\n\n    addScalar: function ( s ) {\n\n      this.x += s;\n      this.y += s;\n      this.z += s;\n\n      return this;\n\n    },\n\n    addVectors: function ( a, b ) {\n\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n\n      return this;\n\n    },\n\n    addScaledVector: function ( v, s ) {\n\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n\n      return this;\n\n    },\n\n    sub: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n        return this.subVectors( v, w );\n\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n\n      return this;\n\n    },\n\n    subScalar: function ( s ) {\n\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n\n      return this;\n\n    },\n\n    subVectors: function ( a, b ) {\n\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n\n      return this;\n\n    },\n\n    multiply: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n        return this.multiplyVectors( v, w );\n\n      }\n\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n\n      return this;\n\n    },\n\n    multiplyScalar: function ( scalar ) {\n\n      if ( isFinite( scalar ) ) {\n\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n\n      } else {\n\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n\n      }\n\n      return this;\n\n    },\n\n    multiplyVectors: function ( a, b ) {\n\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n\n      return this;\n\n    },\n\n    applyEuler: function () {\n\n      var quaternion = new Quaternion();\n\n      return function applyEuler( euler ) {\n\n        if ( (euler && euler.isEuler) === false ) {\n\n          console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n        }\n\n        return this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n      };\n\n    }(),\n\n    applyAxisAngle: function () {\n\n      var quaternion = new Quaternion();\n\n      return function applyAxisAngle( axis, angle ) {\n\n        return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n      };\n\n    }(),\n\n    applyMatrix3: function ( m ) {\n\n      var x = this.x, y = this.y, z = this.z;\n      var e = m.elements;\n\n      this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n      this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n      this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n      return this;\n\n    },\n\n    applyMatrix4: function ( m ) {\n\n      var x = this.x, y = this.y, z = this.z;\n      var e = m.elements;\n\n      this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n      this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n      this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n      var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];\n\n      return this.divideScalar( w );\n\n    },\n\n    applyQuaternion: function ( q ) {\n\n      var x = this.x, y = this.y, z = this.z;\n      var qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n      // calculate quat * vector\n\n      var ix =  qw * x + qy * z - qz * y;\n      var iy =  qw * y + qz * x - qx * z;\n      var iz =  qw * z + qx * y - qy * x;\n      var iw = - qx * x - qy * y - qz * z;\n\n      // calculate result * inverse quat\n\n      this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n      this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n      this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n      return this;\n\n    },\n\n    project: function () {\n\n      var matrix = new Matrix4();\n\n      return function project( camera ) {\n\n        matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n        return this.applyMatrix4( matrix );\n\n      };\n\n    }(),\n\n    unproject: function () {\n\n      var matrix = new Matrix4();\n\n      return function unproject( camera ) {\n\n        matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n        return this.applyMatrix4( matrix );\n\n      };\n\n    }(),\n\n    transformDirection: function ( m ) {\n\n      // input: THREE.Matrix4 affine matrix\n      // vector interpreted as a direction\n\n      var x = this.x, y = this.y, z = this.z;\n      var e = m.elements;\n\n      this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n      this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n      this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n      return this.normalize();\n\n    },\n\n    divide: function ( v ) {\n\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n\n      return this;\n\n    },\n\n    divideScalar: function ( scalar ) {\n\n      return this.multiplyScalar( 1 / scalar );\n\n    },\n\n    min: function ( v ) {\n\n      this.x = Math.min( this.x, v.x );\n      this.y = Math.min( this.y, v.y );\n      this.z = Math.min( this.z, v.z );\n\n      return this;\n\n    },\n\n    max: function ( v ) {\n\n      this.x = Math.max( this.x, v.x );\n      this.y = Math.max( this.y, v.y );\n      this.z = Math.max( this.z, v.z );\n\n      return this;\n\n    },\n\n    clamp: function ( min, max ) {\n\n      // This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n      this.x = Math.max( min.x, Math.min( max.x, this.x ) );\n      this.y = Math.max( min.y, Math.min( max.y, this.y ) );\n      this.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n      return this;\n\n    },\n\n    clampScalar: function () {\n\n      var min = new Vector3();\n      var max = new Vector3();\n\n      return function clampScalar( minVal, maxVal ) {\n\n        min.set( minVal, minVal, minVal );\n        max.set( maxVal, maxVal, maxVal );\n\n        return this.clamp( min, max );\n\n      };\n\n    }(),\n\n    clampLength: function ( min, max ) {\n\n      var length = this.length();\n\n      return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n    },\n\n    floor: function () {\n\n      this.x = Math.floor( this.x );\n      this.y = Math.floor( this.y );\n      this.z = Math.floor( this.z );\n\n      return this;\n\n    },\n\n    ceil: function () {\n\n      this.x = Math.ceil( this.x );\n      this.y = Math.ceil( this.y );\n      this.z = Math.ceil( this.z );\n\n      return this;\n\n    },\n\n    round: function () {\n\n      this.x = Math.round( this.x );\n      this.y = Math.round( this.y );\n      this.z = Math.round( this.z );\n\n      return this;\n\n    },\n\n    roundToZero: function () {\n\n      this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n      this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n      this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n      return this;\n\n    },\n\n    negate: function () {\n\n      this.x = - this.x;\n      this.y = - this.y;\n      this.z = - this.z;\n\n      return this;\n\n    },\n\n    dot: function ( v ) {\n\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n\n    },\n\n    lengthSq: function () {\n\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n\n    },\n\n    length: function () {\n\n      return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n    },\n\n    lengthManhattan: function () {\n\n      return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n    },\n\n    normalize: function () {\n\n      return this.divideScalar( this.length() );\n\n    },\n\n    setLength: function ( length ) {\n\n      return this.multiplyScalar( length / this.length() );\n\n    },\n\n    lerp: function ( v, alpha ) {\n\n      this.x += ( v.x - this.x ) * alpha;\n      this.y += ( v.y - this.y ) * alpha;\n      this.z += ( v.z - this.z ) * alpha;\n\n      return this;\n\n    },\n\n    lerpVectors: function ( v1, v2, alpha ) {\n\n      return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n    },\n\n    cross: function ( v, w ) {\n\n      if ( w !== undefined ) {\n\n        console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n        return this.crossVectors( v, w );\n\n      }\n\n      var x = this.x, y = this.y, z = this.z;\n\n      this.x = y * v.z - z * v.y;\n      this.y = z * v.x - x * v.z;\n      this.z = x * v.y - y * v.x;\n\n      return this;\n\n    },\n\n    crossVectors: function ( a, b ) {\n\n      var ax = a.x, ay = a.y, az = a.z;\n      var bx = b.x, by = b.y, bz = b.z;\n\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n\n      return this;\n\n    },\n\n    projectOnVector: function ( vector ) {\n\n      var scalar = vector.dot( this ) / vector.lengthSq();\n\n      return this.copy( vector ).multiplyScalar( scalar );\n\n    },\n\n    projectOnPlane: function () {\n\n      var v1 = new Vector3();\n\n      return function projectOnPlane( planeNormal ) {\n\n        v1.copy( this ).projectOnVector( planeNormal );\n\n        return this.sub( v1 );\n\n      };\n\n    }(),\n\n    reflect: function () {\n\n      // reflect incident vector off plane orthogonal to normal\n      // normal is assumed to have unit length\n\n      var v1 = new Vector3();\n\n      return function reflect( normal ) {\n\n        return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n      };\n\n    }(),\n\n    angleTo: function ( v ) {\n\n      var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n      // clamp, to handle numerical problems\n\n      return Math.acos( _Math.clamp( theta, - 1, 1 ) );\n\n    },\n\n    distanceTo: function ( v ) {\n\n      return Math.sqrt( this.distanceToSquared( v ) );\n\n    },\n\n    distanceToSquared: function ( v ) {\n\n      var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n      return dx * dx + dy * dy + dz * dz;\n\n    },\n\n    distanceToManhattan: function ( v ) {\n\n      return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n    },\n\n    setFromSpherical: function( s ) {\n\n      var sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n      this.x = sinPhiRadius * Math.sin( s.theta );\n      this.y = Math.cos( s.phi ) * s.radius;\n      this.z = sinPhiRadius * Math.cos( s.theta );\n\n      return this;\n\n    },\n\n    setFromCylindrical: function( c ) {\n\n      this.x = c.radius * Math.sin( c.theta );\n      this.y = c.y;\n      this.z = c.radius * Math.cos( c.theta );\n\n      return this;\n\n    },\n\n    setFromMatrixPosition: function ( m ) {\n\n      return this.setFromMatrixColumn( m, 3 );\n\n    },\n\n    setFromMatrixScale: function ( m ) {\n\n      var sx = this.setFromMatrixColumn( m, 0 ).length();\n      var sy = this.setFromMatrixColumn( m, 1 ).length();\n      var sz = this.setFromMatrixColumn( m, 2 ).length();\n\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n\n      return this;\n\n    },\n\n    setFromMatrixColumn: function ( m, index ) {\n\n      if ( typeof m === 'number' ) {\n\n        console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n        var temp = m;\n        m = index;\n        index = temp;\n\n      }\n\n      return this.fromArray( m.elements, index * 4 );\n\n    },\n\n    equals: function ( v ) {\n\n      return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.x = array[ offset ];\n      this.y = array[ offset + 1 ];\n      this.z = array[ offset + 2 ];\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this.x;\n      array[ offset + 1 ] = this.y;\n      array[ offset + 2 ] = this.z;\n\n      return array;\n\n    },\n\n    fromBufferAttribute: function ( attribute, index, offset ) {\n\n      if ( offset !== undefined ) {\n\n        console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n      }\n\n      this.x = attribute.getX( index );\n      this.y = attribute.getY( index );\n      this.z = attribute.getZ( index );\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author supereggbert / http://www.paulbrunt.co.uk/\n   * @author philogb / http://blog.thejit.org/\n   * @author jordi_ros / http://plattsoft.com\n   * @author D1plo1d / http://github.com/D1plo1d\n   * @author alteredq / http://alteredqualia.com/\n   * @author mikael emtinger / http://gomo.se/\n   * @author timknip / http://www.floorplanner.com/\n   * @author bhouston / http://clara.io\n   * @author WestLangley / http://github.com/WestLangley\n   */\n\n  function Matrix4() {\n\n    this.elements = new Float32Array( [\n\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1\n\n    ] );\n\n    if ( arguments.length > 0 ) {\n\n      console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n    }\n\n  }\n\n  Object.assign( Matrix4.prototype, {\n\n    isMatrix4: true,\n\n    set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n      var te = this.elements;\n\n      te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n      te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n      te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n      te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n      return this;\n\n    },\n\n    identity: function () {\n\n      this.set(\n\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new Matrix4().fromArray( this.elements );\n\n    },\n\n    copy: function ( m ) {\n\n      this.elements.set( m.elements );\n\n      return this;\n\n    },\n\n    copyPosition: function ( m ) {\n\n      var te = this.elements;\n      var me = m.elements;\n\n      te[ 12 ] = me[ 12 ];\n      te[ 13 ] = me[ 13 ];\n      te[ 14 ] = me[ 14 ];\n\n      return this;\n\n    },\n\n    extractBasis: function ( xAxis, yAxis, zAxis ) {\n\n      xAxis.setFromMatrixColumn( this, 0 );\n      yAxis.setFromMatrixColumn( this, 1 );\n      zAxis.setFromMatrixColumn( this, 2 );\n\n      return this;\n\n    },\n\n    makeBasis: function ( xAxis, yAxis, zAxis ) {\n\n      this.set(\n        xAxis.x, yAxis.x, zAxis.x, 0,\n        xAxis.y, yAxis.y, zAxis.y, 0,\n        xAxis.z, yAxis.z, zAxis.z, 0,\n        0,       0,       0,       1\n      );\n\n      return this;\n\n    },\n\n    extractRotation: function () {\n\n      var v1 = new Vector3();\n\n      return function extractRotation( m ) {\n\n        var te = this.elements;\n        var me = m.elements;\n\n        var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n        var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n        var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n        te[ 0 ] = me[ 0 ] * scaleX;\n        te[ 1 ] = me[ 1 ] * scaleX;\n        te[ 2 ] = me[ 2 ] * scaleX;\n\n        te[ 4 ] = me[ 4 ] * scaleY;\n        te[ 5 ] = me[ 5 ] * scaleY;\n        te[ 6 ] = me[ 6 ] * scaleY;\n\n        te[ 8 ] = me[ 8 ] * scaleZ;\n        te[ 9 ] = me[ 9 ] * scaleZ;\n        te[ 10 ] = me[ 10 ] * scaleZ;\n\n        return this;\n\n      };\n\n    }(),\n\n    makeRotationFromEuler: function ( euler ) {\n\n      if ( (euler && euler.isEuler) === false ) {\n\n        console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n      }\n\n      var te = this.elements;\n\n      var x = euler.x, y = euler.y, z = euler.z;\n      var a = Math.cos( x ), b = Math.sin( x );\n      var c = Math.cos( y ), d = Math.sin( y );\n      var e = Math.cos( z ), f = Math.sin( z );\n\n      if ( euler.order === 'XYZ' ) {\n\n        var ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n        te[ 0 ] = c * e;\n        te[ 4 ] = - c * f;\n        te[ 8 ] = d;\n\n        te[ 1 ] = af + be * d;\n        te[ 5 ] = ae - bf * d;\n        te[ 9 ] = - b * c;\n\n        te[ 2 ] = bf - ae * d;\n        te[ 6 ] = be + af * d;\n        te[ 10 ] = a * c;\n\n      } else if ( euler.order === 'YXZ' ) {\n\n        var ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n        te[ 0 ] = ce + df * b;\n        te[ 4 ] = de * b - cf;\n        te[ 8 ] = a * d;\n\n        te[ 1 ] = a * f;\n        te[ 5 ] = a * e;\n        te[ 9 ] = - b;\n\n        te[ 2 ] = cf * b - de;\n        te[ 6 ] = df + ce * b;\n        te[ 10 ] = a * c;\n\n      } else if ( euler.order === 'ZXY' ) {\n\n        var ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n        te[ 0 ] = ce - df * b;\n        te[ 4 ] = - a * f;\n        te[ 8 ] = de + cf * b;\n\n        te[ 1 ] = cf + de * b;\n        te[ 5 ] = a * e;\n        te[ 9 ] = df - ce * b;\n\n        te[ 2 ] = - a * d;\n        te[ 6 ] = b;\n        te[ 10 ] = a * c;\n\n      } else if ( euler.order === 'ZYX' ) {\n\n        var ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n        te[ 0 ] = c * e;\n        te[ 4 ] = be * d - af;\n        te[ 8 ] = ae * d + bf;\n\n        te[ 1 ] = c * f;\n        te[ 5 ] = bf * d + ae;\n        te[ 9 ] = af * d - be;\n\n        te[ 2 ] = - d;\n        te[ 6 ] = b * c;\n        te[ 10 ] = a * c;\n\n      } else if ( euler.order === 'YZX' ) {\n\n        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n        te[ 0 ] = c * e;\n        te[ 4 ] = bd - ac * f;\n        te[ 8 ] = bc * f + ad;\n\n        te[ 1 ] = f;\n        te[ 5 ] = a * e;\n        te[ 9 ] = - b * e;\n\n        te[ 2 ] = - d * e;\n        te[ 6 ] = ad * f + bc;\n        te[ 10 ] = ac - bd * f;\n\n      } else if ( euler.order === 'XZY' ) {\n\n        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n        te[ 0 ] = c * e;\n        te[ 4 ] = - f;\n        te[ 8 ] = d * e;\n\n        te[ 1 ] = ac * f + bd;\n        te[ 5 ] = a * e;\n        te[ 9 ] = ad * f - bc;\n\n        te[ 2 ] = bc * f - ad;\n        te[ 6 ] = b * e;\n        te[ 10 ] = bd * f + ac;\n\n      }\n\n      // last column\n      te[ 3 ] = 0;\n      te[ 7 ] = 0;\n      te[ 11 ] = 0;\n\n      // bottom row\n      te[ 12 ] = 0;\n      te[ 13 ] = 0;\n      te[ 14 ] = 0;\n      te[ 15 ] = 1;\n\n      return this;\n\n    },\n\n    makeRotationFromQuaternion: function ( q ) {\n\n      var te = this.elements;\n\n      var x = q.x, y = q.y, z = q.z, w = q.w;\n      var x2 = x + x, y2 = y + y, z2 = z + z;\n      var xx = x * x2, xy = x * y2, xz = x * z2;\n      var yy = y * y2, yz = y * z2, zz = z * z2;\n      var wx = w * x2, wy = w * y2, wz = w * z2;\n\n      te[ 0 ] = 1 - ( yy + zz );\n      te[ 4 ] = xy - wz;\n      te[ 8 ] = xz + wy;\n\n      te[ 1 ] = xy + wz;\n      te[ 5 ] = 1 - ( xx + zz );\n      te[ 9 ] = yz - wx;\n\n      te[ 2 ] = xz - wy;\n      te[ 6 ] = yz + wx;\n      te[ 10 ] = 1 - ( xx + yy );\n\n      // last column\n      te[ 3 ] = 0;\n      te[ 7 ] = 0;\n      te[ 11 ] = 0;\n\n      // bottom row\n      te[ 12 ] = 0;\n      te[ 13 ] = 0;\n      te[ 14 ] = 0;\n      te[ 15 ] = 1;\n\n      return this;\n\n    },\n\n    lookAt: function () {\n\n      var x = new Vector3();\n      var y = new Vector3();\n      var z = new Vector3();\n\n      return function lookAt( eye, target, up ) {\n\n        var te = this.elements;\n\n        z.subVectors( eye, target ).normalize();\n\n        if ( z.lengthSq() === 0 ) {\n\n          z.z = 1;\n\n        }\n\n        x.crossVectors( up, z ).normalize();\n\n        if ( x.lengthSq() === 0 ) {\n\n          z.z += 0.0001;\n          x.crossVectors( up, z ).normalize();\n\n        }\n\n        y.crossVectors( z, x );\n\n\n        te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n        te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n        te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n        return this;\n\n      };\n\n    }(),\n\n    multiply: function ( m, n ) {\n\n      if ( n !== undefined ) {\n\n        console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n        return this.multiplyMatrices( m, n );\n\n      }\n\n      return this.multiplyMatrices( this, m );\n\n    },\n\n    premultiply: function ( m ) {\n\n      return this.multiplyMatrices( m, this );\n\n    },\n\n    multiplyMatrices: function ( a, b ) {\n\n      var ae = a.elements;\n      var be = b.elements;\n      var te = this.elements;\n\n      var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n      var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n      var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n      var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n      var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n      var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n      var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n      var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n      te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n      te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n      te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n      te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n      return this;\n\n    },\n\n    multiplyToArray: function ( a, b, r ) {\n\n      var te = this.elements;\n\n      this.multiplyMatrices( a, b );\n\n      r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n      r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n      r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n      r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n      return this;\n\n    },\n\n    multiplyScalar: function ( s ) {\n\n      var te = this.elements;\n\n      te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n      te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n      te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n      te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n      return this;\n\n    },\n\n    applyToBufferAttribute: function () {\n\n      var v1 = new Vector3();\n\n      return function applyToBufferAttribute( attribute ) {\n\n        for ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n          v1.x = attribute.getX( i );\n          v1.y = attribute.getY( i );\n          v1.z = attribute.getZ( i );\n\n          v1.applyMatrix4( this );\n\n          attribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n        }\n\n        return attribute;\n\n      };\n\n    }(),\n\n    determinant: function () {\n\n      var te = this.elements;\n\n      var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n      var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n      var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n      var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n      //TODO: make this more efficient\n      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n      return (\n        n41 * (\n          + n14 * n23 * n32\n           - n13 * n24 * n32\n           - n14 * n22 * n33\n           + n12 * n24 * n33\n           + n13 * n22 * n34\n           - n12 * n23 * n34\n        ) +\n        n42 * (\n          + n11 * n23 * n34\n           - n11 * n24 * n33\n           + n14 * n21 * n33\n           - n13 * n21 * n34\n           + n13 * n24 * n31\n           - n14 * n23 * n31\n        ) +\n        n43 * (\n          + n11 * n24 * n32\n           - n11 * n22 * n34\n           - n14 * n21 * n32\n           + n12 * n21 * n34\n           + n14 * n22 * n31\n           - n12 * n24 * n31\n        ) +\n        n44 * (\n          - n13 * n22 * n31\n           - n11 * n23 * n32\n           + n11 * n22 * n33\n           + n13 * n21 * n32\n           - n12 * n21 * n33\n           + n12 * n23 * n31\n        )\n\n      );\n\n    },\n\n    transpose: function () {\n\n      var te = this.elements;\n      var tmp;\n\n      tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n      tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n      tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n      tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n      tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n      tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n      return this;\n\n    },\n\n    setPosition: function ( v ) {\n\n      var te = this.elements;\n\n      te[ 12 ] = v.x;\n      te[ 13 ] = v.y;\n      te[ 14 ] = v.z;\n\n      return this;\n\n    },\n\n    getInverse: function ( m, throwOnDegenerate ) {\n\n      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n      var te = this.elements,\n        me = m.elements,\n\n        n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n        n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n        n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n        n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n        t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n        t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n        t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n        t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n      if ( det === 0 ) {\n\n        var msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n        if ( throwOnDegenerate === true ) {\n\n          throw new Error( msg );\n\n        } else {\n\n          console.warn( msg );\n\n        }\n\n        return this.identity();\n\n      }\n\n      var detInv = 1 / det;\n\n      te[ 0 ] = t11 * detInv;\n      te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n      te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n      te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n      te[ 4 ] = t12 * detInv;\n      te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n      te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n      te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n      te[ 8 ] = t13 * detInv;\n      te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n      te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n      te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n      te[ 12 ] = t14 * detInv;\n      te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n      te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n      te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n      return this;\n\n    },\n\n    scale: function ( v ) {\n\n      var te = this.elements;\n      var x = v.x, y = v.y, z = v.z;\n\n      te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n      te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n      te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n      te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n      return this;\n\n    },\n\n    getMaxScaleOnAxis: function () {\n\n      var te = this.elements;\n\n      var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n      var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n      var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n      return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n    },\n\n    makeTranslation: function ( x, y, z ) {\n\n      this.set(\n\n        1, 0, 0, x,\n        0, 1, 0, y,\n        0, 0, 1, z,\n        0, 0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    makeRotationX: function ( theta ) {\n\n      var c = Math.cos( theta ), s = Math.sin( theta );\n\n      this.set(\n\n        1, 0,  0, 0,\n        0, c, - s, 0,\n        0, s,  c, 0,\n        0, 0,  0, 1\n\n      );\n\n      return this;\n\n    },\n\n    makeRotationY: function ( theta ) {\n\n      var c = Math.cos( theta ), s = Math.sin( theta );\n\n      this.set(\n\n         c, 0, s, 0,\n         0, 1, 0, 0,\n        - s, 0, c, 0,\n         0, 0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    makeRotationZ: function ( theta ) {\n\n      var c = Math.cos( theta ), s = Math.sin( theta );\n\n      this.set(\n\n        c, - s, 0, 0,\n        s,  c, 0, 0,\n        0,  0, 1, 0,\n        0,  0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    makeRotationAxis: function ( axis, angle ) {\n\n      // Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n      var c = Math.cos( angle );\n      var s = Math.sin( angle );\n      var t = 1 - c;\n      var x = axis.x, y = axis.y, z = axis.z;\n      var tx = t * x, ty = t * y;\n\n      this.set(\n\n        tx * x + c, tx * y - s * z, tx * z + s * y, 0,\n        tx * y + s * z, ty * y + c, ty * z - s * x, 0,\n        tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n        0, 0, 0, 1\n\n      );\n\n       return this;\n\n    },\n\n    makeScale: function ( x, y, z ) {\n\n      this.set(\n\n        x, 0, 0, 0,\n        0, y, 0, 0,\n        0, 0, z, 0,\n        0, 0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    makeShear: function ( x, y, z ) {\n\n      this.set(\n\n        1, y, z, 0,\n        x, 1, z, 0,\n        x, y, 1, 0,\n        0, 0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    compose: function ( position, quaternion, scale ) {\n\n      this.makeRotationFromQuaternion( quaternion );\n      this.scale( scale );\n      this.setPosition( position );\n\n      return this;\n\n    },\n\n    decompose: function () {\n\n      var vector = new Vector3();\n      var matrix = new Matrix4();\n\n      return function decompose( position, quaternion, scale ) {\n\n        var te = this.elements;\n\n        var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n        var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n        var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n        // if determine is negative, we need to invert one scale\n        var det = this.determinant();\n        if ( det < 0 ) {\n\n          sx = - sx;\n\n        }\n\n        position.x = te[ 12 ];\n        position.y = te[ 13 ];\n        position.z = te[ 14 ];\n\n        // scale the rotation part\n\n        matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n        var invSX = 1 / sx;\n        var invSY = 1 / sy;\n        var invSZ = 1 / sz;\n\n        matrix.elements[ 0 ] *= invSX;\n        matrix.elements[ 1 ] *= invSX;\n        matrix.elements[ 2 ] *= invSX;\n\n        matrix.elements[ 4 ] *= invSY;\n        matrix.elements[ 5 ] *= invSY;\n        matrix.elements[ 6 ] *= invSY;\n\n        matrix.elements[ 8 ] *= invSZ;\n        matrix.elements[ 9 ] *= invSZ;\n        matrix.elements[ 10 ] *= invSZ;\n\n        quaternion.setFromRotationMatrix( matrix );\n\n        scale.x = sx;\n        scale.y = sy;\n        scale.z = sz;\n\n        return this;\n\n      };\n\n    }(),\n\n    makePerspective: function ( left, right, top, bottom, near, far ) {\n\n      if ( far === undefined ) {\n\n        console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n      }\n\n      var te = this.elements;\n      var x = 2 * near / ( right - left );\n      var y = 2 * near / ( top - bottom );\n\n      var a = ( right + left ) / ( right - left );\n      var b = ( top + bottom ) / ( top - bottom );\n      var c = - ( far + near ) / ( far - near );\n      var d = - 2 * far * near / ( far - near );\n\n      te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;\n      te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;\n      te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;\n      te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;\n\n      return this;\n\n    },\n\n    makeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n      var te = this.elements;\n      var w = 1.0 / ( right - left );\n      var h = 1.0 / ( top - bottom );\n      var p = 1.0 / ( far - near );\n\n      var x = ( right + left ) * w;\n      var y = ( top + bottom ) * h;\n      var z = ( far + near ) * p;\n\n      te[ 0 ] = 2 * w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;\n      te[ 1 ] = 0;  te[ 5 ] = 2 * h;  te[ 9 ] = 0;  te[ 13 ] = - y;\n      te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 * p; te[ 14 ] = - z;\n      te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;\n\n      return this;\n\n    },\n\n    equals: function ( matrix ) {\n\n      var te = this.elements;\n      var me = matrix.elements;\n\n      for ( var i = 0; i < 16; i ++ ) {\n\n        if ( te[ i ] !== me[ i ] ) return false;\n\n      }\n\n      return true;\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      for( var i = 0; i < 16; i ++ ) {\n\n        this.elements[ i ] = array[ i + offset ];\n\n      }\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      var te = this.elements;\n\n      array[ offset ] = te[ 0 ];\n      array[ offset + 1 ] = te[ 1 ];\n      array[ offset + 2 ] = te[ 2 ];\n      array[ offset + 3 ] = te[ 3 ];\n\n      array[ offset + 4 ] = te[ 4 ];\n      array[ offset + 5 ] = te[ 5 ];\n      array[ offset + 6 ] = te[ 6 ];\n      array[ offset + 7 ] = te[ 7 ];\n\n      array[ offset + 8 ]  = te[ 8 ];\n      array[ offset + 9 ]  = te[ 9 ];\n      array[ offset + 10 ] = te[ 10 ];\n      array[ offset + 11 ] = te[ 11 ];\n\n      array[ offset + 12 ] = te[ 12 ];\n      array[ offset + 13 ] = te[ 13 ];\n      array[ offset + 14 ] = te[ 14 ];\n      array[ offset + 15 ] = te[ 15 ];\n\n      return array;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n    images = images !== undefined ? images : [];\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n    Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n    this.flipY = false;\n\n  }\n\n  CubeTexture.prototype = Object.create( Texture.prototype );\n  CubeTexture.prototype.constructor = CubeTexture;\n\n  CubeTexture.prototype.isCubeTexture = true;\n\n  Object.defineProperty( CubeTexture.prototype, 'images', {\n\n    get: function () {\n\n      return this.image;\n\n    },\n\n    set: function ( value ) {\n\n      this.image = value;\n\n    }\n\n  } );\n\n  /**\n   * @author tschw\n   *\n   * Uniforms of a program.\n   * Those form a tree structure with a special top-level container for the root,\n   * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n   *\n   *\n   * Properties of inner nodes including the top-level container:\n   *\n   * .seq - array of nested uniforms\n   * .map - nested uniforms by name\n   *\n   *\n   * Methods of all nodes except the top-level container:\n   *\n   * .setValue( gl, value, [renderer] )\n   *\n   *    uploads a uniform value(s)\n   *    the 'renderer' parameter is needed for sampler uniforms\n   *\n   *\n   * Static methods of the top-level container (renderer factorizations):\n   *\n   * .upload( gl, seq, values, renderer )\n   *\n   *    sets uniforms in 'seq' to 'values[id].value'\n   *\n   * .seqWithValue( seq, values ) : filteredSeq\n   *\n   *    filters 'seq' entries with corresponding entry in values\n   *\n   *\n   * Methods of the top-level container (renderer factorizations):\n   *\n   * .setValue( gl, name, value )\n   *\n   *    sets uniform with  name 'name' to 'value'\n   *\n   * .set( gl, obj, prop )\n   *\n   *    sets uniform from object and property with same name than uniform\n   *\n   * .setOptional( gl, obj, prop )\n   *\n   *    like .set for an optional property of the object\n   *\n   */\n\n  var emptyTexture = new Texture();\n  var emptyCubeTexture = new CubeTexture();\n\n  // --- Base for inner nodes (including the root) ---\n\n  function UniformContainer() {\n\n    this.seq = [];\n    this.map = {};\n\n  }\n\n  // --- Utilities ---\n\n  // Array Caches (provide typed arrays for temporary by size)\n\n  var arrayCacheF32 = [];\n  var arrayCacheI32 = [];\n\n  // Flattening for arrays of vectors and matrices\n\n  function flatten( array, nBlocks, blockSize ) {\n\n    var firstElem = array[ 0 ];\n\n    if ( firstElem <= 0 || firstElem > 0 ) return array;\n    // unoptimized: ! isNaN( firstElem )\n    // see http://jacksondunstan.com/articles/983\n\n    var n = nBlocks * blockSize,\n      r = arrayCacheF32[ n ];\n\n    if ( r === undefined ) {\n\n      r = new Float32Array( n );\n      arrayCacheF32[ n ] = r;\n\n    }\n\n    if ( nBlocks !== 0 ) {\n\n      firstElem.toArray( r, 0 );\n\n      for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n        offset += blockSize;\n        array[ i ].toArray( r, offset );\n\n      }\n\n    }\n\n    return r;\n\n  }\n\n  // Texture unit allocation\n\n  function allocTexUnits( renderer, n ) {\n\n    var r = arrayCacheI32[ n ];\n\n    if ( r === undefined ) {\n\n      r = new Int32Array( n );\n      arrayCacheI32[ n ] = r;\n\n    }\n\n    for ( var i = 0; i !== n; ++ i )\n      r[ i ] = renderer.allocTextureUnit();\n\n    return r;\n\n  }\n\n  // --- Setters ---\n\n  // Note: Defining these methods externally, because they come in a bunch\n  // and this way their names minify.\n\n  // Single scalar\n\n  function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }\n  function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }\n\n  // Single float vector (from flat array or THREE.VectorN)\n\n  function setValue2fv( gl, v ) {\n\n    if ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n    else gl.uniform2f( this.addr, v.x, v.y );\n\n  }\n\n  function setValue3fv( gl, v ) {\n\n    if ( v.x !== undefined )\n      gl.uniform3f( this.addr, v.x, v.y, v.z );\n    else if ( v.r !== undefined )\n      gl.uniform3f( this.addr, v.r, v.g, v.b );\n    else\n      gl.uniform3fv( this.addr, v );\n\n  }\n\n  function setValue4fv( gl, v ) {\n\n    if ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n    else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n  }\n\n  // Single matrix (from flat array or MatrixN)\n\n  function setValue2fm( gl, v ) {\n\n    gl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n  }\n\n  function setValue3fm( gl, v ) {\n\n    gl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n  }\n\n  function setValue4fm( gl, v ) {\n\n    gl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n  }\n\n  // Single texture (2D / Cube)\n\n  function setValueT1( gl, v, renderer ) {\n\n    var unit = renderer.allocTextureUnit();\n    gl.uniform1i( this.addr, unit );\n    renderer.setTexture2D( v || emptyTexture, unit );\n\n  }\n\n  function setValueT6( gl, v, renderer ) {\n\n    var unit = renderer.allocTextureUnit();\n    gl.uniform1i( this.addr, unit );\n    renderer.setTextureCube( v || emptyCubeTexture, unit );\n\n  }\n\n  // Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n  function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }\n  function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }\n  function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }\n\n  // Helper to pick the right setter for the singular case\n\n  function getSingularSetter( type ) {\n\n    switch ( type ) {\n\n      case 0x1406: return setValue1f; // FLOAT\n      case 0x8b50: return setValue2fv; // _VEC2\n      case 0x8b51: return setValue3fv; // _VEC3\n      case 0x8b52: return setValue4fv; // _VEC4\n\n      case 0x8b5a: return setValue2fm; // _MAT2\n      case 0x8b5b: return setValue3fm; // _MAT3\n      case 0x8b5c: return setValue4fm; // _MAT4\n\n      case 0x8b5e: return setValueT1; // SAMPLER_2D\n      case 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n      case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n      case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n      case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n      case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n    }\n\n  }\n\n  // Array of scalars\n\n  function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }\n  function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }\n\n  // Array of vectors (flat or from THREE classes)\n\n  function setValueV2a( gl, v ) {\n\n    gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n  }\n\n  function setValueV3a( gl, v ) {\n\n    gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n  }\n\n  function setValueV4a( gl, v ) {\n\n    gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n  }\n\n  // Array of matrices (flat or from THREE clases)\n\n  function setValueM2a( gl, v ) {\n\n    gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n  }\n\n  function setValueM3a( gl, v ) {\n\n    gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n  }\n\n  function setValueM4a( gl, v ) {\n\n    gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n  }\n\n  // Array of textures (2D / Cube)\n\n  function setValueT1a( gl, v, renderer ) {\n\n    var n = v.length,\n      units = allocTexUnits( renderer, n );\n\n    gl.uniform1iv( this.addr, units );\n\n    for ( var i = 0; i !== n; ++ i ) {\n\n      renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n    }\n\n  }\n\n  function setValueT6a( gl, v, renderer ) {\n\n    var n = v.length,\n      units = allocTexUnits( renderer, n );\n\n    gl.uniform1iv( this.addr, units );\n\n    for ( var i = 0; i !== n; ++ i ) {\n\n      renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n    }\n\n  }\n\n  // Helper to pick the right setter for a pure (bottom-level) array\n\n  function getPureArraySetter( type ) {\n\n    switch ( type ) {\n\n      case 0x1406: return setValue1fv; // FLOAT\n      case 0x8b50: return setValueV2a; // _VEC2\n      case 0x8b51: return setValueV3a; // _VEC3\n      case 0x8b52: return setValueV4a; // _VEC4\n\n      case 0x8b5a: return setValueM2a; // _MAT2\n      case 0x8b5b: return setValueM3a; // _MAT3\n      case 0x8b5c: return setValueM4a; // _MAT4\n\n      case 0x8b5e: return setValueT1a; // SAMPLER_2D\n      case 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n      case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n      case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n      case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n      case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n    }\n\n  }\n\n  // --- Uniform Classes ---\n\n  function SingleUniform( id, activeInfo, addr ) {\n\n    this.id = id;\n    this.addr = addr;\n    this.setValue = getSingularSetter( activeInfo.type );\n\n    // this.path = activeInfo.name; // DEBUG\n\n  }\n\n  function PureArrayUniform( id, activeInfo, addr ) {\n\n    this.id = id;\n    this.addr = addr;\n    this.size = activeInfo.size;\n    this.setValue = getPureArraySetter( activeInfo.type );\n\n    // this.path = activeInfo.name; // DEBUG\n\n  }\n\n  function StructuredUniform( id ) {\n\n    this.id = id;\n\n    UniformContainer.call( this ); // mix-in\n\n  }\n\n  StructuredUniform.prototype.setValue = function( gl, value ) {\n\n    // Note: Don't need an extra 'renderer' parameter, since samplers\n    // are not allowed in structured uniforms.\n\n    var seq = this.seq;\n\n    for ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n      var u = seq[ i ];\n      u.setValue( gl, value[ u.id ] );\n\n    }\n\n  };\n\n  // --- Top-level ---\n\n  // Parser - builds up the property tree from the path strings\n\n  var RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n  // extracts\n  //  - the identifier (member name or array index)\n  //  - followed by an optional right bracket (found when array index)\n  //  - followed by an optional left bracket or dot (type of subscript)\n  //\n  // Note: These portions can be read in a non-overlapping fashion and\n  // allow straightforward parsing of the hierarchy that WebGL encodes\n  // in the uniform names.\n\n  function addUniform( container, uniformObject ) {\n\n    container.seq.push( uniformObject );\n    container.map[ uniformObject.id ] = uniformObject;\n\n  }\n\n  function parseUniform( activeInfo, addr, container ) {\n\n    var path = activeInfo.name,\n      pathLength = path.length;\n\n    // reset RegExp object, because of the early exit of a previous run\n    RePathPart.lastIndex = 0;\n\n    for (; ;) {\n\n      var match = RePathPart.exec( path ),\n        matchEnd = RePathPart.lastIndex,\n\n        id = match[ 1 ],\n        idIsIndex = match[ 2 ] === ']',\n        subscript = match[ 3 ];\n\n      if ( idIsIndex ) id = id | 0; // convert to integer\n\n      if ( subscript === undefined ||\n          subscript === '[' && matchEnd + 2 === pathLength ) {\n        // bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n        addUniform( container, subscript === undefined ?\n            new SingleUniform( id, activeInfo, addr ) :\n            new PureArrayUniform( id, activeInfo, addr ) );\n\n        break;\n\n      } else {\n        // step into inner node / create it in case it doesn't exist\n\n        var map = container.map,\n          next = map[ id ];\n\n        if ( next === undefined ) {\n\n          next = new StructuredUniform( id );\n          addUniform( container, next );\n\n        }\n\n        container = next;\n\n      }\n\n    }\n\n  }\n\n  // Root Container\n\n  function WebGLUniforms( gl, program, renderer ) {\n\n    UniformContainer.call( this );\n\n    this.renderer = renderer;\n\n    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n    for ( var i = 0; i < n; ++ i ) {\n\n      var info = gl.getActiveUniform( program, i ),\n        path = info.name,\n        addr = gl.getUniformLocation( program, path );\n\n      parseUniform( info, addr, this );\n\n    }\n\n  }\n\n  WebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n    var u = this.map[ name ];\n\n    if ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n  };\n\n  WebGLUniforms.prototype.set = function( gl, object, name ) {\n\n    var u = this.map[ name ];\n\n    if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n  };\n\n  WebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n    var v = object[ name ];\n\n    if ( v !== undefined ) this.setValue( gl, name, v );\n\n  };\n\n\n  // Static interface\n\n  WebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n    for ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n      var u = seq[ i ],\n        v = values[ u.id ];\n\n      if ( v.needsUpdate !== false ) {\n        // note: always updating when .needsUpdate is undefined\n\n        u.setValue( gl, v.value, renderer );\n\n      }\n\n    }\n\n  };\n\n  WebGLUniforms.seqWithValue = function( seq, values ) {\n\n    var r = [];\n\n    for ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n      var u = seq[ i ];\n      if ( u.id in values ) r.push( u );\n\n    }\n\n    return r;\n\n  };\n\n  /**\n   * Uniform Utilities\n   */\n\n  var UniformsUtils = {\n\n    merge: function ( uniforms ) {\n\n      var merged = {};\n\n      for ( var u = 0; u < uniforms.length; u ++ ) {\n\n        var tmp = this.clone( uniforms[ u ] );\n\n        for ( var p in tmp ) {\n\n          merged[ p ] = tmp[ p ];\n\n        }\n\n      }\n\n      return merged;\n\n    },\n\n    clone: function ( uniforms_src ) {\n\n      var uniforms_dst = {};\n\n      for ( var u in uniforms_src ) {\n\n        uniforms_dst[ u ] = {};\n\n        for ( var p in uniforms_src[ u ] ) {\n\n          var parameter_src = uniforms_src[ u ][ p ];\n\n          if ( parameter_src && ( parameter_src.isColor ||\n            parameter_src.isMatrix3 || parameter_src.isMatrix4 ||\n            parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\n            parameter_src.isTexture ) ) {\n\n            uniforms_dst[ u ][ p ] = parameter_src.clone();\n\n          } else if ( Array.isArray( parameter_src ) ) {\n\n            uniforms_dst[ u ][ p ] = parameter_src.slice();\n\n          } else {\n\n            uniforms_dst[ u ][ p ] = parameter_src;\n\n          }\n\n        }\n\n      }\n\n      return uniforms_dst;\n\n    }\n\n  };\n\n  var alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n  var alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n  var alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n  var aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\n  var aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n  var begin_vertex = \"\\nvec3 transformed = vec3( position );\\n\";\n\n  var beginnormal_vertex = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n  var bsdfs = \"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 P = geometry.position;\\n\\tfloat theta = acos( dot( N, V ) );\\n\\tvec2 uv = vec2(\\n\\t\\tsqrt( saturate( roughness ) ),\\n\\t\\tsaturate( theta / ( 0.5 * PI ) ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\\n\\tint config = 0;\\n\\tif ( L[0].z > 0.0 ) config += 1;\\n\\tif ( L[1].z > 0.0 ) config += 2;\\n\\tif ( L[2].z > 0.0 ) config += 4;\\n\\tif ( L[3].z > 0.0 ) config += 8;\\n\\tn = 0;\\n\\tif ( config == 0 ) {\\n\\t} else if ( config == 1 ) {\\n\\t\\tn = 3;\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t\\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t} else if ( config == 2 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t} else if ( config == 3 ) {\\n\\t\\tn = 4;\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t\\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t} else if ( config == 4 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t\\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t} else if ( config == 5 ) {\\n\\t\\tn = 0;\\n\\t} else if ( config == 6 ) {\\n\\t\\tn = 4;\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t\\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t} else if ( config == 7 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t\\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t} else if ( config == 8 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t\\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t\\tL[2] =  L[3];\\n\\t} else if ( config == 9 ) {\\n\\t\\tn = 4;\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t\\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t} else if ( config == 10 ) {\\n\\t\\tn = 0;\\n\\t} else if ( config == 11 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = L[3];\\n\\t\\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t} else if ( config == 12 ) {\\n\\t\\tn = 4;\\n\\t\\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t\\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t} else if ( config == 13 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = L[3];\\n\\t\\tL[3] = L[2];\\n\\t\\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t} else if ( config == 14 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t} else if ( config == 15 ) {\\n\\t\\tn = 4;\\n\\t}\\n\\tif ( n == 3 )\\n\\t\\tL[3] = L[0];\\n\\tif ( n == 4 )\\n\\t\\tL[4] = L[0];\\n}\\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\\n\\tfloat cosTheta = dot( v1, v2 );\\n\\tfloat theta = acos( cosTheta );\\n\\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\\n\\treturn res;\\n}\\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\\n\\trectPoints[0] = pos - halfWidth - halfHeight;\\n\\trectPoints[1] = pos + halfWidth - halfHeight;\\n\\trectPoints[2] = pos + halfWidth + halfHeight;\\n\\trectPoints[3] = pos - halfWidth + halfHeight;\\n}\\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 P = geometry.position;\\n\\tvec3 T1, T2;\\n\\tT1 = normalize(V - N * dot( V, N ));\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\\n\\tvec3 clippedRect[5];\\n\\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\\n\\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\\n\\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\\n\\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\\n\\tint n;\\n\\tclipQuadToHorizon(clippedRect, n);\\n\\tif ( n == 0 )\\n\\t\\treturn vec3( 0, 0, 0 );\\n\\tclippedRect[0] = normalize( clippedRect[0] );\\n\\tclippedRect[1] = normalize( clippedRect[1] );\\n\\tclippedRect[2] = normalize( clippedRect[2] );\\n\\tclippedRect[3] = normalize( clippedRect[3] );\\n\\tclippedRect[4] = normalize( clippedRect[4] );\\n\\tfloat sum = 0.0;\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\\n\\tif (n >= 4)\\n\\t\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\\n\\tif (n == 5)\\n\\t\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\\n\\tsum = max( 0.0, sum );\\n\\tvec3 Lo_i = vec3( sum, sum, sum );\\n\\treturn Lo_i;\\n}\\nvec3 Rect_Area_Light_Specular_Reflectance(\\n\\t\\tconst in GeometricContext geometry,\\n\\t\\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\\n\\t\\tconst in float roughness,\\n\\t\\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\\n\\tvec3 rectPoints[4];\\n\\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\\n\\tvec2 uv = ltcTextureCoords( geometry, roughness );\\n\\tvec4 brdfLtcApproxParams, t;\\n\\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\\n\\tt = texture2D( ltcMat, uv );\\n\\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\\n\\tmat3 brdfLtcApproxMat = mat3(\\n\\t\\tvec3(   1,   0, t.y ),\\n\\t\\tvec3(   0, t.z,   0 ),\\n\\t\\tvec3( t.w,   0, t.x )\\n\\t);\\n\\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\\n\\tspecularReflectance *= brdfLtcScalar;\\n\\treturn specularReflectance;\\n}\\nvec3 Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\tconst in GeometricContext geometry,\\n\\t\\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\\n\\tvec3 rectPoints[4];\\n\\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\\n\\tmat3 diffuseBrdfMat = mat3(1);\\n\\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\\n\\treturn diffuseReflectance;\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n  var bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\n  var clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\n  var clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n  var clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n  var clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n  var color_fragment = \"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n  var color_pars_fragment = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\n  var color_pars_vertex = \"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\n  var color_vertex = \"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\n  var common = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transpose( const in mat3 v ) {\\n\\tmat3 tmp;\\n\\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\\n\\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\\n\\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\\n\\treturn tmp;\\n}\\n\";\n\n  var cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n  var defaultnormal_vertex = \"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n  var displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\n  var displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n  var emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n  var emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n  var encodings_fragment = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n  var encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n  var envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\n  var envmap_pars_fragment = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\n  var envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\n  var envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\n  var fog_vertex = \"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\";\n\n  var fog_pars_vertex = \"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\";\n\n  var fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n  var fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\";\n\n  var gradientmap_pars_fragment = \"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n  var lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n  var lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n  var lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n  var lights_pars = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltcMat;\\tuniform sampler2D ltcMag;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\n  var lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n  var lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 matDiffColor = material.diffuseColor;\\n\\t\\tvec3 matSpecColor = material.specularColor;\\n\\t\\tvec3 lightColor   = rectAreaLight.color;\\n\\t\\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\\n\\t\\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\\n\\t\\t\\t\\troughness,\\n\\t\\t\\t\\tltcMat, ltcMag );\\n\\t\\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\\n\\t\\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\\n\\t\\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\\n\\t}\\n#endif\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\n  var lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n  var lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 matDiffColor = material.diffuseColor;\\n\\t\\tvec3 matSpecColor = material.specularColor;\\n\\t\\tvec3 lightColor   = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\\n\\t\\t\\t\\troughness,\\n\\t\\t\\t\\tltcMat, ltcMag );\\n\\t\\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\\n\\t\\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\\n\\t\\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n  var lights_template = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n  var logdepthbuf_fragment = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n  var logdepthbuf_pars_fragment = \"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\n  var logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\n  var logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\n  var map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n  var map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n  var map_particle_fragment = \"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n  var map_particle_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\n  var metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\\n\";\n\n  var metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n  var morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n  var morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n  var morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\n  var normal_flip = \"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n  var normal_fragment = \"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n  var normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\n  var packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n  var premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n  var project_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n  var roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n\";\n\n  var roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n  var shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\n  var shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\n  var shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\n  var shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\n  var skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n  var skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\n  var skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n  var skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n  var specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n  var specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n  var tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n  var tonemapping_pars_fragment = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n  var uv_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n  var uv_pars_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n  var uv_vertex = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n  var uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n  var uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n  var uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\n  var worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\n  var cube_frag = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n  var cube_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n  var depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\n  var depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\n  var distanceRGBA_frag = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n  var distanceRGBA_vert = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\n  var equirect_frag = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n  var equirect_vert = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\n  var linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var meshphysical_frag = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var meshphysical_vert = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\";\n\n  var normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\";\n\n  var points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\n  var points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\n  var shadow_frag = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\\n}\\n\";\n\n  var shadow_vert = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\n  var ShaderChunk = {\n    alphamap_fragment: alphamap_fragment,\n    alphamap_pars_fragment: alphamap_pars_fragment,\n    alphatest_fragment: alphatest_fragment,\n    aomap_fragment: aomap_fragment,\n    aomap_pars_fragment: aomap_pars_fragment,\n    begin_vertex: begin_vertex,\n    beginnormal_vertex: beginnormal_vertex,\n    bsdfs: bsdfs,\n    bumpmap_pars_fragment: bumpmap_pars_fragment,\n    clipping_planes_fragment: clipping_planes_fragment,\n    clipping_planes_pars_fragment: clipping_planes_pars_fragment,\n    clipping_planes_pars_vertex: clipping_planes_pars_vertex,\n    clipping_planes_vertex: clipping_planes_vertex,\n    color_fragment: color_fragment,\n    color_pars_fragment: color_pars_fragment,\n    color_pars_vertex: color_pars_vertex,\n    color_vertex: color_vertex,\n    common: common,\n    cube_uv_reflection_fragment: cube_uv_reflection_fragment,\n    defaultnormal_vertex: defaultnormal_vertex,\n    displacementmap_pars_vertex: displacementmap_pars_vertex,\n    displacementmap_vertex: displacementmap_vertex,\n    emissivemap_fragment: emissivemap_fragment,\n    emissivemap_pars_fragment: emissivemap_pars_fragment,\n    encodings_fragment: encodings_fragment,\n    encodings_pars_fragment: encodings_pars_fragment,\n    envmap_fragment: envmap_fragment,\n    envmap_pars_fragment: envmap_pars_fragment,\n    envmap_pars_vertex: envmap_pars_vertex,\n    envmap_vertex: envmap_vertex,\n    fog_vertex: fog_vertex,\n    fog_pars_vertex: fog_pars_vertex,\n    fog_fragment: fog_fragment,\n    fog_pars_fragment: fog_pars_fragment,\n    gradientmap_pars_fragment: gradientmap_pars_fragment,\n    lightmap_fragment: lightmap_fragment,\n    lightmap_pars_fragment: lightmap_pars_fragment,\n    lights_lambert_vertex: lights_lambert_vertex,\n    lights_pars: lights_pars,\n    lights_phong_fragment: lights_phong_fragment,\n    lights_phong_pars_fragment: lights_phong_pars_fragment,\n    lights_physical_fragment: lights_physical_fragment,\n    lights_physical_pars_fragment: lights_physical_pars_fragment,\n    lights_template: lights_template,\n    logdepthbuf_fragment: logdepthbuf_fragment,\n    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n    logdepthbuf_vertex: logdepthbuf_vertex,\n    map_fragment: map_fragment,\n    map_pars_fragment: map_pars_fragment,\n    map_particle_fragment: map_particle_fragment,\n    map_particle_pars_fragment: map_particle_pars_fragment,\n    metalnessmap_fragment: metalnessmap_fragment,\n    metalnessmap_pars_fragment: metalnessmap_pars_fragment,\n    morphnormal_vertex: morphnormal_vertex,\n    morphtarget_pars_vertex: morphtarget_pars_vertex,\n    morphtarget_vertex: morphtarget_vertex,\n    normal_flip: normal_flip,\n    normal_fragment: normal_fragment,\n    normalmap_pars_fragment: normalmap_pars_fragment,\n    packing: packing,\n    premultiplied_alpha_fragment: premultiplied_alpha_fragment,\n    project_vertex: project_vertex,\n    roughnessmap_fragment: roughnessmap_fragment,\n    roughnessmap_pars_fragment: roughnessmap_pars_fragment,\n    shadowmap_pars_fragment: shadowmap_pars_fragment,\n    shadowmap_pars_vertex: shadowmap_pars_vertex,\n    shadowmap_vertex: shadowmap_vertex,\n    shadowmask_pars_fragment: shadowmask_pars_fragment,\n    skinbase_vertex: skinbase_vertex,\n    skinning_pars_vertex: skinning_pars_vertex,\n    skinning_vertex: skinning_vertex,\n    skinnormal_vertex: skinnormal_vertex,\n    specularmap_fragment: specularmap_fragment,\n    specularmap_pars_fragment: specularmap_pars_fragment,\n    tonemapping_fragment: tonemapping_fragment,\n    tonemapping_pars_fragment: tonemapping_pars_fragment,\n    uv_pars_fragment: uv_pars_fragment,\n    uv_pars_vertex: uv_pars_vertex,\n    uv_vertex: uv_vertex,\n    uv2_pars_fragment: uv2_pars_fragment,\n    uv2_pars_vertex: uv2_pars_vertex,\n    uv2_vertex: uv2_vertex,\n    worldpos_vertex: worldpos_vertex,\n\n    cube_frag: cube_frag,\n    cube_vert: cube_vert,\n    depth_frag: depth_frag,\n    depth_vert: depth_vert,\n    distanceRGBA_frag: distanceRGBA_frag,\n    distanceRGBA_vert: distanceRGBA_vert,\n    equirect_frag: equirect_frag,\n    equirect_vert: equirect_vert,\n    linedashed_frag: linedashed_frag,\n    linedashed_vert: linedashed_vert,\n    meshbasic_frag: meshbasic_frag,\n    meshbasic_vert: meshbasic_vert,\n    meshlambert_frag: meshlambert_frag,\n    meshlambert_vert: meshlambert_vert,\n    meshphong_frag: meshphong_frag,\n    meshphong_vert: meshphong_vert,\n    meshphysical_frag: meshphysical_frag,\n    meshphysical_vert: meshphysical_vert,\n    normal_frag: normal_frag,\n    normal_vert: normal_vert,\n    points_frag: points_frag,\n    points_vert: points_vert,\n    shadow_frag: shadow_frag,\n    shadow_vert: shadow_vert\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n  function Color( r, g, b ) {\n\n    if ( g === undefined && b === undefined ) {\n\n      // r is THREE.Color, hex or string\n      return this.set( r );\n\n    }\n\n    return this.setRGB( r, g, b );\n\n  }\n\n  Object.assign( Color.prototype, {\n\n    isColor: true,\n\n    r: 1, g: 1, b: 1,\n\n    set: function ( value ) {\n\n      if ( value && value.isColor ) {\n\n        this.copy( value );\n\n      } else if ( typeof value === 'number' ) {\n\n        this.setHex( value );\n\n      } else if ( typeof value === 'string' ) {\n\n        this.setStyle( value );\n\n      }\n\n      return this;\n\n    },\n\n    setScalar: function ( scalar ) {\n\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n\n      return this;\n\n    },\n\n    setHex: function ( hex ) {\n\n      hex = Math.floor( hex );\n\n      this.r = ( hex >> 16 & 255 ) / 255;\n      this.g = ( hex >> 8 & 255 ) / 255;\n      this.b = ( hex & 255 ) / 255;\n\n      return this;\n\n    },\n\n    setRGB: function ( r, g, b ) {\n\n      this.r = r;\n      this.g = g;\n      this.b = b;\n\n      return this;\n\n    },\n\n    setHSL: function () {\n\n      function hue2rgb( p, q, t ) {\n\n        if ( t < 0 ) t += 1;\n        if ( t > 1 ) t -= 1;\n        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n        if ( t < 1 / 2 ) return q;\n        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n        return p;\n\n      }\n\n      return function setHSL( h, s, l ) {\n\n        // h,s,l ranges are in 0.0 - 1.0\n        h = _Math.euclideanModulo( h, 1 );\n        s = _Math.clamp( s, 0, 1 );\n        l = _Math.clamp( l, 0, 1 );\n\n        if ( s === 0 ) {\n\n          this.r = this.g = this.b = l;\n\n        } else {\n\n          var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n          var q = ( 2 * l ) - p;\n\n          this.r = hue2rgb( q, p, h + 1 / 3 );\n          this.g = hue2rgb( q, p, h );\n          this.b = hue2rgb( q, p, h - 1 / 3 );\n\n        }\n\n        return this;\n\n      };\n\n    }(),\n\n    setStyle: function ( style ) {\n\n      function handleAlpha( string ) {\n\n        if ( string === undefined ) return;\n\n        if ( parseFloat( string ) < 1 ) {\n\n          console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n        }\n\n      }\n\n\n      var m;\n\n      if ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n        // rgb / hsl\n\n        var color;\n        var name = m[ 1 ];\n        var components = m[ 2 ];\n\n        switch ( name ) {\n\n          case 'rgb':\n          case 'rgba':\n\n            if ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n              // rgb(255,0,0) rgba(255,0,0,0.5)\n              this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n              this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n              this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n              handleAlpha( color[ 5 ] );\n\n              return this;\n\n            }\n\n            if ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n              this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n              this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n              this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n              handleAlpha( color[ 5 ] );\n\n              return this;\n\n            }\n\n            break;\n\n          case 'hsl':\n          case 'hsla':\n\n            if ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n              var h = parseFloat( color[ 1 ] ) / 360;\n              var s = parseInt( color[ 2 ], 10 ) / 100;\n              var l = parseInt( color[ 3 ], 10 ) / 100;\n\n              handleAlpha( color[ 5 ] );\n\n              return this.setHSL( h, s, l );\n\n            }\n\n            break;\n\n        }\n\n      } else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n        // hex color\n\n        var hex = m[ 1 ];\n        var size = hex.length;\n\n        if ( size === 3 ) {\n\n          // #ff0\n          this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n          this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n          this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n          return this;\n\n        } else if ( size === 6 ) {\n\n          // #ff0000\n          this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n          this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n          this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n          return this;\n\n        }\n\n      }\n\n      if ( style && style.length > 0 ) {\n\n        // color keywords\n        var hex = ColorKeywords[ style ];\n\n        if ( hex !== undefined ) {\n\n          // red\n          this.setHex( hex );\n\n        } else {\n\n          // unknown color\n          console.warn( 'THREE.Color: Unknown color ' + style );\n\n        }\n\n      }\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this.r, this.g, this.b );\n\n    },\n\n    copy: function ( color ) {\n\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n\n      return this;\n\n    },\n\n    copyGammaToLinear: function ( color, gammaFactor ) {\n\n      if ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n      this.r = Math.pow( color.r, gammaFactor );\n      this.g = Math.pow( color.g, gammaFactor );\n      this.b = Math.pow( color.b, gammaFactor );\n\n      return this;\n\n    },\n\n    copyLinearToGamma: function ( color, gammaFactor ) {\n\n      if ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n      var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n      this.r = Math.pow( color.r, safeInverse );\n      this.g = Math.pow( color.g, safeInverse );\n      this.b = Math.pow( color.b, safeInverse );\n\n      return this;\n\n    },\n\n    convertGammaToLinear: function () {\n\n      var r = this.r, g = this.g, b = this.b;\n\n      this.r = r * r;\n      this.g = g * g;\n      this.b = b * b;\n\n      return this;\n\n    },\n\n    convertLinearToGamma: function () {\n\n      this.r = Math.sqrt( this.r );\n      this.g = Math.sqrt( this.g );\n      this.b = Math.sqrt( this.b );\n\n      return this;\n\n    },\n\n    getHex: function () {\n\n      return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n    },\n\n    getHexString: function () {\n\n      return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n    },\n\n    getHSL: function ( optionalTarget ) {\n\n      // h,s,l ranges are in 0.0 - 1.0\n\n      var hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n      var r = this.r, g = this.g, b = this.b;\n\n      var max = Math.max( r, g, b );\n      var min = Math.min( r, g, b );\n\n      var hue, saturation;\n      var lightness = ( min + max ) / 2.0;\n\n      if ( min === max ) {\n\n        hue = 0;\n        saturation = 0;\n\n      } else {\n\n        var delta = max - min;\n\n        saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n        switch ( max ) {\n\n          case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n          case g: hue = ( b - r ) / delta + 2; break;\n          case b: hue = ( r - g ) / delta + 4; break;\n\n        }\n\n        hue /= 6;\n\n      }\n\n      hsl.h = hue;\n      hsl.s = saturation;\n      hsl.l = lightness;\n\n      return hsl;\n\n    },\n\n    getStyle: function () {\n\n      return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n    },\n\n    offsetHSL: function ( h, s, l ) {\n\n      var hsl = this.getHSL();\n\n      hsl.h += h; hsl.s += s; hsl.l += l;\n\n      this.setHSL( hsl.h, hsl.s, hsl.l );\n\n      return this;\n\n    },\n\n    add: function ( color ) {\n\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n\n      return this;\n\n    },\n\n    addColors: function ( color1, color2 ) {\n\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n\n      return this;\n\n    },\n\n    addScalar: function ( s ) {\n\n      this.r += s;\n      this.g += s;\n      this.b += s;\n\n      return this;\n\n    },\n\n    sub: function( color ) {\n\n      this.r = Math.max( 0, this.r - color.r );\n      this.g = Math.max( 0, this.g - color.g );\n      this.b = Math.max( 0, this.b - color.b );\n\n      return this;\n\n    },\n\n    multiply: function ( color ) {\n\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n\n      return this;\n\n    },\n\n    multiplyScalar: function ( s ) {\n\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n\n      return this;\n\n    },\n\n    lerp: function ( color, alpha ) {\n\n      this.r += ( color.r - this.r ) * alpha;\n      this.g += ( color.g - this.g ) * alpha;\n      this.b += ( color.b - this.b ) * alpha;\n\n      return this;\n\n    },\n\n    equals: function ( c ) {\n\n      return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.r = array[ offset ];\n      this.g = array[ offset + 1 ];\n      this.b = array[ offset + 2 ];\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this.r;\n      array[ offset + 1 ] = this.g;\n      array[ offset + 2 ] = this.b;\n\n      return array;\n\n    },\n\n    toJSON: function () {\n\n      return this.getHex();\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n    this.image = { data: data, width: width, height: height };\n\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n    this.generateMipmaps  = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n\n  }\n\n  DataTexture.prototype = Object.create( Texture.prototype );\n  DataTexture.prototype.constructor = DataTexture;\n\n  DataTexture.prototype.isDataTexture = true;\n\n  /**\n   * Uniforms library for shared webgl shaders\n   */\n\n  var UniformsLib = {\n\n    common: {\n\n      diffuse: { value: new Color( 0xeeeeee ) },\n      opacity: { value: 1.0 },\n\n      map: { value: null },\n      offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },\n\n      specularMap: { value: null },\n      alphaMap: { value: null },\n\n      envMap: { value: null },\n      flipEnvMap: { value: - 1 },\n      reflectivity: { value: 1.0 },\n      refractionRatio: { value: 0.98 }\n\n    },\n\n    aomap: {\n\n      aoMap: { value: null },\n      aoMapIntensity: { value: 1 }\n\n    },\n\n    lightmap: {\n\n      lightMap: { value: null },\n      lightMapIntensity: { value: 1 }\n\n    },\n\n    emissivemap: {\n\n      emissiveMap: { value: null }\n\n    },\n\n    bumpmap: {\n\n      bumpMap: { value: null },\n      bumpScale: { value: 1 }\n\n    },\n\n    normalmap: {\n\n      normalMap: { value: null },\n      normalScale: { value: new Vector2( 1, 1 ) }\n\n    },\n\n    displacementmap: {\n\n      displacementMap: { value: null },\n      displacementScale: { value: 1 },\n      displacementBias: { value: 0 }\n\n    },\n\n    roughnessmap: {\n\n      roughnessMap: { value: null }\n\n    },\n\n    metalnessmap: {\n\n      metalnessMap: { value: null }\n\n    },\n\n    gradientmap: {\n\n      gradientMap: { value: null }\n\n    },\n\n    fog: {\n\n      fogDensity: { value: 0.00025 },\n      fogNear: { value: 1 },\n      fogFar: { value: 2000 },\n      fogColor: { value: new Color( 0xffffff ) }\n\n    },\n\n    lights: {\n\n      ambientLightColor: { value: [] },\n\n      directionalLights: { value: [], properties: {\n        direction: {},\n        color: {},\n\n        shadow: {},\n        shadowBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      } },\n\n      directionalShadowMap: { value: [] },\n      directionalShadowMatrix: { value: [] },\n\n      spotLights: { value: [], properties: {\n        color: {},\n        position: {},\n        direction: {},\n        distance: {},\n        coneCos: {},\n        penumbraCos: {},\n        decay: {},\n\n        shadow: {},\n        shadowBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      } },\n\n      spotShadowMap: { value: [] },\n      spotShadowMatrix: { value: [] },\n\n      pointLights: { value: [], properties: {\n        color: {},\n        position: {},\n        decay: {},\n        distance: {},\n\n        shadow: {},\n        shadowBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      } },\n\n      pointShadowMap: { value: [] },\n      pointShadowMatrix: { value: [] },\n\n      hemisphereLights: { value: [], properties: {\n        direction: {},\n        skyColor: {},\n        groundColor: {}\n      } },\n\n      // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n      rectAreaLights: { value: [], properties: {\n        color: {},\n        position: {},\n        width: {},\n        height: {}\n      } }\n\n    },\n\n    points: {\n\n      diffuse: { value: new Color( 0xeeeeee ) },\n      opacity: { value: 1.0 },\n      size: { value: 1.0 },\n      scale: { value: 1.0 },\n      map: { value: null },\n      offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }\n\n    }\n\n  };\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   * @author mikael emtinger / http://gomo.se/\n   */\n\n  var ShaderLib = {\n\n    basic: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.aomap,\n        UniformsLib.lightmap,\n        UniformsLib.fog\n      ] ),\n\n      vertexShader: ShaderChunk.meshbasic_vert,\n      fragmentShader: ShaderChunk.meshbasic_frag\n\n    },\n\n    lambert: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.aomap,\n        UniformsLib.lightmap,\n        UniformsLib.emissivemap,\n        UniformsLib.fog,\n        UniformsLib.lights,\n        {\n          emissive: { value: new Color( 0x000000 ) }\n        }\n      ] ),\n\n      vertexShader: ShaderChunk.meshlambert_vert,\n      fragmentShader: ShaderChunk.meshlambert_frag\n\n    },\n\n    phong: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.aomap,\n        UniformsLib.lightmap,\n        UniformsLib.emissivemap,\n        UniformsLib.bumpmap,\n        UniformsLib.normalmap,\n        UniformsLib.displacementmap,\n        UniformsLib.gradientmap,\n        UniformsLib.fog,\n        UniformsLib.lights,\n        {\n          emissive: { value: new Color( 0x000000 ) },\n          specular: { value: new Color( 0x111111 ) },\n          shininess: { value: 30 }\n        }\n      ] ),\n\n      vertexShader: ShaderChunk.meshphong_vert,\n      fragmentShader: ShaderChunk.meshphong_frag\n\n    },\n\n    standard: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.aomap,\n        UniformsLib.lightmap,\n        UniformsLib.emissivemap,\n        UniformsLib.bumpmap,\n        UniformsLib.normalmap,\n        UniformsLib.displacementmap,\n        UniformsLib.roughnessmap,\n        UniformsLib.metalnessmap,\n        UniformsLib.fog,\n        UniformsLib.lights,\n        {\n          emissive: { value: new Color( 0x000000 ) },\n          roughness: { value: 0.5 },\n          metalness: { value: 0 },\n          envMapIntensity: { value: 1 } // temporary\n        }\n      ] ),\n\n      vertexShader: ShaderChunk.meshphysical_vert,\n      fragmentShader: ShaderChunk.meshphysical_frag\n\n    },\n\n    points: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.points,\n        UniformsLib.fog\n      ] ),\n\n      vertexShader: ShaderChunk.points_vert,\n      fragmentShader: ShaderChunk.points_frag\n\n    },\n\n    dashed: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.fog,\n        {\n          scale: { value: 1 },\n          dashSize: { value: 1 },\n          totalSize: { value: 2 }\n        }\n      ] ),\n\n      vertexShader: ShaderChunk.linedashed_vert,\n      fragmentShader: ShaderChunk.linedashed_frag\n\n    },\n\n    depth: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.displacementmap\n      ] ),\n\n      vertexShader: ShaderChunk.depth_vert,\n      fragmentShader: ShaderChunk.depth_frag\n\n    },\n\n    normal: {\n\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.common,\n        UniformsLib.bumpmap,\n        UniformsLib.normalmap,\n        UniformsLib.displacementmap,\n        {\n          opacity: { value: 1.0 }\n        }\n      ] ),\n\n      vertexShader: ShaderChunk.normal_vert,\n      fragmentShader: ShaderChunk.normal_frag\n\n    },\n\n    /* -------------------------------------------------------------------------\n    //  Cube map shader\n     ------------------------------------------------------------------------- */\n\n    cube: {\n\n      uniforms: {\n        tCube: { value: null },\n        tFlip: { value: - 1 },\n        opacity: { value: 1.0 }\n      },\n\n      vertexShader: ShaderChunk.cube_vert,\n      fragmentShader: ShaderChunk.cube_frag\n\n    },\n\n    /* -------------------------------------------------------------------------\n    //  Cube map shader\n     ------------------------------------------------------------------------- */\n\n    equirect: {\n\n      uniforms: {\n        tEquirect: { value: null },\n        tFlip: { value: - 1 }\n      },\n\n      vertexShader: ShaderChunk.equirect_vert,\n      fragmentShader: ShaderChunk.equirect_frag\n\n    },\n\n    distanceRGBA: {\n\n      uniforms: {\n        lightPos: { value: new Vector3() }\n      },\n\n      vertexShader: ShaderChunk.distanceRGBA_vert,\n      fragmentShader: ShaderChunk.distanceRGBA_frag\n\n    }\n\n  };\n\n  ShaderLib.physical = {\n\n    uniforms: UniformsUtils.merge( [\n      ShaderLib.standard.uniforms,\n      {\n        clearCoat: { value: 0 },\n        clearCoatRoughness: { value: 0 }\n      }\n    ] ),\n\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag\n\n  };\n\n  /**\n   * @author bhouston / http://clara.io\n   */\n\n  function Box2( min, max ) {\n\n    this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\n    this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\n\n  }\n\n  Object.assign( Box2.prototype, {\n\n    set: function ( min, max ) {\n\n      this.min.copy( min );\n      this.max.copy( max );\n\n      return this;\n\n    },\n\n    setFromPoints: function ( points ) {\n\n      this.makeEmpty();\n\n      for ( var i = 0, il = points.length; i < il; i ++ ) {\n\n        this.expandByPoint( points[ i ] );\n\n      }\n\n      return this;\n\n    },\n\n    setFromCenterAndSize: function () {\n\n      var v1 = new Vector2();\n\n      return function setFromCenterAndSize( center, size ) {\n\n        var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n        this.min.copy( center ).sub( halfSize );\n        this.max.copy( center ).add( halfSize );\n\n        return this;\n\n      };\n\n    }(),\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( box ) {\n\n      this.min.copy( box.min );\n      this.max.copy( box.max );\n\n      return this;\n\n    },\n\n    makeEmpty: function () {\n\n      this.min.x = this.min.y = + Infinity;\n      this.max.x = this.max.y = - Infinity;\n\n      return this;\n\n    },\n\n    isEmpty: function () {\n\n      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n      return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n    },\n\n    getCenter: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector2();\n      return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n    },\n\n    getSize: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector2();\n      return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\n\n    },\n\n    expandByPoint: function ( point ) {\n\n      this.min.min( point );\n      this.max.max( point );\n\n      return this;\n\n    },\n\n    expandByVector: function ( vector ) {\n\n      this.min.sub( vector );\n      this.max.add( vector );\n\n      return this;\n\n    },\n\n    expandByScalar: function ( scalar ) {\n\n      this.min.addScalar( - scalar );\n      this.max.addScalar( scalar );\n\n      return this;\n\n    },\n\n    containsPoint: function ( point ) {\n\n      return point.x < this.min.x || point.x > this.max.x ||\n        point.y < this.min.y || point.y > this.max.y ? false : true;\n\n    },\n\n    containsBox: function ( box ) {\n\n      return this.min.x <= box.min.x && box.max.x <= this.max.x &&\n        this.min.y <= box.min.y && box.max.y <= this.max.y;\n\n    },\n\n    getParameter: function ( point, optionalTarget ) {\n\n      // This can potentially have a divide by zero if the box\n      // has a size dimension of 0.\n\n      var result = optionalTarget || new Vector2();\n\n      return result.set(\n        ( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n        ( point.y - this.min.y ) / ( this.max.y - this.min.y )\n      );\n\n    },\n\n    intersectsBox: function ( box ) {\n\n      // using 6 splitting planes to rule out intersections.\n      return box.max.x < this.min.x || box.min.x > this.max.x ||\n        box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n    },\n\n    clampPoint: function ( point, optionalTarget ) {\n\n      var result = optionalTarget || new Vector2();\n      return result.copy( point ).clamp( this.min, this.max );\n\n    },\n\n    distanceToPoint: function () {\n\n      var v1 = new Vector2();\n\n      return function distanceToPoint( point ) {\n\n        var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n        return clampedPoint.sub( point ).length();\n\n      };\n\n    }(),\n\n    intersect: function ( box ) {\n\n      this.min.max( box.min );\n      this.max.min( box.max );\n\n      return this;\n\n    },\n\n    union: function ( box ) {\n\n      this.min.min( box.min );\n      this.max.max( box.max );\n\n      return this;\n\n    },\n\n    translate: function ( offset ) {\n\n      this.min.add( offset );\n      this.max.add( offset );\n\n      return this;\n\n    },\n\n    equals: function ( box ) {\n\n      return box.min.equals( this.min ) && box.max.equals( this.max );\n\n    }\n\n  } );\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function LensFlarePlugin( renderer, flares ) {\n\n    var gl = renderer.context;\n    var state = renderer.state;\n\n    var vertexBuffer, elementBuffer;\n    var shader, program, attributes, uniforms;\n\n    var tempTexture, occlusionTexture;\n\n    function init() {\n\n      var vertices = new Float32Array( [\n        - 1, - 1,  0, 0,\n         1, - 1,  1, 0,\n         1,  1,  1, 1,\n        - 1,  1,  0, 1\n      ] );\n\n      var faces = new Uint16Array( [\n        0, 1, 2,\n        0, 2, 3\n      ] );\n\n      // buffers\n\n      vertexBuffer     = gl.createBuffer();\n      elementBuffer    = gl.createBuffer();\n\n      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n      // textures\n\n      tempTexture      = gl.createTexture();\n      occlusionTexture = gl.createTexture();\n\n      state.bindTexture( gl.TEXTURE_2D, tempTexture );\n      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n      state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n      shader = {\n\n        vertexShader: [\n\n          \"uniform lowp int renderType;\",\n\n          \"uniform vec3 screenPosition;\",\n          \"uniform vec2 scale;\",\n          \"uniform float rotation;\",\n\n          \"uniform sampler2D occlusionMap;\",\n\n          \"attribute vec2 position;\",\n          \"attribute vec2 uv;\",\n\n          \"varying vec2 vUV;\",\n          \"varying float vVisibility;\",\n\n          \"void main() {\",\n\n            \"vUV = uv;\",\n\n            \"vec2 pos = position;\",\n\n            \"if ( renderType == 2 ) {\",\n\n              \"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n              \"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n              \"vVisibility =        visibility.r / 9.0;\",\n              \"vVisibility *= 1.0 - visibility.g / 9.0;\",\n              \"vVisibility *=       visibility.b / 9.0;\",\n              \"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n              \"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n              \"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n            \"}\",\n\n            \"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n          \"}\"\n\n        ].join( \"\\n\" ),\n\n        fragmentShader: [\n\n          \"uniform lowp int renderType;\",\n\n          \"uniform sampler2D map;\",\n          \"uniform float opacity;\",\n          \"uniform vec3 color;\",\n\n          \"varying vec2 vUV;\",\n          \"varying float vVisibility;\",\n\n          \"void main() {\",\n\n            // pink square\n\n            \"if ( renderType == 0 ) {\",\n\n              \"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n            // restore\n\n            \"} else if ( renderType == 1 ) {\",\n\n              \"gl_FragColor = texture2D( map, vUV );\",\n\n            // flare\n\n            \"} else {\",\n\n              \"vec4 texture = texture2D( map, vUV );\",\n              \"texture.a *= opacity * vVisibility;\",\n              \"gl_FragColor = texture;\",\n              \"gl_FragColor.rgb *= color;\",\n\n            \"}\",\n\n          \"}\"\n\n        ].join( \"\\n\" )\n\n      };\n\n      program = createProgram( shader );\n\n      attributes = {\n        vertex: gl.getAttribLocation ( program, \"position\" ),\n        uv:     gl.getAttribLocation ( program, \"uv\" )\n      };\n\n      uniforms = {\n        renderType:     gl.getUniformLocation( program, \"renderType\" ),\n        map:            gl.getUniformLocation( program, \"map\" ),\n        occlusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n        opacity:        gl.getUniformLocation( program, \"opacity\" ),\n        color:          gl.getUniformLocation( program, \"color\" ),\n        scale:          gl.getUniformLocation( program, \"scale\" ),\n        rotation:       gl.getUniformLocation( program, \"rotation\" ),\n        screenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n      };\n\n    }\n\n    /*\n     * Render lens flares\n     * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n     *         reads these back and calculates occlusion.\n     */\n\n    this.render = function ( scene, camera, viewport ) {\n\n      if ( flares.length === 0 ) return;\n\n      var tempPosition = new Vector3();\n\n      var invAspect = viewport.w / viewport.z,\n        halfViewportWidth = viewport.z * 0.5,\n        halfViewportHeight = viewport.w * 0.5;\n\n      var size = 16 / viewport.w,\n        scale = new Vector2( size * invAspect, size );\n\n      var screenPosition = new Vector3( 1, 1, 0 ),\n        screenPositionPixels = new Vector2( 1, 1 );\n\n      var validArea = new Box2();\n\n      validArea.min.set( viewport.x, viewport.y );\n      validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n      if ( program === undefined ) {\n\n        init();\n\n      }\n\n      gl.useProgram( program );\n\n      state.initAttributes();\n      state.enableAttribute( attributes.vertex );\n      state.enableAttribute( attributes.uv );\n      state.disableUnusedAttributes();\n\n      // loop through all lens flares to update their occlusion and positions\n      // setup gl and common used attribs/uniforms\n\n      gl.uniform1i( uniforms.occlusionMap, 0 );\n      gl.uniform1i( uniforms.map, 1 );\n\n      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n      gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n      gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n      state.disable( gl.CULL_FACE );\n      state.setDepthWrite( false );\n\n      for ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n        size = 16 / viewport.w;\n        scale.set( size * invAspect, size );\n\n        // calc object screen position\n\n        var flare = flares[ i ];\n\n        tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n        tempPosition.applyMatrix4( camera.matrixWorldInverse );\n        tempPosition.applyMatrix4( camera.projectionMatrix );\n\n        // setup arrays for gl programs\n\n        screenPosition.copy( tempPosition );\n\n        // horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n        screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n        screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n        // screen cull\n\n        if ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n          // save current RGB to temp texture\n\n          state.activeTexture( gl.TEXTURE0 );\n          state.bindTexture( gl.TEXTURE_2D, null );\n          state.activeTexture( gl.TEXTURE1 );\n          state.bindTexture( gl.TEXTURE_2D, tempTexture );\n          gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n          // render pink quad\n\n          gl.uniform1i( uniforms.renderType, 0 );\n          gl.uniform2f( uniforms.scale, scale.x, scale.y );\n          gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n          state.disable( gl.BLEND );\n          state.enable( gl.DEPTH_TEST );\n\n          gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n          // copy result to occlusionMap\n\n          state.activeTexture( gl.TEXTURE0 );\n          state.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n          gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n          // restore graphics\n\n          gl.uniform1i( uniforms.renderType, 1 );\n          state.disable( gl.DEPTH_TEST );\n\n          state.activeTexture( gl.TEXTURE1 );\n          state.bindTexture( gl.TEXTURE_2D, tempTexture );\n          gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n          // update object positions\n\n          flare.positionScreen.copy( screenPosition );\n\n          if ( flare.customUpdateCallback ) {\n\n            flare.customUpdateCallback( flare );\n\n          } else {\n\n            flare.updateLensFlares();\n\n          }\n\n          // render flares\n\n          gl.uniform1i( uniforms.renderType, 2 );\n          state.enable( gl.BLEND );\n\n          for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n            var sprite = flare.lensFlares[ j ];\n\n            if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n              screenPosition.x = sprite.x;\n              screenPosition.y = sprite.y;\n              screenPosition.z = sprite.z;\n\n              size = sprite.size * sprite.scale / viewport.w;\n\n              scale.x = size * invAspect;\n              scale.y = size;\n\n              gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n              gl.uniform2f( uniforms.scale, scale.x, scale.y );\n              gl.uniform1f( uniforms.rotation, sprite.rotation );\n\n              gl.uniform1f( uniforms.opacity, sprite.opacity );\n              gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n              state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n              renderer.setTexture2D( sprite.texture, 1 );\n\n              gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n            }\n\n          }\n\n        }\n\n      }\n\n      // restore gl\n\n      state.enable( gl.CULL_FACE );\n      state.enable( gl.DEPTH_TEST );\n      state.setDepthWrite( true );\n\n      renderer.resetGLState();\n\n    };\n\n    function createProgram( shader ) {\n\n      var program = gl.createProgram();\n\n      var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n      var vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n      var prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n      gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n      gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n      gl.compileShader( fragmentShader );\n      gl.compileShader( vertexShader );\n\n      gl.attachShader( program, fragmentShader );\n      gl.attachShader( program, vertexShader );\n\n      gl.linkProgram( program );\n\n      return program;\n\n    }\n\n  }\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function SpritePlugin( renderer, sprites ) {\n\n    var gl = renderer.context;\n    var state = renderer.state;\n\n    var vertexBuffer, elementBuffer;\n    var program, attributes, uniforms;\n\n    var texture;\n\n    // decompose matrixWorld\n\n    var spritePosition = new Vector3();\n    var spriteRotation = new Quaternion();\n    var spriteScale = new Vector3();\n\n    function init() {\n\n      var vertices = new Float32Array( [\n        - 0.5, - 0.5,  0, 0,\n          0.5, - 0.5,  1, 0,\n          0.5,   0.5,  1, 1,\n        - 0.5,   0.5,  0, 1\n      ] );\n\n      var faces = new Uint16Array( [\n        0, 1, 2,\n        0, 2, 3\n      ] );\n\n      vertexBuffer  = gl.createBuffer();\n      elementBuffer = gl.createBuffer();\n\n      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n      program = createProgram();\n\n      attributes = {\n        position:     gl.getAttribLocation ( program, 'position' ),\n        uv:         gl.getAttribLocation ( program, 'uv' )\n      };\n\n      uniforms = {\n        uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),\n        uvScale:      gl.getUniformLocation( program, 'uvScale' ),\n\n        rotation:     gl.getUniformLocation( program, 'rotation' ),\n        scale:        gl.getUniformLocation( program, 'scale' ),\n\n        color:        gl.getUniformLocation( program, 'color' ),\n        map:        gl.getUniformLocation( program, 'map' ),\n        opacity:      gl.getUniformLocation( program, 'opacity' ),\n\n        modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),\n        projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\n\n        fogType:      gl.getUniformLocation( program, 'fogType' ),\n        fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),\n        fogNear:      gl.getUniformLocation( program, 'fogNear' ),\n        fogFar:       gl.getUniformLocation( program, 'fogFar' ),\n        fogColor:     gl.getUniformLocation( program, 'fogColor' ),\n\n        alphaTest:      gl.getUniformLocation( program, 'alphaTest' )\n      };\n\n      var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n      canvas.width = 8;\n      canvas.height = 8;\n\n      var context = canvas.getContext( '2d' );\n      context.fillStyle = 'white';\n      context.fillRect( 0, 0, 8, 8 );\n\n      texture = new Texture( canvas );\n      texture.needsUpdate = true;\n\n    }\n\n    this.render = function ( scene, camera ) {\n\n      if ( sprites.length === 0 ) return;\n\n      // setup gl\n\n      if ( program === undefined ) {\n\n        init();\n\n      }\n\n      gl.useProgram( program );\n\n      state.initAttributes();\n      state.enableAttribute( attributes.position );\n      state.enableAttribute( attributes.uv );\n      state.disableUnusedAttributes();\n\n      state.disable( gl.CULL_FACE );\n      state.enable( gl.BLEND );\n\n      gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n      gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n      gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n      gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n      state.activeTexture( gl.TEXTURE0 );\n      gl.uniform1i( uniforms.map, 0 );\n\n      var oldFogType = 0;\n      var sceneFogType = 0;\n      var fog = scene.fog;\n\n      if ( fog ) {\n\n        gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n        if ( fog.isFog ) {\n\n          gl.uniform1f( uniforms.fogNear, fog.near );\n          gl.uniform1f( uniforms.fogFar, fog.far );\n\n          gl.uniform1i( uniforms.fogType, 1 );\n          oldFogType = 1;\n          sceneFogType = 1;\n\n        } else if ( fog.isFogExp2 ) {\n\n          gl.uniform1f( uniforms.fogDensity, fog.density );\n\n          gl.uniform1i( uniforms.fogType, 2 );\n          oldFogType = 2;\n          sceneFogType = 2;\n\n        }\n\n      } else {\n\n        gl.uniform1i( uniforms.fogType, 0 );\n        oldFogType = 0;\n        sceneFogType = 0;\n\n      }\n\n\n      // update positions and sort\n\n      for ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n        var sprite = sprites[ i ];\n\n        sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n        sprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n      }\n\n      sprites.sort( painterSortStable );\n\n      // render all sprites\n\n      var scale = [];\n\n      for ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n        var sprite = sprites[ i ];\n        var material = sprite.material;\n\n        if ( material.visible === false ) continue;\n\n        gl.uniform1f( uniforms.alphaTest, material.alphaTest );\n        gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n        sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n        scale[ 0 ] = spriteScale.x;\n        scale[ 1 ] = spriteScale.y;\n\n        var fogType = 0;\n\n        if ( scene.fog && material.fog ) {\n\n          fogType = sceneFogType;\n\n        }\n\n        if ( oldFogType !== fogType ) {\n\n          gl.uniform1i( uniforms.fogType, fogType );\n          oldFogType = fogType;\n\n        }\n\n        if ( material.map !== null ) {\n\n          gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n          gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n        } else {\n\n          gl.uniform2f( uniforms.uvOffset, 0, 0 );\n          gl.uniform2f( uniforms.uvScale, 1, 1 );\n\n        }\n\n        gl.uniform1f( uniforms.opacity, material.opacity );\n        gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n        gl.uniform1f( uniforms.rotation, material.rotation );\n        gl.uniform2fv( uniforms.scale, scale );\n\n        state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n        state.setDepthTest( material.depthTest );\n        state.setDepthWrite( material.depthWrite );\n\n        if ( material.map ) {\n\n          renderer.setTexture2D( material.map, 0 );\n\n        } else {\n\n          renderer.setTexture2D( texture, 0 );\n\n        }\n\n        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n      }\n\n      // restore gl\n\n      state.enable( gl.CULL_FACE );\n\n      renderer.resetGLState();\n\n    };\n\n    function createProgram() {\n\n      var program = gl.createProgram();\n\n      var vertexShader = gl.createShader( gl.VERTEX_SHADER );\n      var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n      gl.shaderSource( vertexShader, [\n\n        'precision ' + renderer.getPrecision() + ' float;',\n\n        'uniform mat4 modelViewMatrix;',\n        'uniform mat4 projectionMatrix;',\n        'uniform float rotation;',\n        'uniform vec2 scale;',\n        'uniform vec2 uvOffset;',\n        'uniform vec2 uvScale;',\n\n        'attribute vec2 position;',\n        'attribute vec2 uv;',\n\n        'varying vec2 vUV;',\n\n        'void main() {',\n\n          'vUV = uvOffset + uv * uvScale;',\n\n          'vec2 alignedPosition = position * scale;',\n\n          'vec2 rotatedPosition;',\n          'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n          'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n          'vec4 finalPosition;',\n\n          'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n          'finalPosition.xy += rotatedPosition;',\n          'finalPosition = projectionMatrix * finalPosition;',\n\n          'gl_Position = finalPosition;',\n\n        '}'\n\n      ].join( '\\n' ) );\n\n      gl.shaderSource( fragmentShader, [\n\n        'precision ' + renderer.getPrecision() + ' float;',\n\n        'uniform vec3 color;',\n        'uniform sampler2D map;',\n        'uniform float opacity;',\n\n        'uniform int fogType;',\n        'uniform vec3 fogColor;',\n        'uniform float fogDensity;',\n        'uniform float fogNear;',\n        'uniform float fogFar;',\n        'uniform float alphaTest;',\n\n        'varying vec2 vUV;',\n\n        'void main() {',\n\n          'vec4 texture = texture2D( map, vUV );',\n\n          'if ( texture.a < alphaTest ) discard;',\n\n          'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n          'if ( fogType > 0 ) {',\n\n            'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n            'float fogFactor = 0.0;',\n\n            'if ( fogType == 1 ) {',\n\n              'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n            '} else {',\n\n              'const float LOG2 = 1.442695;',\n              'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n              'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n            '}',\n\n            'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n          '}',\n\n        '}'\n\n      ].join( '\\n' ) );\n\n      gl.compileShader( vertexShader );\n      gl.compileShader( fragmentShader );\n\n      gl.attachShader( program, vertexShader );\n      gl.attachShader( program, fragmentShader );\n\n      gl.linkProgram( program );\n\n      return program;\n\n    }\n\n    function painterSortStable( a, b ) {\n\n      if ( a.renderOrder !== b.renderOrder ) {\n\n        return a.renderOrder - b.renderOrder;\n\n      } else if ( a.z !== b.z ) {\n\n        return b.z - a.z;\n\n      } else {\n\n        return b.id - a.id;\n\n      }\n\n    }\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  var materialId = 0;\n\n  function Material() {\n\n    Object.defineProperty( this, 'id', { value: materialId ++ } );\n\n    this.uuid = _Math.generateUUID();\n\n    this.name = '';\n    this.type = 'Material';\n\n    this.fog = true;\n    this.lights = true;\n\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n    this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n    this.opacity = 1;\n    this.transparent = false;\n\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n\n    this.colorWrite = true;\n\n    this.precision = null; // override the renderer's default precision for this material\n\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n\n    this.alphaTest = 0;\n    this.premultipliedAlpha = false;\n\n    this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n    this.visible = true;\n\n    this._needsUpdate = true;\n\n  }\n\n  Object.defineProperty( Material.prototype, 'needsUpdate', {\n\n    get: function () {\n\n      return this._needsUpdate;\n\n    },\n\n    set: function ( value ) {\n\n      if ( value === true ) this.update();\n      this._needsUpdate = value;\n\n    }\n\n  } );\n\n  Object.assign( Material.prototype, EventDispatcher.prototype, {\n\n    isMaterial: true,\n\n    setValues: function ( values ) {\n\n      if ( values === undefined ) return;\n\n      for ( var key in values ) {\n\n        var newValue = values[ key ];\n\n        if ( newValue === undefined ) {\n\n          console.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n          continue;\n\n        }\n\n        var currentValue = this[ key ];\n\n        if ( currentValue === undefined ) {\n\n          console.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n          continue;\n\n        }\n\n        if ( currentValue && currentValue.isColor ) {\n\n          currentValue.set( newValue );\n\n        } else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n          currentValue.copy( newValue );\n\n        } else if ( key === 'overdraw' ) {\n\n          // ensure overdraw is backwards-compatible with legacy boolean type\n          this[ key ] = Number( newValue );\n\n        } else {\n\n          this[ key ] = newValue;\n\n        }\n\n      }\n\n    },\n\n    toJSON: function ( meta ) {\n\n      var isRoot = meta === undefined;\n\n      if ( isRoot ) {\n\n        meta = {\n          textures: {},\n          images: {}\n        };\n\n      }\n\n      var data = {\n        metadata: {\n          version: 4.4,\n          type: 'Material',\n          generator: 'Material.toJSON'\n        }\n      };\n\n      // standard Material serialization\n      data.uuid = this.uuid;\n      data.type = this.type;\n\n      if ( this.name !== '' ) data.name = this.name;\n\n      if ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n      if ( this.roughness !== undefined ) data.roughness = this.roughness;\n      if ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n      if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n      if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n      if ( this.shininess !== undefined ) data.shininess = this.shininess;\n      if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\n      if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\n\n      if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n      if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n      if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n      if ( this.bumpMap && this.bumpMap.isTexture ) {\n\n        data.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n        data.bumpScale = this.bumpScale;\n\n      }\n      if ( this.normalMap && this.normalMap.isTexture ) {\n\n        data.normalMap = this.normalMap.toJSON( meta ).uuid;\n        data.normalScale = this.normalScale.toArray();\n\n      }\n      if ( this.displacementMap && this.displacementMap.isTexture ) {\n\n        data.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n\n      }\n      if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n      if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n      if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n      if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n      if ( this.envMap && this.envMap.isTexture ) {\n\n        data.envMap = this.envMap.toJSON( meta ).uuid;\n        data.reflectivity = this.reflectivity; // Scale behind envMap\n\n      }\n\n      if ( this.gradientMap && this.gradientMap.isTexture ) {\n\n        data.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n      }\n\n      if ( this.size !== undefined ) data.size = this.size;\n      if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n      if ( this.blending !== NormalBlending ) data.blending = this.blending;\n      if ( this.shading !== SmoothShading ) data.shading = this.shading;\n      if ( this.side !== FrontSide ) data.side = this.side;\n      if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\n\n      if ( this.opacity < 1 ) data.opacity = this.opacity;\n      if ( this.transparent === true ) data.transparent = this.transparent;\n\n      data.depthFunc = this.depthFunc;\n      data.depthTest = this.depthTest;\n      data.depthWrite = this.depthWrite;\n\n      if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n      if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n      if ( this.wireframe === true ) data.wireframe = this.wireframe;\n      if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n      if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n      if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n      data.skinning = this.skinning;\n      data.morphTargets = this.morphTargets;\n\n      // TODO: Copied from Object3D.toJSON\n\n      function extractFromCache( cache ) {\n\n        var values = [];\n\n        for ( var key in cache ) {\n\n          var data = cache[ key ];\n          delete data.metadata;\n          values.push( data );\n\n        }\n\n        return values;\n\n      }\n\n      if ( isRoot ) {\n\n        var textures = extractFromCache( meta.textures );\n        var images = extractFromCache( meta.images );\n\n        if ( textures.length > 0 ) data.textures = textures;\n        if ( images.length > 0 ) data.images = images;\n\n      }\n\n      return data;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      this.name = source.name;\n\n      this.fog = source.fog;\n      this.lights = source.lights;\n\n      this.blending = source.blending;\n      this.side = source.side;\n      this.shading = source.shading;\n      this.vertexColors = source.vertexColors;\n\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n\n      this.colorWrite = source.colorWrite;\n\n      this.precision = source.precision;\n\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n\n      this.alphaTest = source.alphaTest;\n\n      this.premultipliedAlpha = source.premultipliedAlpha;\n\n      this.overdraw = source.overdraw;\n\n      this.visible = source.visible;\n      this.clipShadows = source.clipShadows;\n      this.clipIntersection = source.clipIntersection;\n\n      var srcPlanes = source.clippingPlanes,\n        dstPlanes = null;\n\n      if ( srcPlanes !== null ) {\n\n        var n = srcPlanes.length;\n        dstPlanes = new Array( n );\n\n        for ( var i = 0; i !== n; ++ i )\n          dstPlanes[ i ] = srcPlanes[ i ].clone();\n\n      }\n\n      this.clippingPlanes = dstPlanes;\n\n      return this;\n\n    },\n\n    update: function () {\n\n      this.dispatchEvent( { type: 'update' } );\n\n    },\n\n    dispose: function () {\n\n      this.dispatchEvent( { type: 'dispose' } );\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  defines: { \"label\" : \"value\" },\n   *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n   *\n   *  fragmentShader: <string>,\n   *  vertexShader: <string>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>,\n   *\n   *  lights: <bool>,\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>,\n   *  morphNormals: <bool>\n   * }\n   */\n\n  function ShaderMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'ShaderMaterial';\n\n    this.defines = {};\n    this.uniforms = {};\n\n    this.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n    this.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n    this.linewidth = 1;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false; // set to use scene fog\n    this.lights = false; // set to use scene lights\n    this.clipping = false; // set to use user-defined clipping planes\n\n    this.skinning = false; // set to use skinning attribute streams\n    this.morphTargets = false; // set to use morph targets\n    this.morphNormals = false; // set to use morph normals\n\n    this.extensions = {\n      derivatives: false, // set to use derivatives\n      fragDepth: false, // set to use fragment depth values\n      drawBuffers: false, // set to use draw buffers\n      shaderTextureLOD: false // set to use shader texture LOD\n    };\n\n    // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n    this.defaultAttributeValues = {\n      'color': [ 1, 1, 1 ],\n      'uv': [ 0, 0 ],\n      'uv2': [ 0, 0 ]\n    };\n\n    this.index0AttributeName = undefined;\n\n    if ( parameters !== undefined ) {\n\n      if ( parameters.attributes !== undefined ) {\n\n        console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n      }\n\n      this.setValues( parameters );\n\n    }\n\n  }\n\n  ShaderMaterial.prototype = Object.create( Material.prototype );\n  ShaderMaterial.prototype.constructor = ShaderMaterial;\n\n  ShaderMaterial.prototype.isShaderMaterial = true;\n\n  ShaderMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n\n    this.uniforms = UniformsUtils.clone( source.uniforms );\n\n    this.defines = source.defines;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n\n    this.skinning = source.skinning;\n\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n\n    this.extensions = source.extensions;\n\n    return this;\n\n  };\n\n  ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n    var data = Material.prototype.toJSON.call( this, meta );\n\n    data.uniforms = this.uniforms;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n\n    return data;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   * @author bhouston / https://clara.io\n   * @author WestLangley / http://github.com/WestLangley\n   *\n   * parameters = {\n   *\n   *  opacity: <float>,\n   *\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  alphaMap: new THREE.Texture( <Image> ),\n   *\n   *  displacementMap: new THREE.Texture( <Image> ),\n   *  displacementScale: <float>,\n   *  displacementBias: <float>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>\n   * }\n   */\n\n  function MeshDepthMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'MeshDepthMaterial';\n\n    this.depthPacking = BasicDepthPacking;\n\n    this.skinning = false;\n    this.morphTargets = false;\n\n    this.map = null;\n\n    this.alphaMap = null;\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false;\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshDepthMaterial.prototype = Object.create( Material.prototype );\n  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\n\n  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n  MeshDepthMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.depthPacking = source.depthPacking;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n\n    this.map = source.map;\n\n    this.alphaMap = source.alphaMap;\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    return this;\n\n  };\n\n  /**\n   * @author bhouston / http://clara.io\n   * @author WestLangley / http://github.com/WestLangley\n   */\n\n  function Box3( min, max ) {\n\n    this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\n    this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\n\n  }\n\n  Object.assign( Box3.prototype, {\n\n    isBox3: true,\n\n    set: function ( min, max ) {\n\n      this.min.copy( min );\n      this.max.copy( max );\n\n      return this;\n\n    },\n\n    setFromArray: function ( array ) {\n\n      var minX = + Infinity;\n      var minY = + Infinity;\n      var minZ = + Infinity;\n\n      var maxX = - Infinity;\n      var maxY = - Infinity;\n      var maxZ = - Infinity;\n\n      for ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n        var x = array[ i ];\n        var y = array[ i + 1 ];\n        var z = array[ i + 2 ];\n\n        if ( x < minX ) minX = x;\n        if ( y < minY ) minY = y;\n        if ( z < minZ ) minZ = z;\n\n        if ( x > maxX ) maxX = x;\n        if ( y > maxY ) maxY = y;\n        if ( z > maxZ ) maxZ = z;\n\n      }\n\n      this.min.set( minX, minY, minZ );\n      this.max.set( maxX, maxY, maxZ );\n\n      return this;\n\n    },\n\n    setFromBufferAttribute: function ( attribute ) {\n\n      var minX = + Infinity;\n      var minY = + Infinity;\n      var minZ = + Infinity;\n\n      var maxX = - Infinity;\n      var maxY = - Infinity;\n      var maxZ = - Infinity;\n\n      for ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n        var x = attribute.getX( i );\n        var y = attribute.getY( i );\n        var z = attribute.getZ( i );\n\n        if ( x < minX ) minX = x;\n        if ( y < minY ) minY = y;\n        if ( z < minZ ) minZ = z;\n\n        if ( x > maxX ) maxX = x;\n        if ( y > maxY ) maxY = y;\n        if ( z > maxZ ) maxZ = z;\n\n      }\n\n      this.min.set( minX, minY, minZ );\n      this.max.set( maxX, maxY, maxZ );\n\n      return this;\n\n    },\n\n    setFromPoints: function ( points ) {\n\n      this.makeEmpty();\n\n      for ( var i = 0, il = points.length; i < il; i ++ ) {\n\n        this.expandByPoint( points[ i ] );\n\n      }\n\n      return this;\n\n    },\n\n    setFromCenterAndSize: function () {\n\n      var v1 = new Vector3();\n\n      return function setFromCenterAndSize( center, size ) {\n\n        var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n        this.min.copy( center ).sub( halfSize );\n        this.max.copy( center ).add( halfSize );\n\n        return this;\n\n      };\n\n    }(),\n\n    setFromObject: function ( object ) {\n\n      this.makeEmpty();\n\n      return this.expandByObject( object );\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( box ) {\n\n      this.min.copy( box.min );\n      this.max.copy( box.max );\n\n      return this;\n\n    },\n\n    makeEmpty: function () {\n\n      this.min.x = this.min.y = this.min.z = + Infinity;\n      this.max.x = this.max.y = this.max.z = - Infinity;\n\n      return this;\n\n    },\n\n    isEmpty: function () {\n\n      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n      return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n    },\n\n    getCenter: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n    },\n\n    getSize: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\n\n    },\n\n    expandByPoint: function ( point ) {\n\n      this.min.min( point );\n      this.max.max( point );\n\n      return this;\n\n    },\n\n    expandByVector: function ( vector ) {\n\n      this.min.sub( vector );\n      this.max.add( vector );\n\n      return this;\n\n    },\n\n    expandByScalar: function ( scalar ) {\n\n      this.min.addScalar( - scalar );\n      this.max.addScalar( scalar );\n\n      return this;\n\n    },\n\n    expandByObject: function () {\n\n      // Computes the world-axis-aligned bounding box of an object (including its children),\n      // accounting for both the object's, and children's, world transforms\n\n      var v1 = new Vector3();\n\n      return function expandByObject( object ) {\n\n        var scope = this;\n\n        object.updateMatrixWorld( true );\n\n        object.traverse( function ( node ) {\n\n          var i, l;\n\n          var geometry = node.geometry;\n\n          if ( geometry !== undefined ) {\n\n            if ( geometry.isGeometry ) {\n\n              var vertices = geometry.vertices;\n\n              for ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n                v1.copy( vertices[ i ] );\n                v1.applyMatrix4( node.matrixWorld );\n\n                scope.expandByPoint( v1 );\n\n              }\n\n            } else if ( geometry.isBufferGeometry ) {\n\n              var attribute = geometry.attributes.position;\n\n              if ( attribute !== undefined ) {\n\n                for ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n                  v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n                  scope.expandByPoint( v1 );\n\n                }\n\n              }\n\n            }\n\n          }\n\n        } );\n\n        return this;\n\n      };\n\n    }(),\n\n    containsPoint: function ( point ) {\n\n      return point.x < this.min.x || point.x > this.max.x ||\n        point.y < this.min.y || point.y > this.max.y ||\n        point.z < this.min.z || point.z > this.max.z ? false : true;\n\n    },\n\n    containsBox: function ( box ) {\n\n      return this.min.x <= box.min.x && box.max.x <= this.max.x &&\n        this.min.y <= box.min.y && box.max.y <= this.max.y &&\n        this.min.z <= box.min.z && box.max.z <= this.max.z;\n\n    },\n\n    getParameter: function ( point, optionalTarget ) {\n\n      // This can potentially have a divide by zero if the box\n      // has a size dimension of 0.\n\n      var result = optionalTarget || new Vector3();\n\n      return result.set(\n        ( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n        ( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n        ( point.z - this.min.z ) / ( this.max.z - this.min.z )\n      );\n\n    },\n\n    intersectsBox: function ( box ) {\n\n      // using 6 splitting planes to rule out intersections.\n      return box.max.x < this.min.x || box.min.x > this.max.x ||\n        box.max.y < this.min.y || box.min.y > this.max.y ||\n        box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n    },\n\n    intersectsSphere: ( function () {\n\n      var closestPoint = new Vector3();\n\n      return function intersectsSphere( sphere ) {\n\n        // Find the point on the AABB closest to the sphere center.\n        this.clampPoint( sphere.center, closestPoint );\n\n        // If that point is inside the sphere, the AABB and sphere intersect.\n        return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n      };\n\n    } )(),\n\n    intersectsPlane: function ( plane ) {\n\n      // We compute the minimum and maximum dot product values. If those values\n      // are on the same side (back or front) of the plane, then there is no intersection.\n\n      var min, max;\n\n      if ( plane.normal.x > 0 ) {\n\n        min = plane.normal.x * this.min.x;\n        max = plane.normal.x * this.max.x;\n\n      } else {\n\n        min = plane.normal.x * this.max.x;\n        max = plane.normal.x * this.min.x;\n\n      }\n\n      if ( plane.normal.y > 0 ) {\n\n        min += plane.normal.y * this.min.y;\n        max += plane.normal.y * this.max.y;\n\n      } else {\n\n        min += plane.normal.y * this.max.y;\n        max += plane.normal.y * this.min.y;\n\n      }\n\n      if ( plane.normal.z > 0 ) {\n\n        min += plane.normal.z * this.min.z;\n        max += plane.normal.z * this.max.z;\n\n      } else {\n\n        min += plane.normal.z * this.max.z;\n        max += plane.normal.z * this.min.z;\n\n      }\n\n      return ( min <= plane.constant && max >= plane.constant );\n\n    },\n\n    clampPoint: function ( point, optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return result.copy( point ).clamp( this.min, this.max );\n\n    },\n\n    distanceToPoint: function () {\n\n      var v1 = new Vector3();\n\n      return function distanceToPoint( point ) {\n\n        var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n        return clampedPoint.sub( point ).length();\n\n      };\n\n    }(),\n\n    getBoundingSphere: function () {\n\n      var v1 = new Vector3();\n\n      return function getBoundingSphere( optionalTarget ) {\n\n        var result = optionalTarget || new Sphere();\n\n        this.getCenter( result.center );\n\n        result.radius = this.getSize( v1 ).length() * 0.5;\n\n        return result;\n\n      };\n\n    }(),\n\n    intersect: function ( box ) {\n\n      this.min.max( box.min );\n      this.max.min( box.max );\n\n      // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n      if( this.isEmpty() ) this.makeEmpty();\n\n      return this;\n\n    },\n\n    union: function ( box ) {\n\n      this.min.min( box.min );\n      this.max.max( box.max );\n\n      return this;\n\n    },\n\n    applyMatrix4: function () {\n\n      var points = [\n        new Vector3(),\n        new Vector3(),\n        new Vector3(),\n        new Vector3(),\n        new Vector3(),\n        new Vector3(),\n        new Vector3(),\n        new Vector3()\n      ];\n\n      return function applyMatrix4( matrix ) {\n\n        // transform of empty box is an empty box.\n        if( this.isEmpty() ) return this;\n\n        // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n        points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n        points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n        points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n        points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n        points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n        points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n        points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n        points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n        this.setFromPoints( points );\n\n        return this;\n\n      };\n\n    }(),\n\n    translate: function ( offset ) {\n\n      this.min.add( offset );\n      this.max.add( offset );\n\n      return this;\n\n    },\n\n    equals: function ( box ) {\n\n      return box.min.equals( this.min ) && box.max.equals( this.max );\n\n    }\n\n  } );\n\n  /**\n   * @author bhouston / http://clara.io\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Sphere( center, radius ) {\n\n    this.center = ( center !== undefined ) ? center : new Vector3();\n    this.radius = ( radius !== undefined ) ? radius : 0;\n\n  }\n\n  Object.assign( Sphere.prototype, {\n\n    set: function ( center, radius ) {\n\n      this.center.copy( center );\n      this.radius = radius;\n\n      return this;\n\n    },\n\n    setFromPoints: function () {\n\n      var box = new Box3();\n\n      return function setFromPoints( points, optionalCenter ) {\n\n        var center = this.center;\n\n        if ( optionalCenter !== undefined ) {\n\n          center.copy( optionalCenter );\n\n        } else {\n\n          box.setFromPoints( points ).getCenter( center );\n\n        }\n\n        var maxRadiusSq = 0;\n\n        for ( var i = 0, il = points.length; i < il; i ++ ) {\n\n          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n        }\n\n        this.radius = Math.sqrt( maxRadiusSq );\n\n        return this;\n\n      };\n\n    }(),\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( sphere ) {\n\n      this.center.copy( sphere.center );\n      this.radius = sphere.radius;\n\n      return this;\n\n    },\n\n    empty: function () {\n\n      return ( this.radius <= 0 );\n\n    },\n\n    containsPoint: function ( point ) {\n\n      return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n    },\n\n    distanceToPoint: function ( point ) {\n\n      return ( point.distanceTo( this.center ) - this.radius );\n\n    },\n\n    intersectsSphere: function ( sphere ) {\n\n      var radiusSum = this.radius + sphere.radius;\n\n      return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n    },\n\n    intersectsBox: function ( box ) {\n\n      return box.intersectsSphere( this );\n\n    },\n\n    intersectsPlane: function ( plane ) {\n\n      // We use the following equation to compute the signed distance from\n      // the center of the sphere to the plane.\n      //\n      // distance = q * n - d\n      //\n      // If this distance is greater than the radius of the sphere,\n      // then there is no intersection.\n\n      return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n    },\n\n    clampPoint: function ( point, optionalTarget ) {\n\n      var deltaLengthSq = this.center.distanceToSquared( point );\n\n      var result = optionalTarget || new Vector3();\n\n      result.copy( point );\n\n      if ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n        result.sub( this.center ).normalize();\n        result.multiplyScalar( this.radius ).add( this.center );\n\n      }\n\n      return result;\n\n    },\n\n    getBoundingBox: function ( optionalTarget ) {\n\n      var box = optionalTarget || new Box3();\n\n      box.set( this.center, this.center );\n      box.expandByScalar( this.radius );\n\n      return box;\n\n    },\n\n    applyMatrix4: function ( matrix ) {\n\n      this.center.applyMatrix4( matrix );\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n      return this;\n\n    },\n\n    translate: function ( offset ) {\n\n      this.center.add( offset );\n\n      return this;\n\n    },\n\n    equals: function ( sphere ) {\n\n      return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author bhouston / http://clara.io\n   * @author tschw\n   */\n\n  function Matrix3() {\n\n    this.elements = new Float32Array( [\n\n      1, 0, 0,\n      0, 1, 0,\n      0, 0, 1\n\n    ] );\n\n    if ( arguments.length > 0 ) {\n\n      console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n    }\n\n  }\n\n  Object.assign( Matrix3.prototype, {\n\n    isMatrix3: true,\n\n    set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n      var te = this.elements;\n\n      te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n      te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n      te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n      return this;\n\n    },\n\n    identity: function () {\n\n      this.set(\n\n        1, 0, 0,\n        0, 1, 0,\n        0, 0, 1\n\n      );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().fromArray( this.elements );\n\n    },\n\n    copy: function ( m ) {\n\n      var me = m.elements;\n\n      this.set(\n\n        me[ 0 ], me[ 3 ], me[ 6 ],\n        me[ 1 ], me[ 4 ], me[ 7 ],\n        me[ 2 ], me[ 5 ], me[ 8 ]\n\n      );\n\n      return this;\n\n    },\n\n    setFromMatrix4: function( m ) {\n\n      var me = m.elements;\n\n      this.set(\n\n        me[ 0 ], me[ 4 ], me[  8 ],\n        me[ 1 ], me[ 5 ], me[  9 ],\n        me[ 2 ], me[ 6 ], me[ 10 ]\n\n      );\n\n      return this;\n\n    },\n\n    applyToBufferAttribute: function () {\n\n      var v1 = new Vector3();\n\n      return function applyToBufferAttribute( attribute ) {\n\n        for ( var i = 0, l = attribute.count; i < l; i ++ ) {\n\n          v1.x = attribute.getX( i );\n          v1.y = attribute.getY( i );\n          v1.z = attribute.getZ( i );\n\n          v1.applyMatrix3( this );\n\n          attribute.setXYZ( i, v1.x, v1.y, v1.z );\n\n        }\n\n        return attribute;\n\n      };\n\n    }(),\n\n    multiplyScalar: function ( s ) {\n\n      var te = this.elements;\n\n      te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n      te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n      te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n      return this;\n\n    },\n\n    determinant: function () {\n\n      var te = this.elements;\n\n      var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n        d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n        g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n    },\n\n    getInverse: function ( matrix, throwOnDegenerate ) {\n\n      if ( matrix && matrix.isMatrix4 ) {\n\n        console.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n      }\n\n      var me = matrix.elements,\n        te = this.elements,\n\n        n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n        n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n        n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n        t11 = n33 * n22 - n32 * n23,\n        t12 = n32 * n13 - n33 * n12,\n        t13 = n23 * n12 - n22 * n13,\n\n        det = n11 * t11 + n21 * t12 + n31 * t13;\n\n      if ( det === 0 ) {\n\n        var msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n        if ( throwOnDegenerate === true ) {\n\n          throw new Error( msg );\n\n        } else {\n\n          console.warn( msg );\n\n        }\n\n        return this.identity();\n      }\n\n      var detInv = 1 / det;\n\n      te[ 0 ] = t11 * detInv;\n      te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n      te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n      te[ 3 ] = t12 * detInv;\n      te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n      te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n      te[ 6 ] = t13 * detInv;\n      te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n      te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n      return this;\n\n    },\n\n    transpose: function () {\n\n      var tmp, m = this.elements;\n\n      tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n      tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n      tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n      return this;\n\n    },\n\n    getNormalMatrix: function ( matrix4 ) {\n\n      return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n    },\n\n    transposeIntoArray: function ( r ) {\n\n      var m = this.elements;\n\n      r[ 0 ] = m[ 0 ];\n      r[ 1 ] = m[ 3 ];\n      r[ 2 ] = m[ 6 ];\n      r[ 3 ] = m[ 1 ];\n      r[ 4 ] = m[ 4 ];\n      r[ 5 ] = m[ 7 ];\n      r[ 6 ] = m[ 2 ];\n      r[ 7 ] = m[ 5 ];\n      r[ 8 ] = m[ 8 ];\n\n      return this;\n\n    },\n\n    fromArray: function ( array, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      for( var i = 0; i < 9; i ++ ) {\n\n        this.elements[ i ] = array[ i + offset ];\n\n      }\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      var te = this.elements;\n\n      array[ offset ] = te[ 0 ];\n      array[ offset + 1 ] = te[ 1 ];\n      array[ offset + 2 ] = te[ 2 ];\n\n      array[ offset + 3 ] = te[ 3 ];\n      array[ offset + 4 ] = te[ 4 ];\n      array[ offset + 5 ] = te[ 5 ];\n\n      array[ offset + 6 ] = te[ 6 ];\n      array[ offset + 7 ] = te[ 7 ];\n      array[ offset + 8 ]  = te[ 8 ];\n\n      return array;\n\n    }\n\n  } );\n\n  /**\n   * @author bhouston / http://clara.io\n   */\n\n  function Plane( normal, constant ) {\n\n    this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\n    this.constant = ( constant !== undefined ) ? constant : 0;\n\n  }\n\n  Object.assign( Plane.prototype, {\n\n    set: function ( normal, constant ) {\n\n      this.normal.copy( normal );\n      this.constant = constant;\n\n      return this;\n\n    },\n\n    setComponents: function ( x, y, z, w ) {\n\n      this.normal.set( x, y, z );\n      this.constant = w;\n\n      return this;\n\n    },\n\n    setFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n      this.normal.copy( normal );\n      this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized\n\n      return this;\n\n    },\n\n    setFromCoplanarPoints: function () {\n\n      var v1 = new Vector3();\n      var v2 = new Vector3();\n\n      return function setFromCoplanarPoints( a, b, c ) {\n\n        var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n        this.setFromNormalAndCoplanarPoint( normal, a );\n\n        return this;\n\n      };\n\n    }(),\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( plane ) {\n\n      this.normal.copy( plane.normal );\n      this.constant = plane.constant;\n\n      return this;\n\n    },\n\n    normalize: function () {\n\n      // Note: will lead to a divide by zero if the plane is invalid.\n\n      var inverseNormalLength = 1.0 / this.normal.length();\n      this.normal.multiplyScalar( inverseNormalLength );\n      this.constant *= inverseNormalLength;\n\n      return this;\n\n    },\n\n    negate: function () {\n\n      this.constant *= - 1;\n      this.normal.negate();\n\n      return this;\n\n    },\n\n    distanceToPoint: function ( point ) {\n\n      return this.normal.dot( point ) + this.constant;\n\n    },\n\n    distanceToSphere: function ( sphere ) {\n\n      return this.distanceToPoint( sphere.center ) - sphere.radius;\n\n    },\n\n    projectPoint: function ( point, optionalTarget ) {\n\n      return this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n    },\n\n    orthoPoint: function ( point, optionalTarget ) {\n\n      var perpendicularMagnitude = this.distanceToPoint( point );\n\n      var result = optionalTarget || new Vector3();\n      return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n    },\n\n    intersectLine: function () {\n\n      var v1 = new Vector3();\n\n      return function intersectLine( line, optionalTarget ) {\n\n        var result = optionalTarget || new Vector3();\n\n        var direction = line.delta( v1 );\n\n        var denominator = this.normal.dot( direction );\n\n        if ( denominator === 0 ) {\n\n          // line is coplanar, return origin\n          if ( this.distanceToPoint( line.start ) === 0 ) {\n\n            return result.copy( line.start );\n\n          }\n\n          // Unsure if this is the correct method to handle this case.\n          return undefined;\n\n        }\n\n        var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n        if ( t < 0 || t > 1 ) {\n\n          return undefined;\n\n        }\n\n        return result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n      };\n\n    }(),\n\n    intersectsLine: function ( line ) {\n\n      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n      var startSign = this.distanceToPoint( line.start );\n      var endSign = this.distanceToPoint( line.end );\n\n      return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n    },\n\n    intersectsBox: function ( box ) {\n\n      return box.intersectsPlane( this );\n\n    },\n\n    intersectsSphere: function ( sphere ) {\n\n      return sphere.intersectsPlane( this );\n\n    },\n\n    coplanarPoint: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return result.copy( this.normal ).multiplyScalar( - this.constant );\n\n    },\n\n    applyMatrix4: function () {\n\n      var v1 = new Vector3();\n      var m1 = new Matrix3();\n\n      return function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n        var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n        // transform normal based on theory here:\n        // http://www.songho.ca/opengl/gl_normaltransform.html\n        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n        var normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n        // recalculate constant (like in setFromNormalAndCoplanarPoint)\n        this.constant = - referencePoint.dot( normal );\n\n        return this;\n\n      };\n\n    }(),\n\n    translate: function ( offset ) {\n\n      this.constant = this.constant - offset.dot( this.normal );\n\n      return this;\n\n    },\n\n    equals: function ( plane ) {\n\n      return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   * @author bhouston / http://clara.io\n   */\n\n  function Frustum( p0, p1, p2, p3, p4, p5 ) {\n\n    this.planes = [\n\n      ( p0 !== undefined ) ? p0 : new Plane(),\n      ( p1 !== undefined ) ? p1 : new Plane(),\n      ( p2 !== undefined ) ? p2 : new Plane(),\n      ( p3 !== undefined ) ? p3 : new Plane(),\n      ( p4 !== undefined ) ? p4 : new Plane(),\n      ( p5 !== undefined ) ? p5 : new Plane()\n\n    ];\n\n  }\n\n  Object.assign( Frustum.prototype, {\n\n    set: function ( p0, p1, p2, p3, p4, p5 ) {\n\n      var planes = this.planes;\n\n      planes[ 0 ].copy( p0 );\n      planes[ 1 ].copy( p1 );\n      planes[ 2 ].copy( p2 );\n      planes[ 3 ].copy( p3 );\n      planes[ 4 ].copy( p4 );\n      planes[ 5 ].copy( p5 );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( frustum ) {\n\n      var planes = this.planes;\n\n      for ( var i = 0; i < 6; i ++ ) {\n\n        planes[ i ].copy( frustum.planes[ i ] );\n\n      }\n\n      return this;\n\n    },\n\n    setFromMatrix: function ( m ) {\n\n      var planes = this.planes;\n      var me = m.elements;\n      var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n      var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n      var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n      var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n      planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n      planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n      planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n      planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n      planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n      planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n      return this;\n\n    },\n\n    intersectsObject: function () {\n\n      var sphere = new Sphere();\n\n      return function intersectsObject( object ) {\n\n        var geometry = object.geometry;\n\n        if ( geometry.boundingSphere === null )\n          geometry.computeBoundingSphere();\n\n        sphere.copy( geometry.boundingSphere )\n          .applyMatrix4( object.matrixWorld );\n\n        return this.intersectsSphere( sphere );\n\n      };\n\n    }(),\n\n    intersectsSprite: function () {\n\n      var sphere = new Sphere();\n\n      return function intersectsSprite( sprite ) {\n\n        sphere.center.set( 0, 0, 0 );\n        sphere.radius = 0.7071067811865476;\n        sphere.applyMatrix4( sprite.matrixWorld );\n\n        return this.intersectsSphere( sphere );\n\n      };\n\n    }(),\n\n    intersectsSphere: function ( sphere ) {\n\n      var planes = this.planes;\n      var center = sphere.center;\n      var negRadius = - sphere.radius;\n\n      for ( var i = 0; i < 6; i ++ ) {\n\n        var distance = planes[ i ].distanceToPoint( center );\n\n        if ( distance < negRadius ) {\n\n          return false;\n\n        }\n\n      }\n\n      return true;\n\n    },\n\n    intersectsBox: function () {\n\n      var p1 = new Vector3(),\n        p2 = new Vector3();\n\n      return function intersectsBox( box ) {\n\n        var planes = this.planes;\n\n        for ( var i = 0; i < 6 ; i ++ ) {\n\n          var plane = planes[ i ];\n\n          p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n          p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n          p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n          p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n          p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n          p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n          var d1 = plane.distanceToPoint( p1 );\n          var d2 = plane.distanceToPoint( p2 );\n\n          // if both outside plane, no intersection\n\n          if ( d1 < 0 && d2 < 0 ) {\n\n            return false;\n\n          }\n\n        }\n\n        return true;\n\n      };\n\n    }(),\n\n    containsPoint: function ( point ) {\n\n      var planes = this.planes;\n\n      for ( var i = 0; i < 6; i ++ ) {\n\n        if ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n          return false;\n\n        }\n\n      }\n\n      return true;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {\n\n    var _gl = _renderer.context,\n    _state = _renderer.state,\n    _frustum = new Frustum(),\n    _projScreenMatrix = new Matrix4(),\n\n    _lightShadows = _lights.shadows,\n\n    _shadowMapSize = new Vector2(),\n    _maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n    _lookTarget = new Vector3(),\n    _lightPositionWorld = new Vector3(),\n\n    _renderList = [],\n\n    _MorphingFlag = 1,\n    _SkinningFlag = 2,\n\n    _NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n    _depthMaterials = new Array( _NumberOfMaterialVariants ),\n    _distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n    _materialCache = {};\n\n    var cubeDirections = [\n      new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n      new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n    ];\n\n    var cubeUps = [\n      new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n      new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ), new Vector3( 0, 0, - 1 )\n    ];\n\n    var cube2DViewPorts = [\n      new Vector4(), new Vector4(), new Vector4(),\n      new Vector4(), new Vector4(), new Vector4()\n    ];\n\n    // init\n\n    var depthMaterialTemplate = new MeshDepthMaterial();\n    depthMaterialTemplate.depthPacking = RGBADepthPacking;\n    depthMaterialTemplate.clipping = true;\n\n    var distanceShader = ShaderLib[ \"distanceRGBA\" ];\n    var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );\n\n    for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n      var useMorphing = ( i & _MorphingFlag ) !== 0;\n      var useSkinning = ( i & _SkinningFlag ) !== 0;\n\n      var depthMaterial = depthMaterialTemplate.clone();\n      depthMaterial.morphTargets = useMorphing;\n      depthMaterial.skinning = useSkinning;\n\n      _depthMaterials[ i ] = depthMaterial;\n\n      var distanceMaterial = new ShaderMaterial( {\n        defines: {\n          'USE_SHADOWMAP': ''\n        },\n        uniforms: distanceUniforms,\n        vertexShader: distanceShader.vertexShader,\n        fragmentShader: distanceShader.fragmentShader,\n        morphTargets: useMorphing,\n        skinning: useSkinning,\n        clipping: true\n      } );\n\n      _distanceMaterials[ i ] = distanceMaterial;\n\n    }\n\n    //\n\n    var scope = this;\n\n    this.enabled = false;\n\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n\n    this.type = PCFShadowMap;\n\n    this.renderReverseSided = true;\n    this.renderSingleSided = true;\n\n    this.render = function ( scene, camera ) {\n\n      if ( scope.enabled === false ) return;\n      if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n      if ( _lightShadows.length === 0 ) return;\n\n      // Set GL state for depth map.\n      _state.buffers.color.setClear( 1, 1, 1, 1 );\n      _state.disable( _gl.BLEND );\n      _state.setDepthTest( true );\n      _state.setScissorTest( false );\n\n      // render depth map\n\n      var faceCount, isPointLight;\n\n      for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n        var light = _lightShadows[ i ];\n        var shadow = light.shadow;\n\n        if ( shadow === undefined ) {\n\n          console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n          continue;\n\n        }\n\n        var shadowCamera = shadow.camera;\n\n        _shadowMapSize.copy( shadow.mapSize );\n        _shadowMapSize.min( _maxShadowMapSize );\n\n        if ( light && light.isPointLight ) {\n\n          faceCount = 6;\n          isPointLight = true;\n\n          var vpWidth = _shadowMapSize.x;\n          var vpHeight = _shadowMapSize.y;\n\n          // These viewports map a cube-map onto a 2D texture with the\n          // following orientation:\n          //\n          //  xzXZ\n          //   y Y\n          //\n          // X - Positive x direction\n          // x - Negative x direction\n          // Y - Positive y direction\n          // y - Negative y direction\n          // Z - Positive z direction\n          // z - Negative z direction\n\n          // positive X\n          cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n          // negative X\n          cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n          // positive Z\n          cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n          // negative Z\n          cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n          // positive Y\n          cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n          // negative Y\n          cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n          _shadowMapSize.x *= 4.0;\n          _shadowMapSize.y *= 2.0;\n\n        } else {\n\n          faceCount = 1;\n          isPointLight = false;\n\n        }\n\n        if ( shadow.map === null ) {\n\n          var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\n\n          shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n          shadow.map.texture.name = light.name + \".shadowMap\";\n\n          shadowCamera.updateProjectionMatrix();\n\n        }\n\n        if ( shadow.isSpotLightShadow ) {\n\n          shadow.update( light );\n\n        }\n\n        // TODO (abelnation / sam-g-steel): is this needed?\n        if ( shadow && shadow.isRectAreaLightShadow ) {\n\n          shadow.update( light );\n\n        }\n\n        var shadowMap = shadow.map;\n        var shadowMatrix = shadow.matrix;\n\n        _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n        shadowCamera.position.copy( _lightPositionWorld );\n\n        _renderer.setRenderTarget( shadowMap );\n        _renderer.clear();\n\n        // render shadow map for each cube face (if omni-directional) or\n        // run a single pass if not\n\n        for ( var face = 0; face < faceCount; face ++ ) {\n\n          if ( isPointLight ) {\n\n            _lookTarget.copy( shadowCamera.position );\n            _lookTarget.add( cubeDirections[ face ] );\n            shadowCamera.up.copy( cubeUps[ face ] );\n            shadowCamera.lookAt( _lookTarget );\n\n            var vpDimensions = cube2DViewPorts[ face ];\n            _state.viewport( vpDimensions );\n\n          } else {\n\n            _lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n            shadowCamera.lookAt( _lookTarget );\n\n          }\n\n          shadowCamera.updateMatrixWorld();\n          shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n          // compute shadow matrix\n\n          shadowMatrix.set(\n            0.5, 0.0, 0.0, 0.5,\n            0.0, 0.5, 0.0, 0.5,\n            0.0, 0.0, 0.5, 0.5,\n            0.0, 0.0, 0.0, 1.0\n          );\n\n          shadowMatrix.multiply( shadowCamera.projectionMatrix );\n          shadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n          // update camera matrices and frustum\n\n          _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n          _frustum.setFromMatrix( _projScreenMatrix );\n\n          // set object matrices & frustum culling\n\n          _renderList.length = 0;\n\n          projectObject( scene, camera, shadowCamera );\n\n          // render shadow map\n          // render regular objects\n\n          for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n            var object = _renderList[ j ];\n            var geometry = _objects.update( object );\n            var material = object.material;\n\n            if ( material && material.isMultiMaterial ) {\n\n              var groups = geometry.groups;\n              var materials = material.materials;\n\n              for ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n                var group = groups[ k ];\n                var groupMaterial = materials[ group.materialIndex ];\n\n                if ( groupMaterial.visible === true ) {\n\n                  var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n                  _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n                }\n\n              }\n\n            } else {\n\n              var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n              _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n            }\n\n          }\n\n        }\n\n      }\n\n      // Restore GL state.\n      var clearColor = _renderer.getClearColor();\n      var clearAlpha = _renderer.getClearAlpha();\n      _renderer.setClearColor( clearColor, clearAlpha );\n\n      scope.needsUpdate = false;\n\n    };\n\n    function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n      var geometry = object.geometry;\n\n      var result = null;\n\n      var materialVariants = _depthMaterials;\n      var customMaterial = object.customDepthMaterial;\n\n      if ( isPointLight ) {\n\n        materialVariants = _distanceMaterials;\n        customMaterial = object.customDistanceMaterial;\n\n      }\n\n      if ( ! customMaterial ) {\n\n        var useMorphing = false;\n\n        if ( material.morphTargets ) {\n\n          if ( geometry && geometry.isBufferGeometry ) {\n\n            useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n          } else if ( geometry && geometry.isGeometry ) {\n\n            useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n          }\n\n        }\n\n        var useSkinning = object.isSkinnedMesh && material.skinning;\n\n        var variantIndex = 0;\n\n        if ( useMorphing ) variantIndex |= _MorphingFlag;\n        if ( useSkinning ) variantIndex |= _SkinningFlag;\n\n        result = materialVariants[ variantIndex ];\n\n      } else {\n\n        result = customMaterial;\n\n      }\n\n      if ( _renderer.localClippingEnabled &&\n         material.clipShadows === true &&\n          material.clippingPlanes.length !== 0 ) {\n\n        // in this case we need a unique material instance reflecting the\n        // appropriate state\n\n        var keyA = result.uuid, keyB = material.uuid;\n\n        var materialsForVariant = _materialCache[ keyA ];\n\n        if ( materialsForVariant === undefined ) {\n\n          materialsForVariant = {};\n          _materialCache[ keyA ] = materialsForVariant;\n\n        }\n\n        var cachedMaterial = materialsForVariant[ keyB ];\n\n        if ( cachedMaterial === undefined ) {\n\n          cachedMaterial = result.clone();\n          materialsForVariant[ keyB ] = cachedMaterial;\n\n        }\n\n        result = cachedMaterial;\n\n      }\n\n      result.visible = material.visible;\n      result.wireframe = material.wireframe;\n\n      var side = material.side;\n\n      if ( scope.renderSingleSided && side == DoubleSide ) {\n\n        side = FrontSide;\n\n      }\n\n      if ( scope.renderReverseSided ) {\n\n        if ( side === FrontSide ) side = BackSide;\n        else if ( side === BackSide ) side = FrontSide;\n\n      }\n\n      result.side = side;\n\n      result.clipShadows = material.clipShadows;\n      result.clippingPlanes = material.clippingPlanes;\n\n      result.wireframeLinewidth = material.wireframeLinewidth;\n      result.linewidth = material.linewidth;\n\n      if ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n        result.uniforms.lightPos.value.copy( lightPositionWorld );\n\n      }\n\n      return result;\n\n    }\n\n    function projectObject( object, camera, shadowCamera ) {\n\n      if ( object.visible === false ) return;\n\n      var visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n      if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n        if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n          var material = object.material;\n\n          if ( material.visible === true ) {\n\n            object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n            _renderList.push( object );\n\n          }\n\n        }\n\n      }\n\n      var children = object.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        projectObject( children[ i ], camera, shadowCamera );\n\n      }\n\n    }\n\n  }\n\n  /**\n   * @author bhouston / http://clara.io\n   */\n\n  function Ray( origin, direction ) {\n\n    this.origin = ( origin !== undefined ) ? origin : new Vector3();\n    this.direction = ( direction !== undefined ) ? direction : new Vector3();\n\n  }\n\n  Object.assign( Ray.prototype, {\n\n    set: function ( origin, direction ) {\n\n      this.origin.copy( origin );\n      this.direction.copy( direction );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( ray ) {\n\n      this.origin.copy( ray.origin );\n      this.direction.copy( ray.direction );\n\n      return this;\n\n    },\n\n    at: function ( t, optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n\n      return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n    },\n\n    lookAt: function ( v ) {\n\n      this.direction.copy( v ).sub( this.origin ).normalize();\n\n      return this;\n\n    },\n\n    recast: function () {\n\n      var v1 = new Vector3();\n\n      return function recast( t ) {\n\n        this.origin.copy( this.at( t, v1 ) );\n\n        return this;\n\n      };\n\n    }(),\n\n    closestPointToPoint: function ( point, optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      result.subVectors( point, this.origin );\n      var directionDistance = result.dot( this.direction );\n\n      if ( directionDistance < 0 ) {\n\n        return result.copy( this.origin );\n\n      }\n\n      return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n    },\n\n    distanceToPoint: function ( point ) {\n\n      return Math.sqrt( this.distanceSqToPoint( point ) );\n\n    },\n\n    distanceSqToPoint: function () {\n\n      var v1 = new Vector3();\n\n      return function distanceSqToPoint( point ) {\n\n        var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n        // point behind the ray\n\n        if ( directionDistance < 0 ) {\n\n          return this.origin.distanceToSquared( point );\n\n        }\n\n        v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n        return v1.distanceToSquared( point );\n\n      };\n\n    }(),\n\n    distanceSqToSegment: function () {\n\n      var segCenter = new Vector3();\n      var segDir = new Vector3();\n      var diff = new Vector3();\n\n      return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n        // It returns the min distance between the ray and the segment\n        // defined by v0 and v1\n        // It can also set two optional targets :\n        // - The closest point on the ray\n        // - The closest point on the segment\n\n        segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n        segDir.copy( v1 ).sub( v0 ).normalize();\n        diff.copy( this.origin ).sub( segCenter );\n\n        var segExtent = v0.distanceTo( v1 ) * 0.5;\n        var a01 = - this.direction.dot( segDir );\n        var b0 = diff.dot( this.direction );\n        var b1 = - diff.dot( segDir );\n        var c = diff.lengthSq();\n        var det = Math.abs( 1 - a01 * a01 );\n        var s0, s1, sqrDist, extDet;\n\n        if ( det > 0 ) {\n\n          // The ray and segment are not parallel.\n\n          s0 = a01 * b1 - b0;\n          s1 = a01 * b0 - b1;\n          extDet = segExtent * det;\n\n          if ( s0 >= 0 ) {\n\n            if ( s1 >= - extDet ) {\n\n              if ( s1 <= extDet ) {\n\n                // region 0\n                // Minimum at interior points of ray and segment.\n\n                var invDet = 1 / det;\n                s0 *= invDet;\n                s1 *= invDet;\n                sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n              } else {\n\n                // region 1\n\n                s1 = segExtent;\n                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n              }\n\n            } else {\n\n              // region 5\n\n              s1 = - segExtent;\n              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n            }\n\n          } else {\n\n            if ( s1 <= - extDet ) {\n\n              // region 4\n\n              s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n              s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n            } else if ( s1 <= extDet ) {\n\n              // region 3\n\n              s0 = 0;\n              s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n              sqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n            } else {\n\n              // region 2\n\n              s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n              s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n            }\n\n          }\n\n        } else {\n\n          // Ray and segment are parallel.\n\n          s1 = ( a01 > 0 ) ? - segExtent : segExtent;\n          s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n          sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n        }\n\n        if ( optionalPointOnRay ) {\n\n          optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n        }\n\n        if ( optionalPointOnSegment ) {\n\n          optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n        }\n\n        return sqrDist;\n\n      };\n\n    }(),\n\n    intersectSphere: function () {\n\n      var v1 = new Vector3();\n\n      return function intersectSphere( sphere, optionalTarget ) {\n\n        v1.subVectors( sphere.center, this.origin );\n        var tca = v1.dot( this.direction );\n        var d2 = v1.dot( v1 ) - tca * tca;\n        var radius2 = sphere.radius * sphere.radius;\n\n        if ( d2 > radius2 ) return null;\n\n        var thc = Math.sqrt( radius2 - d2 );\n\n        // t0 = first intersect point - entrance on front of sphere\n        var t0 = tca - thc;\n\n        // t1 = second intersect point - exit point on back of sphere\n        var t1 = tca + thc;\n\n        // test to see if both t0 and t1 are behind the ray - if so, return null\n        if ( t0 < 0 && t1 < 0 ) return null;\n\n        // test to see if t0 is behind the ray:\n        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n        // in order to always return an intersect point that is in front of the ray.\n        if ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n        // else t0 is in front of the ray, so return the first collision point scaled by t0\n        return this.at( t0, optionalTarget );\n\n      };\n\n    }(),\n\n    intersectsSphere: function ( sphere ) {\n\n      return this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n    },\n\n    distanceToPlane: function ( plane ) {\n\n      var denominator = plane.normal.dot( this.direction );\n\n      if ( denominator === 0 ) {\n\n        // line is coplanar, return origin\n        if ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n          return 0;\n\n        }\n\n        // Null is preferable to undefined since undefined means.... it is undefined\n\n        return null;\n\n      }\n\n      var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n      // Return if the ray never intersects the plane\n\n      return t >= 0 ? t :  null;\n\n    },\n\n    intersectPlane: function ( plane, optionalTarget ) {\n\n      var t = this.distanceToPlane( plane );\n\n      if ( t === null ) {\n\n        return null;\n\n      }\n\n      return this.at( t, optionalTarget );\n\n    },\n\n    intersectsPlane: function ( plane ) {\n\n      // check if the ray lies on the plane first\n\n      var distToPoint = plane.distanceToPoint( this.origin );\n\n      if ( distToPoint === 0 ) {\n\n        return true;\n\n      }\n\n      var denominator = plane.normal.dot( this.direction );\n\n      if ( denominator * distToPoint < 0 ) {\n\n        return true;\n\n      }\n\n      // ray origin is behind the plane (and is pointing behind it)\n\n      return false;\n\n    },\n\n    intersectBox: function ( box, optionalTarget ) {\n\n      var tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n      var invdirx = 1 / this.direction.x,\n        invdiry = 1 / this.direction.y,\n        invdirz = 1 / this.direction.z;\n\n      var origin = this.origin;\n\n      if ( invdirx >= 0 ) {\n\n        tmin = ( box.min.x - origin.x ) * invdirx;\n        tmax = ( box.max.x - origin.x ) * invdirx;\n\n      } else {\n\n        tmin = ( box.max.x - origin.x ) * invdirx;\n        tmax = ( box.min.x - origin.x ) * invdirx;\n\n      }\n\n      if ( invdiry >= 0 ) {\n\n        tymin = ( box.min.y - origin.y ) * invdiry;\n        tymax = ( box.max.y - origin.y ) * invdiry;\n\n      } else {\n\n        tymin = ( box.max.y - origin.y ) * invdiry;\n        tymax = ( box.min.y - origin.y ) * invdiry;\n\n      }\n\n      if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n      // These lines also handle the case where tmin or tmax is NaN\n      // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n      if ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n      if ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n      if ( invdirz >= 0 ) {\n\n        tzmin = ( box.min.z - origin.z ) * invdirz;\n        tzmax = ( box.max.z - origin.z ) * invdirz;\n\n      } else {\n\n        tzmin = ( box.max.z - origin.z ) * invdirz;\n        tzmax = ( box.min.z - origin.z ) * invdirz;\n\n      }\n\n      if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n      if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n      if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n      //return point closest to the ray (positive side)\n\n      if ( tmax < 0 ) return null;\n\n      return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n    },\n\n    intersectsBox: ( function () {\n\n      var v = new Vector3();\n\n      return function intersectsBox( box ) {\n\n        return this.intersectBox( box, v ) !== null;\n\n      };\n\n    } )(),\n\n    intersectTriangle: function () {\n\n      // Compute the offset origin, edges, and normal.\n      var diff = new Vector3();\n      var edge1 = new Vector3();\n      var edge2 = new Vector3();\n      var normal = new Vector3();\n\n      return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n        edge1.subVectors( b, a );\n        edge2.subVectors( c, a );\n        normal.crossVectors( edge1, edge2 );\n\n        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n        var DdN = this.direction.dot( normal );\n        var sign;\n\n        if ( DdN > 0 ) {\n\n          if ( backfaceCulling ) return null;\n          sign = 1;\n\n        } else if ( DdN < 0 ) {\n\n          sign = - 1;\n          DdN = - DdN;\n\n        } else {\n\n          return null;\n\n        }\n\n        diff.subVectors( this.origin, a );\n        var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n        // b1 < 0, no intersection\n        if ( DdQxE2 < 0 ) {\n\n          return null;\n\n        }\n\n        var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n        // b2 < 0, no intersection\n        if ( DdE1xQ < 0 ) {\n\n          return null;\n\n        }\n\n        // b1+b2 > 1, no intersection\n        if ( DdQxE2 + DdE1xQ > DdN ) {\n\n          return null;\n\n        }\n\n        // Line intersects triangle, check if ray does.\n        var QdN = - sign * diff.dot( normal );\n\n        // t < 0, no intersection\n        if ( QdN < 0 ) {\n\n          return null;\n\n        }\n\n        // Ray intersects triangle.\n        return this.at( QdN / DdN, optionalTarget );\n\n      };\n\n    }(),\n\n    applyMatrix4: function ( matrix4 ) {\n\n      this.direction.add( this.origin ).applyMatrix4( matrix4 );\n      this.origin.applyMatrix4( matrix4 );\n      this.direction.sub( this.origin );\n      this.direction.normalize();\n\n      return this;\n\n    },\n\n    equals: function ( ray ) {\n\n      return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author bhouston / http://clara.io\n   */\n\n  function Euler( x, y, z, order ) {\n\n    this._x = x || 0;\n    this._y = y || 0;\n    this._z = z || 0;\n    this._order = order || Euler.DefaultOrder;\n\n  }\n\n  Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\n  Euler.DefaultOrder = 'XYZ';\n\n  Object.defineProperties( Euler.prototype, {\n\n    \"x\" : {\n\n      get: function () {\n\n        return this._x;\n\n      },\n\n      set: function ( value ) {\n\n        this._x = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"y\" : {\n\n      get: function () {\n\n        return this._y;\n\n      },\n\n      set: function ( value ) {\n\n        this._y = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"z\" : {\n\n      get: function () {\n\n        return this._z;\n\n      },\n\n      set: function ( value ) {\n\n        this._z = value;\n        this.onChangeCallback();\n\n      }\n\n    },\n\n    \"order\" : {\n\n      get: function () {\n\n        return this._order;\n\n      },\n\n      set: function ( value ) {\n\n        this._order = value;\n        this.onChangeCallback();\n\n      }\n\n    }\n\n  });\n\n  Object.assign( Euler.prototype, {\n\n    isEuler: true,\n\n    set: function ( x, y, z, order ) {\n\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      this._order = order || this._order;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this._x, this._y, this._z, this._order );\n\n    },\n\n    copy: function ( euler ) {\n\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromRotationMatrix: function ( m, order, update ) {\n\n      var clamp = _Math.clamp;\n\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n      var te = m.elements;\n      var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n      var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n      var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n      order = order || this._order;\n\n      if ( order === 'XYZ' ) {\n\n        this._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n        if ( Math.abs( m13 ) < 0.99999 ) {\n\n          this._x = Math.atan2( - m23, m33 );\n          this._z = Math.atan2( - m12, m11 );\n\n        } else {\n\n          this._x = Math.atan2( m32, m22 );\n          this._z = 0;\n\n        }\n\n      } else if ( order === 'YXZ' ) {\n\n        this._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n        if ( Math.abs( m23 ) < 0.99999 ) {\n\n          this._y = Math.atan2( m13, m33 );\n          this._z = Math.atan2( m21, m22 );\n\n        } else {\n\n          this._y = Math.atan2( - m31, m11 );\n          this._z = 0;\n\n        }\n\n      } else if ( order === 'ZXY' ) {\n\n        this._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n        if ( Math.abs( m32 ) < 0.99999 ) {\n\n          this._y = Math.atan2( - m31, m33 );\n          this._z = Math.atan2( - m12, m22 );\n\n        } else {\n\n          this._y = 0;\n          this._z = Math.atan2( m21, m11 );\n\n        }\n\n      } else if ( order === 'ZYX' ) {\n\n        this._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n        if ( Math.abs( m31 ) < 0.99999 ) {\n\n          this._x = Math.atan2( m32, m33 );\n          this._z = Math.atan2( m21, m11 );\n\n        } else {\n\n          this._x = 0;\n          this._z = Math.atan2( - m12, m22 );\n\n        }\n\n      } else if ( order === 'YZX' ) {\n\n        this._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n        if ( Math.abs( m21 ) < 0.99999 ) {\n\n          this._x = Math.atan2( - m23, m22 );\n          this._y = Math.atan2( - m31, m11 );\n\n        } else {\n\n          this._x = 0;\n          this._y = Math.atan2( m13, m33 );\n\n        }\n\n      } else if ( order === 'XZY' ) {\n\n        this._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n        if ( Math.abs( m12 ) < 0.99999 ) {\n\n          this._x = Math.atan2( m32, m22 );\n          this._y = Math.atan2( m13, m11 );\n\n        } else {\n\n          this._x = Math.atan2( - m23, m33 );\n          this._y = 0;\n\n        }\n\n      } else {\n\n        console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n      }\n\n      this._order = order;\n\n      if ( update !== false ) this.onChangeCallback();\n\n      return this;\n\n    },\n\n    setFromQuaternion: function () {\n\n      var matrix = new Matrix4();\n\n      return function setFromQuaternion( q, order, update ) {\n\n        matrix.makeRotationFromQuaternion( q );\n\n        return this.setFromRotationMatrix( matrix, order, update );\n\n      };\n\n    }(),\n\n    setFromVector3: function ( v, order ) {\n\n      return this.set( v.x, v.y, v.z, order || this._order );\n\n    },\n\n    reorder: function () {\n\n      // WARNING: this discards revolution information -bhouston\n\n      var q = new Quaternion();\n\n      return function reorder( newOrder ) {\n\n        q.setFromEuler( this );\n\n        return this.setFromQuaternion( q, newOrder );\n\n      };\n\n    }(),\n\n    equals: function ( euler ) {\n\n      return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n    },\n\n    fromArray: function ( array ) {\n\n      this._x = array[ 0 ];\n      this._y = array[ 1 ];\n      this._z = array[ 2 ];\n      if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n      this.onChangeCallback();\n\n      return this;\n\n    },\n\n    toArray: function ( array, offset ) {\n\n      if ( array === undefined ) array = [];\n      if ( offset === undefined ) offset = 0;\n\n      array[ offset ] = this._x;\n      array[ offset + 1 ] = this._y;\n      array[ offset + 2 ] = this._z;\n      array[ offset + 3 ] = this._order;\n\n      return array;\n\n    },\n\n    toVector3: function ( optionalResult ) {\n\n      if ( optionalResult ) {\n\n        return optionalResult.set( this._x, this._y, this._z );\n\n      } else {\n\n        return new Vector3( this._x, this._y, this._z );\n\n      }\n\n    },\n\n    onChange: function ( callback ) {\n\n      this.onChangeCallback = callback;\n\n      return this;\n\n    },\n\n    onChangeCallback: function () {}\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Layers() {\n\n    this.mask = 1;\n\n  }\n\n  Object.assign( Layers.prototype, {\n\n    set: function ( channel ) {\n\n      this.mask = 1 << channel;\n\n    },\n\n    enable: function ( channel ) {\n\n      this.mask |= 1 << channel;\n\n    },\n\n    toggle: function ( channel ) {\n\n      this.mask ^= 1 << channel;\n\n    },\n\n    disable: function ( channel ) {\n\n      this.mask &= ~ ( 1 << channel );\n\n    },\n\n    test: function ( layers ) {\n\n      return ( this.mask & layers.mask ) !== 0;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author WestLangley / http://github.com/WestLangley\n   * @author elephantatwork / www.elephantatwork.ch\n   */\n\n  var object3DId = 0;\n\n  function Object3D() {\n\n    Object.defineProperty( this, 'id', { value: object3DId ++ } );\n\n    this.uuid = _Math.generateUUID();\n\n    this.name = '';\n    this.type = 'Object3D';\n\n    this.parent = null;\n    this.children = [];\n\n    this.up = Object3D.DefaultUp.clone();\n\n    var position = new Vector3();\n    var rotation = new Euler();\n    var quaternion = new Quaternion();\n    var scale = new Vector3( 1, 1, 1 );\n\n    function onRotationChange() {\n\n      quaternion.setFromEuler( rotation, false );\n\n    }\n\n    function onQuaternionChange() {\n\n      rotation.setFromQuaternion( quaternion, undefined, false );\n\n    }\n\n    rotation.onChange( onRotationChange );\n    quaternion.onChange( onQuaternionChange );\n\n    Object.defineProperties( this, {\n      position: {\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    } );\n\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n\n    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = false;\n\n    this.layers = new Layers();\n    this.visible = true;\n\n    this.castShadow = false;\n    this.receiveShadow = false;\n\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n\n    this.userData = {};\n\n    this.onBeforeRender = function () {};\n    this.onAfterRender = function () {};\n\n  }\n\n  Object3D.DefaultUp = new Vector3( 0, 1, 0 );\n  Object3D.DefaultMatrixAutoUpdate = true;\n\n  Object.assign( Object3D.prototype, EventDispatcher.prototype, {\n\n    isObject3D: true,\n\n    applyMatrix: function ( matrix ) {\n\n      this.matrix.multiplyMatrices( matrix, this.matrix );\n\n      this.matrix.decompose( this.position, this.quaternion, this.scale );\n\n    },\n\n    setRotationFromAxisAngle: function ( axis, angle ) {\n\n      // assumes axis is normalized\n\n      this.quaternion.setFromAxisAngle( axis, angle );\n\n    },\n\n    setRotationFromEuler: function ( euler ) {\n\n      this.quaternion.setFromEuler( euler, true );\n\n    },\n\n    setRotationFromMatrix: function ( m ) {\n\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n      this.quaternion.setFromRotationMatrix( m );\n\n    },\n\n    setRotationFromQuaternion: function ( q ) {\n\n      // assumes q is normalized\n\n      this.quaternion.copy( q );\n\n    },\n\n    rotateOnAxis: function () {\n\n      // rotate object on axis in object space\n      // axis is assumed to be normalized\n\n      var q1 = new Quaternion();\n\n      return function rotateOnAxis( axis, angle ) {\n\n        q1.setFromAxisAngle( axis, angle );\n\n        this.quaternion.multiply( q1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    rotateX: function () {\n\n      var v1 = new Vector3( 1, 0, 0 );\n\n      return function rotateX( angle ) {\n\n        return this.rotateOnAxis( v1, angle );\n\n      };\n\n    }(),\n\n    rotateY: function () {\n\n      var v1 = new Vector3( 0, 1, 0 );\n\n      return function rotateY( angle ) {\n\n        return this.rotateOnAxis( v1, angle );\n\n      };\n\n    }(),\n\n    rotateZ: function () {\n\n      var v1 = new Vector3( 0, 0, 1 );\n\n      return function rotateZ( angle ) {\n\n        return this.rotateOnAxis( v1, angle );\n\n      };\n\n    }(),\n\n    translateOnAxis: function () {\n\n      // translate object by distance along axis in object space\n      // axis is assumed to be normalized\n\n      var v1 = new Vector3();\n\n      return function translateOnAxis( axis, distance ) {\n\n        v1.copy( axis ).applyQuaternion( this.quaternion );\n\n        this.position.add( v1.multiplyScalar( distance ) );\n\n        return this;\n\n      };\n\n    }(),\n\n    translateX: function () {\n\n      var v1 = new Vector3( 1, 0, 0 );\n\n      return function translateX( distance ) {\n\n        return this.translateOnAxis( v1, distance );\n\n      };\n\n    }(),\n\n    translateY: function () {\n\n      var v1 = new Vector3( 0, 1, 0 );\n\n      return function translateY( distance ) {\n\n        return this.translateOnAxis( v1, distance );\n\n      };\n\n    }(),\n\n    translateZ: function () {\n\n      var v1 = new Vector3( 0, 0, 1 );\n\n      return function translateZ( distance ) {\n\n        return this.translateOnAxis( v1, distance );\n\n      };\n\n    }(),\n\n    localToWorld: function ( vector ) {\n\n      return vector.applyMatrix4( this.matrixWorld );\n\n    },\n\n    worldToLocal: function () {\n\n      var m1 = new Matrix4();\n\n      return function worldToLocal( vector ) {\n\n        return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n      };\n\n    }(),\n\n    lookAt: function () {\n\n      // This routine does not support objects with rotated and/or translated parent(s)\n\n      var m1 = new Matrix4();\n\n      return function lookAt( vector ) {\n\n        m1.lookAt( vector, this.position, this.up );\n\n        this.quaternion.setFromRotationMatrix( m1 );\n\n      };\n\n    }(),\n\n    add: function ( object ) {\n\n      if ( arguments.length > 1 ) {\n\n        for ( var i = 0; i < arguments.length; i ++ ) {\n\n          this.add( arguments[ i ] );\n\n        }\n\n        return this;\n\n      }\n\n      if ( object === this ) {\n\n        console.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n        return this;\n\n      }\n\n      if ( ( object && object.isObject3D ) ) {\n\n        if ( object.parent !== null ) {\n\n          object.parent.remove( object );\n\n        }\n\n        object.parent = this;\n        object.dispatchEvent( { type: 'added' } );\n\n        this.children.push( object );\n\n      } else {\n\n        console.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n      }\n\n      return this;\n\n    },\n\n    remove: function ( object ) {\n\n      if ( arguments.length > 1 ) {\n\n        for ( var i = 0; i < arguments.length; i ++ ) {\n\n          this.remove( arguments[ i ] );\n\n        }\n\n      }\n\n      var index = this.children.indexOf( object );\n\n      if ( index !== - 1 ) {\n\n        object.parent = null;\n\n        object.dispatchEvent( { type: 'removed' } );\n\n        this.children.splice( index, 1 );\n\n      }\n\n    },\n\n    getObjectById: function ( id ) {\n\n      return this.getObjectByProperty( 'id', id );\n\n    },\n\n    getObjectByName: function ( name ) {\n\n      return this.getObjectByProperty( 'name', name );\n\n    },\n\n    getObjectByProperty: function ( name, value ) {\n\n      if ( this[ name ] === value ) return this;\n\n      for ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n        var child = this.children[ i ];\n        var object = child.getObjectByProperty( name, value );\n\n        if ( object !== undefined ) {\n\n          return object;\n\n        }\n\n      }\n\n      return undefined;\n\n    },\n\n    getWorldPosition: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n\n      this.updateMatrixWorld( true );\n\n      return result.setFromMatrixPosition( this.matrixWorld );\n\n    },\n\n    getWorldQuaternion: function () {\n\n      var position = new Vector3();\n      var scale = new Vector3();\n\n      return function getWorldQuaternion( optionalTarget ) {\n\n        var result = optionalTarget || new Quaternion();\n\n        this.updateMatrixWorld( true );\n\n        this.matrixWorld.decompose( position, result, scale );\n\n        return result;\n\n      };\n\n    }(),\n\n    getWorldRotation: function () {\n\n      var quaternion = new Quaternion();\n\n      return function getWorldRotation( optionalTarget ) {\n\n        var result = optionalTarget || new Euler();\n\n        this.getWorldQuaternion( quaternion );\n\n        return result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n      };\n\n    }(),\n\n    getWorldScale: function () {\n\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n\n      return function getWorldScale( optionalTarget ) {\n\n        var result = optionalTarget || new Vector3();\n\n        this.updateMatrixWorld( true );\n\n        this.matrixWorld.decompose( position, quaternion, result );\n\n        return result;\n\n      };\n\n    }(),\n\n    getWorldDirection: function () {\n\n      var quaternion = new Quaternion();\n\n      return function getWorldDirection( optionalTarget ) {\n\n        var result = optionalTarget || new Vector3();\n\n        this.getWorldQuaternion( quaternion );\n\n        return result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n      };\n\n    }(),\n\n    raycast: function () {},\n\n    traverse: function ( callback ) {\n\n      callback( this );\n\n      var children = this.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        children[ i ].traverse( callback );\n\n      }\n\n    },\n\n    traverseVisible: function ( callback ) {\n\n      if ( this.visible === false ) return;\n\n      callback( this );\n\n      var children = this.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        children[ i ].traverseVisible( callback );\n\n      }\n\n    },\n\n    traverseAncestors: function ( callback ) {\n\n      var parent = this.parent;\n\n      if ( parent !== null ) {\n\n        callback( parent );\n\n        parent.traverseAncestors( callback );\n\n      }\n\n    },\n\n    updateMatrix: function () {\n\n      this.matrix.compose( this.position, this.quaternion, this.scale );\n\n      this.matrixWorldNeedsUpdate = true;\n\n    },\n\n    updateMatrixWorld: function ( force ) {\n\n      if ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n      if ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n        if ( this.parent === null ) {\n\n          this.matrixWorld.copy( this.matrix );\n\n        } else {\n\n          this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n        }\n\n        this.matrixWorldNeedsUpdate = false;\n\n        force = true;\n\n      }\n\n      // update children\n\n      var children = this.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        children[ i ].updateMatrixWorld( force );\n\n      }\n\n    },\n\n    toJSON: function ( meta ) {\n\n      // meta is '' when called from JSON.stringify\n      var isRootObject = ( meta === undefined || meta === '' );\n\n      var output = {};\n\n      // meta is a hash used to collect geometries, materials.\n      // not providing it implies that this is the root object\n      // being serialized.\n      if ( isRootObject ) {\n\n        // initialize meta obj\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {}\n        };\n\n        output.metadata = {\n          version: 4.4,\n          type: 'Object',\n          generator: 'Object3D.toJSON'\n        };\n\n      }\n\n      // standard Object3D serialization\n\n      var object = {};\n\n      object.uuid = this.uuid;\n      object.type = this.type;\n\n      if ( this.name !== '' ) object.name = this.name;\n      if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n      if ( this.castShadow === true ) object.castShadow = true;\n      if ( this.receiveShadow === true ) object.receiveShadow = true;\n      if ( this.visible === false ) object.visible = false;\n\n      object.matrix = this.matrix.toArray();\n\n      //\n\n      if ( this.geometry !== undefined ) {\n\n        if ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n          meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n        }\n\n        object.geometry = this.geometry.uuid;\n\n      }\n\n      if ( this.material !== undefined ) {\n\n        if ( meta.materials[ this.material.uuid ] === undefined ) {\n\n          meta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n        }\n\n        object.material = this.material.uuid;\n\n      }\n\n      //\n\n      if ( this.children.length > 0 ) {\n\n        object.children = [];\n\n        for ( var i = 0; i < this.children.length; i ++ ) {\n\n          object.children.push( this.children[ i ].toJSON( meta ).object );\n\n        }\n\n      }\n\n      if ( isRootObject ) {\n\n        var geometries = extractFromCache( meta.geometries );\n        var materials = extractFromCache( meta.materials );\n        var textures = extractFromCache( meta.textures );\n        var images = extractFromCache( meta.images );\n\n        if ( geometries.length > 0 ) output.geometries = geometries;\n        if ( materials.length > 0 ) output.materials = materials;\n        if ( textures.length > 0 ) output.textures = textures;\n        if ( images.length > 0 ) output.images = images;\n\n      }\n\n      output.object = object;\n\n      return output;\n\n      // extract data from the cache hash\n      // remove metadata on each item\n      // and return as array\n      function extractFromCache( cache ) {\n\n        var values = [];\n        for ( var key in cache ) {\n\n          var data = cache[ key ];\n          delete data.metadata;\n          values.push( data );\n\n        }\n        return values;\n\n      }\n\n    },\n\n    clone: function ( recursive ) {\n\n      return new this.constructor().copy( this, recursive );\n\n    },\n\n    copy: function ( source, recursive ) {\n\n      if ( recursive === undefined ) recursive = true;\n\n      this.name = source.name;\n\n      this.up.copy( source.up );\n\n      this.position.copy( source.position );\n      this.quaternion.copy( source.quaternion );\n      this.scale.copy( source.scale );\n\n      this.matrix.copy( source.matrix );\n      this.matrixWorld.copy( source.matrixWorld );\n\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n\n      this.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n      if ( recursive === true ) {\n\n        for ( var i = 0; i < source.children.length; i ++ ) {\n\n          var child = source.children[ i ];\n          this.add( child.clone() );\n\n        }\n\n      }\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author bhouston / http://clara.io\n   */\n\n  function Line3( start, end ) {\n\n    this.start = ( start !== undefined ) ? start : new Vector3();\n    this.end = ( end !== undefined ) ? end : new Vector3();\n\n  }\n\n  Object.assign( Line3.prototype, {\n\n    set: function ( start, end ) {\n\n      this.start.copy( start );\n      this.end.copy( end );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( line ) {\n\n      this.start.copy( line.start );\n      this.end.copy( line.end );\n\n      return this;\n\n    },\n\n    getCenter: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n    },\n\n    delta: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return result.subVectors( this.end, this.start );\n\n    },\n\n    distanceSq: function () {\n\n      return this.start.distanceToSquared( this.end );\n\n    },\n\n    distance: function () {\n\n      return this.start.distanceTo( this.end );\n\n    },\n\n    at: function ( t, optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n\n      return this.delta( result ).multiplyScalar( t ).add( this.start );\n\n    },\n\n    closestPointToPointParameter: function () {\n\n      var startP = new Vector3();\n      var startEnd = new Vector3();\n\n      return function closestPointToPointParameter( point, clampToLine ) {\n\n        startP.subVectors( point, this.start );\n        startEnd.subVectors( this.end, this.start );\n\n        var startEnd2 = startEnd.dot( startEnd );\n        var startEnd_startP = startEnd.dot( startP );\n\n        var t = startEnd_startP / startEnd2;\n\n        if ( clampToLine ) {\n\n          t = _Math.clamp( t, 0, 1 );\n\n        }\n\n        return t;\n\n      };\n\n    }(),\n\n    closestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n      var t = this.closestPointToPointParameter( point, clampToLine );\n\n      var result = optionalTarget || new Vector3();\n\n      return this.delta( result ).multiplyScalar( t ).add( this.start );\n\n    },\n\n    applyMatrix4: function ( matrix ) {\n\n      this.start.applyMatrix4( matrix );\n      this.end.applyMatrix4( matrix );\n\n      return this;\n\n    },\n\n    equals: function ( line ) {\n\n      return line.start.equals( this.start ) && line.end.equals( this.end );\n\n    }\n\n  } );\n\n  /**\n   * @author bhouston / http://clara.io\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Triangle( a, b, c ) {\n\n    this.a = ( a !== undefined ) ? a : new Vector3();\n    this.b = ( b !== undefined ) ? b : new Vector3();\n    this.c = ( c !== undefined ) ? c : new Vector3();\n\n  }\n\n  Object.assign( Triangle, {\n\n    normal: function () {\n\n      var v0 = new Vector3();\n\n      return function normal( a, b, c, optionalTarget ) {\n\n        var result = optionalTarget || new Vector3();\n\n        result.subVectors( c, b );\n        v0.subVectors( a, b );\n        result.cross( v0 );\n\n        var resultLengthSq = result.lengthSq();\n        if ( resultLengthSq > 0 ) {\n\n          return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n        }\n\n        return result.set( 0, 0, 0 );\n\n      };\n\n    }(),\n\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    barycoordFromPoint: function () {\n\n      var v0 = new Vector3();\n      var v1 = new Vector3();\n      var v2 = new Vector3();\n\n      return function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n        v0.subVectors( c, a );\n        v1.subVectors( b, a );\n        v2.subVectors( point, a );\n\n        var dot00 = v0.dot( v0 );\n        var dot01 = v0.dot( v1 );\n        var dot02 = v0.dot( v2 );\n        var dot11 = v1.dot( v1 );\n        var dot12 = v1.dot( v2 );\n\n        var denom = ( dot00 * dot11 - dot01 * dot01 );\n\n        var result = optionalTarget || new Vector3();\n\n        // collinear or singular triangle\n        if ( denom === 0 ) {\n\n          // arbitrary location outside of triangle?\n          // not sure if this is the best idea, maybe should be returning undefined\n          return result.set( - 2, - 1, - 1 );\n\n        }\n\n        var invDenom = 1 / denom;\n        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n        // barycentric coordinates must always sum to 1\n        return result.set( 1 - u - v, v, u );\n\n      };\n\n    }(),\n\n    containsPoint: function () {\n\n      var v1 = new Vector3();\n\n      return function containsPoint( point, a, b, c ) {\n\n        var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n        return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n      };\n\n    }()\n\n  } );\n\n  Object.assign( Triangle.prototype, {\n\n    set: function ( a, b, c ) {\n\n      this.a.copy( a );\n      this.b.copy( b );\n      this.c.copy( c );\n\n      return this;\n\n    },\n\n    setFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n      this.a.copy( points[ i0 ] );\n      this.b.copy( points[ i1 ] );\n      this.c.copy( points[ i2 ] );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( triangle ) {\n\n      this.a.copy( triangle.a );\n      this.b.copy( triangle.b );\n      this.c.copy( triangle.c );\n\n      return this;\n\n    },\n\n    area: function () {\n\n      var v0 = new Vector3();\n      var v1 = new Vector3();\n\n      return function area() {\n\n        v0.subVectors( this.c, this.b );\n        v1.subVectors( this.a, this.b );\n\n        return v0.cross( v1 ).length() * 0.5;\n\n      };\n\n    }(),\n\n    midpoint: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n      return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n    },\n\n    normal: function ( optionalTarget ) {\n\n      return Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n    },\n\n    plane: function ( optionalTarget ) {\n\n      var result = optionalTarget || new Plane();\n\n      return result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n    },\n\n    barycoordFromPoint: function ( point, optionalTarget ) {\n\n      return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n    },\n\n    containsPoint: function ( point ) {\n\n      return Triangle.containsPoint( point, this.a, this.b, this.c );\n\n    },\n\n    closestPointToPoint: function () {\n\n      var plane = new Plane();\n      var edgeList = [ new Line3(), new Line3(), new Line3() ];\n      var projectedPoint = new Vector3();\n      var closestPoint = new Vector3();\n\n      return function closestPointToPoint( point, optionalTarget ) {\n\n        var result = optionalTarget || new Vector3();\n        var minDistance = Infinity;\n\n        // project the point onto the plane of the triangle\n\n        plane.setFromCoplanarPoints( this.a, this.b, this.c );\n        plane.projectPoint( point, projectedPoint );\n\n        // check if the projection lies within the triangle\n\n        if( this.containsPoint( projectedPoint ) === true ) {\n\n          // if so, this is the closest point\n\n          result.copy( projectedPoint );\n\n        } else {\n\n          // if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n          edgeList[ 0 ].set( this.a, this.b );\n          edgeList[ 1 ].set( this.b, this.c );\n          edgeList[ 2 ].set( this.c, this.a );\n\n          for( var i = 0; i < edgeList.length; i ++ ) {\n\n            edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n            var distance = projectedPoint.distanceToSquared( closestPoint );\n\n            if( distance < minDistance ) {\n\n              minDistance = distance;\n\n              result.copy( closestPoint );\n\n            }\n\n          }\n\n        }\n\n        return result;\n\n      };\n\n    }(),\n\n    equals: function ( triangle ) {\n\n      return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Face3( a, b, c, normal, color, materialIndex ) {\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n\n    this.normal = (normal && normal.isVector3) ? normal : new Vector3();\n    this.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n    this.color = (color && color.isColor) ? color : new Color();\n    this.vertexColors = Array.isArray( color ) ? color : [];\n\n    this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n  }\n\n  Object.assign( Face3.prototype, {\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      this.a = source.a;\n      this.b = source.b;\n      this.c = source.c;\n\n      this.normal.copy( source.normal );\n      this.color.copy( source.color );\n\n      this.materialIndex = source.materialIndex;\n\n      for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n        this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n      }\n\n      for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n        this.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n      }\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  lightMap: new THREE.Texture( <Image> ),\n   *  lightMapIntensity: <float>\n   *\n   *  aoMap: new THREE.Texture( <Image> ),\n   *  aoMapIntensity: <float>\n   *\n   *  specularMap: new THREE.Texture( <Image> ),\n   *\n   *  alphaMap: new THREE.Texture( <Image> ),\n   *\n   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n   *  combine: THREE.Multiply,\n   *  reflectivity: <float>,\n   *  refractionRatio: <float>,\n   *\n   *  shading: THREE.SmoothShading,\n   *  depthTest: <bool>,\n   *  depthWrite: <bool>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>,\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>\n   * }\n   */\n\n  function MeshBasicMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'MeshBasicMaterial';\n\n    this.color = new Color( 0xffffff ); // emissive\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.skinning = false;\n    this.morphTargets = false;\n\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshBasicMaterial.prototype = Object.create( Material.prototype );\n  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\n\n  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n  MeshBasicMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function BufferAttribute( array, itemSize, normalized ) {\n\n    if ( Array.isArray( array ) ) {\n\n      throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n    }\n\n    this.uuid = _Math.generateUUID();\n\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== undefined ? array.length / itemSize : 0;\n    this.normalized = normalized === true;\n\n    this.dynamic = false;\n    this.updateRange = { offset: 0, count: - 1 };\n\n    this.onUploadCallback = function () {};\n\n    this.version = 0;\n\n  }\n\n  Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\n\n    set: function ( value ) {\n\n      if ( value === true ) this.version ++;\n\n    }\n\n  } );\n\n  Object.assign( BufferAttribute.prototype, {\n\n    isBufferAttribute: true,\n\n    setArray: function ( array ) {\n\n      if ( Array.isArray( array ) ) {\n\n        throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n      }\n\n      this.count = array !== undefined ? array.length / this.itemSize : 0;\n      this.array = array;\n\n    },\n\n    setDynamic: function ( value ) {\n\n      this.dynamic = value;\n\n      return this;\n\n    },\n\n    copy: function ( source ) {\n\n      this.array = new source.array.constructor( source.array );\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n\n      this.dynamic = source.dynamic;\n\n      return this;\n\n    },\n\n    copyAt: function ( index1, attribute, index2 ) {\n\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n\n      for ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n        this.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n      }\n\n      return this;\n\n    },\n\n    copyArray: function ( array ) {\n\n      this.array.set( array );\n\n      return this;\n\n    },\n\n    copyColorsArray: function ( colors ) {\n\n      var array = this.array, offset = 0;\n\n      for ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n        var color = colors[ i ];\n\n        if ( color === undefined ) {\n\n          console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n          color = new Color();\n\n        }\n\n        array[ offset ++ ] = color.r;\n        array[ offset ++ ] = color.g;\n        array[ offset ++ ] = color.b;\n\n      }\n\n      return this;\n\n    },\n\n    copyIndicesArray: function ( indices ) {\n\n      var array = this.array, offset = 0;\n\n      for ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n        var index = indices[ i ];\n\n        array[ offset ++ ] = index.a;\n        array[ offset ++ ] = index.b;\n        array[ offset ++ ] = index.c;\n\n      }\n\n      return this;\n\n    },\n\n    copyVector2sArray: function ( vectors ) {\n\n      var array = this.array, offset = 0;\n\n      for ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n        var vector = vectors[ i ];\n\n        if ( vector === undefined ) {\n\n          console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n          vector = new Vector2();\n\n        }\n\n        array[ offset ++ ] = vector.x;\n        array[ offset ++ ] = vector.y;\n\n      }\n\n      return this;\n\n    },\n\n    copyVector3sArray: function ( vectors ) {\n\n      var array = this.array, offset = 0;\n\n      for ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n        var vector = vectors[ i ];\n\n        if ( vector === undefined ) {\n\n          console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n          vector = new Vector3();\n\n        }\n\n        array[ offset ++ ] = vector.x;\n        array[ offset ++ ] = vector.y;\n        array[ offset ++ ] = vector.z;\n\n      }\n\n      return this;\n\n    },\n\n    copyVector4sArray: function ( vectors ) {\n\n      var array = this.array, offset = 0;\n\n      for ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n        var vector = vectors[ i ];\n\n        if ( vector === undefined ) {\n\n          console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n          vector = new Vector4();\n\n        }\n\n        array[ offset ++ ] = vector.x;\n        array[ offset ++ ] = vector.y;\n        array[ offset ++ ] = vector.z;\n        array[ offset ++ ] = vector.w;\n\n      }\n\n      return this;\n\n    },\n\n    set: function ( value, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.array.set( value, offset );\n\n      return this;\n\n    },\n\n    getX: function ( index ) {\n\n      return this.array[ index * this.itemSize ];\n\n    },\n\n    setX: function ( index, x ) {\n\n      this.array[ index * this.itemSize ] = x;\n\n      return this;\n\n    },\n\n    getY: function ( index ) {\n\n      return this.array[ index * this.itemSize + 1 ];\n\n    },\n\n    setY: function ( index, y ) {\n\n      this.array[ index * this.itemSize + 1 ] = y;\n\n      return this;\n\n    },\n\n    getZ: function ( index ) {\n\n      return this.array[ index * this.itemSize + 2 ];\n\n    },\n\n    setZ: function ( index, z ) {\n\n      this.array[ index * this.itemSize + 2 ] = z;\n\n      return this;\n\n    },\n\n    getW: function ( index ) {\n\n      return this.array[ index * this.itemSize + 3 ];\n\n    },\n\n    setW: function ( index, w ) {\n\n      this.array[ index * this.itemSize + 3 ] = w;\n\n      return this;\n\n    },\n\n    setXY: function ( index, x, y ) {\n\n      index *= this.itemSize;\n\n      this.array[ index + 0 ] = x;\n      this.array[ index + 1 ] = y;\n\n      return this;\n\n    },\n\n    setXYZ: function ( index, x, y, z ) {\n\n      index *= this.itemSize;\n\n      this.array[ index + 0 ] = x;\n      this.array[ index + 1 ] = y;\n      this.array[ index + 2 ] = z;\n\n      return this;\n\n    },\n\n    setXYZW: function ( index, x, y, z, w ) {\n\n      index *= this.itemSize;\n\n      this.array[ index + 0 ] = x;\n      this.array[ index + 1 ] = y;\n      this.array[ index + 2 ] = z;\n      this.array[ index + 3 ] = w;\n\n      return this;\n\n    },\n\n    onUpload: function ( callback ) {\n\n      this.onUploadCallback = callback;\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor( this.array, this.itemSize ).copy( this );\n\n    }\n\n  } );\n\n  //\n\n  function Int8BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Int8Array( array ), itemSize );\n\n  }\n\n  Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;\n\n\n  function Uint8BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Uint8Array( array ), itemSize );\n\n  }\n\n  Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\n\n\n  function Uint8ClampedBufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );\n\n  }\n\n  Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\n\n\n  function Int16BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Int16Array( array ), itemSize );\n\n  }\n\n  Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;\n\n\n  function Uint16BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Uint16Array( array ), itemSize );\n\n  }\n\n  Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\n\n\n  function Int32BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Int32Array( array ), itemSize );\n\n  }\n\n  Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;\n\n\n  function Uint32BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Uint32Array( array ), itemSize );\n\n  }\n\n  Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\n\n\n  function Float32BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Float32Array( array ), itemSize );\n\n  }\n\n  Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;\n\n\n  function Float64BufferAttribute( array, itemSize ) {\n\n    BufferAttribute.call( this, new Float64Array( array ), itemSize );\n\n  }\n\n  Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function DirectGeometry() {\n\n    this.indices = [];\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n\n    this.groups = [];\n\n    this.morphTargets = {};\n\n    this.skinWeights = [];\n    this.skinIndices = [];\n\n    // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n\n  }\n\n  Object.assign( DirectGeometry.prototype, {\n\n    computeGroups: function ( geometry ) {\n\n      var group;\n      var groups = [];\n      var materialIndex = undefined;\n\n      var faces = geometry.faces;\n\n      for ( var i = 0; i < faces.length; i ++ ) {\n\n        var face = faces[ i ];\n\n        // materials\n\n        if ( face.materialIndex !== materialIndex ) {\n\n          materialIndex = face.materialIndex;\n\n          if ( group !== undefined ) {\n\n            group.count = ( i * 3 ) - group.start;\n            groups.push( group );\n\n          }\n\n          group = {\n            start: i * 3,\n            materialIndex: materialIndex\n          };\n\n        }\n\n      }\n\n      if ( group !== undefined ) {\n\n        group.count = ( i * 3 ) - group.start;\n        groups.push( group );\n\n      }\n\n      this.groups = groups;\n\n    },\n\n    fromGeometry: function ( geometry ) {\n\n      var faces = geometry.faces;\n      var vertices = geometry.vertices;\n      var faceVertexUvs = geometry.faceVertexUvs;\n\n      var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n      var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n      // morphs\n\n      var morphTargets = geometry.morphTargets;\n      var morphTargetsLength = morphTargets.length;\n\n      var morphTargetsPosition;\n\n      if ( morphTargetsLength > 0 ) {\n\n        morphTargetsPosition = [];\n\n        for ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n          morphTargetsPosition[ i ] = [];\n\n        }\n\n        this.morphTargets.position = morphTargetsPosition;\n\n      }\n\n      var morphNormals = geometry.morphNormals;\n      var morphNormalsLength = morphNormals.length;\n\n      var morphTargetsNormal;\n\n      if ( morphNormalsLength > 0 ) {\n\n        morphTargetsNormal = [];\n\n        for ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n          morphTargetsNormal[ i ] = [];\n\n        }\n\n        this.morphTargets.normal = morphTargetsNormal;\n\n      }\n\n      // skins\n\n      var skinIndices = geometry.skinIndices;\n      var skinWeights = geometry.skinWeights;\n\n      var hasSkinIndices = skinIndices.length === vertices.length;\n      var hasSkinWeights = skinWeights.length === vertices.length;\n\n      //\n\n      for ( var i = 0; i < faces.length; i ++ ) {\n\n        var face = faces[ i ];\n\n        this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n        var vertexNormals = face.vertexNormals;\n\n        if ( vertexNormals.length === 3 ) {\n\n          this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n        } else {\n\n          var normal = face.normal;\n\n          this.normals.push( normal, normal, normal );\n\n        }\n\n        var vertexColors = face.vertexColors;\n\n        if ( vertexColors.length === 3 ) {\n\n          this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n        } else {\n\n          var color = face.color;\n\n          this.colors.push( color, color, color );\n\n        }\n\n        if ( hasFaceVertexUv === true ) {\n\n          var vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n          if ( vertexUvs !== undefined ) {\n\n            this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n          } else {\n\n            console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n            this.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n          }\n\n        }\n\n        if ( hasFaceVertexUv2 === true ) {\n\n          var vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n          if ( vertexUvs !== undefined ) {\n\n            this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n          } else {\n\n            console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n            this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n          }\n\n        }\n\n        // morphs\n\n        for ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n          var morphTarget = morphTargets[ j ].vertices;\n\n          morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n        }\n\n        for ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n          var morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n          morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n        }\n\n        // skins\n\n        if ( hasSkinIndices ) {\n\n          this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n        }\n\n        if ( hasSkinWeights ) {\n\n          this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n        }\n\n      }\n\n      this.computeGroups( geometry );\n\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n      return this;\n\n    }\n\n  } );\n\n  // http://stackoverflow.com/questions/1669190/javascript-min-max-array-values/13440842#13440842\n\n  function arrayMax( array ) {\n\n    var length = array.length, max = - Infinity;\n\n    while ( length -- ) {\n\n      if ( array[ length ] > max ) {\n\n        max = array[ length ];\n\n      }\n\n    }\n\n    return max;\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author kile / http://kile.stravaganza.org/\n   * @author alteredq / http://alteredqualia.com/\n   * @author mikael emtinger / http://gomo.se/\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * @author bhouston / http://clara.io\n   */\n\n  var count = 0;\n  function GeometryIdCount() { return count++; }\n\n  function Geometry() {\n\n    Object.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n    this.uuid = _Math.generateUUID();\n\n    this.name = '';\n    this.type = 'Geometry';\n\n    this.vertices = [];\n    this.colors = [];\n    this.faces = [];\n    this.faceVertexUvs = [[]];\n\n    this.morphTargets = [];\n    this.morphNormals = [];\n\n    this.skinWeights = [];\n    this.skinIndices = [];\n\n    this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // update flags\n\n    this.elementsNeedUpdate = false;\n    this.verticesNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.lineDistancesNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n\n  }\n\n  Object.assign( Geometry.prototype, EventDispatcher.prototype, {\n\n    isGeometry: true,\n\n    applyMatrix: function ( matrix ) {\n\n      var normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n      for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n        var vertex = this.vertices[ i ];\n        vertex.applyMatrix4( matrix );\n\n      }\n\n      for ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n        var face = this.faces[ i ];\n        face.normal.applyMatrix3( normalMatrix ).normalize();\n\n        for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n          face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n        }\n\n      }\n\n      if ( this.boundingBox !== null ) {\n\n        this.computeBoundingBox();\n\n      }\n\n      if ( this.boundingSphere !== null ) {\n\n        this.computeBoundingSphere();\n\n      }\n\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n\n      return this;\n\n    },\n\n    rotateX: function () {\n\n      // rotate geometry around world x-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateX( angle ) {\n\n        m1.makeRotationX( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    rotateY: function () {\n\n      // rotate geometry around world y-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateY( angle ) {\n\n        m1.makeRotationY( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    rotateZ: function () {\n\n      // rotate geometry around world z-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateZ( angle ) {\n\n        m1.makeRotationZ( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    translate: function () {\n\n      // translate geometry\n\n      var m1 = new Matrix4();\n\n      return function translate( x, y, z ) {\n\n        m1.makeTranslation( x, y, z );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    scale: function () {\n\n      // scale geometry\n\n      var m1 = new Matrix4();\n\n      return function scale( x, y, z ) {\n\n        m1.makeScale( x, y, z );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    lookAt: function () {\n\n      var obj = new Object3D();\n\n      return function lookAt( vector ) {\n\n        obj.lookAt( vector );\n\n        obj.updateMatrix();\n\n        this.applyMatrix( obj.matrix );\n\n      };\n\n    }(),\n\n    fromBufferGeometry: function ( geometry ) {\n\n      var scope = this;\n\n      var indices = geometry.index !== null ? geometry.index.array : undefined;\n      var attributes = geometry.attributes;\n\n      var positions = attributes.position.array;\n      var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n      var colors = attributes.color !== undefined ? attributes.color.array : undefined;\n      var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n      var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n      if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n      var tempNormals = [];\n      var tempUVs = [];\n      var tempUVs2 = [];\n\n      for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n        scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n        if ( normals !== undefined ) {\n\n          tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n        }\n\n        if ( colors !== undefined ) {\n\n          scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n        }\n\n        if ( uvs !== undefined ) {\n\n          tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n        }\n\n        if ( uvs2 !== undefined ) {\n\n          tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n        }\n\n      }\n\n      function addFace( a, b, c, materialIndex ) {\n\n        var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n        var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n        var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n        scope.faces.push( face );\n\n        if ( uvs !== undefined ) {\n\n          scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n        }\n\n        if ( uvs2 !== undefined ) {\n\n          scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n        }\n\n      }\n\n      if ( indices !== undefined ) {\n\n        var groups = geometry.groups;\n\n        if ( groups.length > 0 ) {\n\n          for ( var i = 0; i < groups.length; i ++ ) {\n\n            var group = groups[ i ];\n\n            var start = group.start;\n            var count = group.count;\n\n            for ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n              addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\n\n            }\n\n          }\n\n        } else {\n\n          for ( var i = 0; i < indices.length; i += 3 ) {\n\n            addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n          }\n\n        }\n\n      } else {\n\n        for ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n          addFace( i, i + 1, i + 2 );\n\n        }\n\n      }\n\n      this.computeFaceNormals();\n\n      if ( geometry.boundingBox !== null ) {\n\n        this.boundingBox = geometry.boundingBox.clone();\n\n      }\n\n      if ( geometry.boundingSphere !== null ) {\n\n        this.boundingSphere = geometry.boundingSphere.clone();\n\n      }\n\n      return this;\n\n    },\n\n    center: function () {\n\n      this.computeBoundingBox();\n\n      var offset = this.boundingBox.getCenter().negate();\n\n      this.translate( offset.x, offset.y, offset.z );\n\n      return offset;\n\n    },\n\n    normalize: function () {\n\n      this.computeBoundingSphere();\n\n      var center = this.boundingSphere.center;\n      var radius = this.boundingSphere.radius;\n\n      var s = radius === 0 ? 1 : 1.0 / radius;\n\n      var matrix = new Matrix4();\n      matrix.set(\n        s, 0, 0, - s * center.x,\n        0, s, 0, - s * center.y,\n        0, 0, s, - s * center.z,\n        0, 0, 0, 1\n      );\n\n      this.applyMatrix( matrix );\n\n      return this;\n\n    },\n\n    computeFaceNormals: function () {\n\n      var cb = new Vector3(), ab = new Vector3();\n\n      for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n        var face = this.faces[ f ];\n\n        var vA = this.vertices[ face.a ];\n        var vB = this.vertices[ face.b ];\n        var vC = this.vertices[ face.c ];\n\n        cb.subVectors( vC, vB );\n        ab.subVectors( vA, vB );\n        cb.cross( ab );\n\n        cb.normalize();\n\n        face.normal.copy( cb );\n\n      }\n\n    },\n\n    computeVertexNormals: function ( areaWeighted ) {\n\n      if ( areaWeighted === undefined ) areaWeighted = true;\n\n      var v, vl, f, fl, face, vertices;\n\n      vertices = new Array( this.vertices.length );\n\n      for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n        vertices[ v ] = new Vector3();\n\n      }\n\n      if ( areaWeighted ) {\n\n        // vertex normals weighted by triangle areas\n        // http://www.iquilezles.org/www/articles/normals/normals.htm\n\n        var vA, vB, vC;\n        var cb = new Vector3(), ab = new Vector3();\n\n        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n          face = this.faces[ f ];\n\n          vA = this.vertices[ face.a ];\n          vB = this.vertices[ face.b ];\n          vC = this.vertices[ face.c ];\n\n          cb.subVectors( vC, vB );\n          ab.subVectors( vA, vB );\n          cb.cross( ab );\n\n          vertices[ face.a ].add( cb );\n          vertices[ face.b ].add( cb );\n          vertices[ face.c ].add( cb );\n\n        }\n\n      } else {\n\n        this.computeFaceNormals();\n\n        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n          face = this.faces[ f ];\n\n          vertices[ face.a ].add( face.normal );\n          vertices[ face.b ].add( face.normal );\n          vertices[ face.c ].add( face.normal );\n\n        }\n\n      }\n\n      for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n        vertices[ v ].normalize();\n\n      }\n\n      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n        face = this.faces[ f ];\n\n        var vertexNormals = face.vertexNormals;\n\n        if ( vertexNormals.length === 3 ) {\n\n          vertexNormals[ 0 ].copy( vertices[ face.a ] );\n          vertexNormals[ 1 ].copy( vertices[ face.b ] );\n          vertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n        } else {\n\n          vertexNormals[ 0 ] = vertices[ face.a ].clone();\n          vertexNormals[ 1 ] = vertices[ face.b ].clone();\n          vertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n        }\n\n      }\n\n      if ( this.faces.length > 0 ) {\n\n        this.normalsNeedUpdate = true;\n\n      }\n\n    },\n\n    computeFlatVertexNormals: function () {\n\n      var f, fl, face;\n\n      this.computeFaceNormals();\n\n      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n        face = this.faces[ f ];\n\n        var vertexNormals = face.vertexNormals;\n\n        if ( vertexNormals.length === 3 ) {\n\n          vertexNormals[ 0 ].copy( face.normal );\n          vertexNormals[ 1 ].copy( face.normal );\n          vertexNormals[ 2 ].copy( face.normal );\n\n        } else {\n\n          vertexNormals[ 0 ] = face.normal.clone();\n          vertexNormals[ 1 ] = face.normal.clone();\n          vertexNormals[ 2 ] = face.normal.clone();\n\n        }\n\n      }\n\n      if ( this.faces.length > 0 ) {\n\n        this.normalsNeedUpdate = true;\n\n      }\n\n    },\n\n    computeMorphNormals: function () {\n\n      var i, il, f, fl, face;\n\n      // save original normals\n      // - create temp variables on first access\n      //   otherwise just copy (for faster repeated calls)\n\n      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n        face = this.faces[ f ];\n\n        if ( ! face.__originalFaceNormal ) {\n\n          face.__originalFaceNormal = face.normal.clone();\n\n        } else {\n\n          face.__originalFaceNormal.copy( face.normal );\n\n        }\n\n        if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n        for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n          if ( ! face.__originalVertexNormals[ i ] ) {\n\n            face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n          } else {\n\n            face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n          }\n\n        }\n\n      }\n\n      // use temp geometry to compute face and vertex normals for each morph\n\n      var tmpGeo = new Geometry();\n      tmpGeo.faces = this.faces;\n\n      for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n        // create on first access\n\n        if ( ! this.morphNormals[ i ] ) {\n\n          this.morphNormals[ i ] = {};\n          this.morphNormals[ i ].faceNormals = [];\n          this.morphNormals[ i ].vertexNormals = [];\n\n          var dstNormalsFace = this.morphNormals[ i ].faceNormals;\n          var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n          var faceNormal, vertexNormals;\n\n          for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n            faceNormal = new Vector3();\n            vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n            dstNormalsFace.push( faceNormal );\n            dstNormalsVertex.push( vertexNormals );\n\n          }\n\n        }\n\n        var morphNormals = this.morphNormals[ i ];\n\n        // set vertices to morph target\n\n        tmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n        // compute morph normals\n\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals();\n\n        // store morph normals\n\n        var faceNormal, vertexNormals;\n\n        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n          face = this.faces[ f ];\n\n          faceNormal = morphNormals.faceNormals[ f ];\n          vertexNormals = morphNormals.vertexNormals[ f ];\n\n          faceNormal.copy( face.normal );\n\n          vertexNormals.a.copy( face.vertexNormals[ 0 ] );\n          vertexNormals.b.copy( face.vertexNormals[ 1 ] );\n          vertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n        }\n\n      }\n\n      // restore original normals\n\n      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n        face = this.faces[ f ];\n\n        face.normal = face.__originalFaceNormal;\n        face.vertexNormals = face.__originalVertexNormals;\n\n      }\n\n    },\n\n    computeLineDistances: function () {\n\n      var d = 0;\n      var vertices = this.vertices;\n\n      for ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n        if ( i > 0 ) {\n\n          d += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n        }\n\n        this.lineDistances[ i ] = d;\n\n      }\n\n    },\n\n    computeBoundingBox: function () {\n\n      if ( this.boundingBox === null ) {\n\n        this.boundingBox = new Box3();\n\n      }\n\n      this.boundingBox.setFromPoints( this.vertices );\n\n    },\n\n    computeBoundingSphere: function () {\n\n      if ( this.boundingSphere === null ) {\n\n        this.boundingSphere = new Sphere();\n\n      }\n\n      this.boundingSphere.setFromPoints( this.vertices );\n\n    },\n\n    merge: function ( geometry, matrix, materialIndexOffset ) {\n\n      if ( ( geometry && geometry.isGeometry ) === false ) {\n\n        console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n        return;\n\n      }\n\n      var normalMatrix,\n        vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        uvs1 = this.faceVertexUvs[ 0 ],\n        uvs2 = geometry.faceVertexUvs[ 0 ],\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n\n      if ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n      if ( matrix !== undefined ) {\n\n        normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n      }\n\n      // vertices\n\n      for ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n        var vertex = vertices2[ i ];\n\n        var vertexCopy = vertex.clone();\n\n        if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n        vertices1.push( vertexCopy );\n\n      }\n\n      // colors\n\n      for ( var i = 0, il = colors2.length; i < il; i ++ ) {\n\n        colors1.push( colors2[ i ].clone() );\n\n      }\n\n      // faces\n\n      for ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n        var face = faces2[ i ], faceCopy, normal, color,\n          faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n\n        faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n        faceCopy.normal.copy( face.normal );\n\n        if ( normalMatrix !== undefined ) {\n\n          faceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n        }\n\n        for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n          normal = faceVertexNormals[ j ].clone();\n\n          if ( normalMatrix !== undefined ) {\n\n            normal.applyMatrix3( normalMatrix ).normalize();\n\n          }\n\n          faceCopy.vertexNormals.push( normal );\n\n        }\n\n        faceCopy.color.copy( face.color );\n\n        for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n          color = faceVertexColors[ j ];\n          faceCopy.vertexColors.push( color.clone() );\n\n        }\n\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n        faces1.push( faceCopy );\n\n      }\n\n      // uvs\n\n      for ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n        var uv = uvs2[ i ], uvCopy = [];\n\n        if ( uv === undefined ) {\n\n          continue;\n\n        }\n\n        for ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n          uvCopy.push( uv[ j ].clone() );\n\n        }\n\n        uvs1.push( uvCopy );\n\n      }\n\n    },\n\n    mergeMesh: function ( mesh ) {\n\n      if ( ( mesh && mesh.isMesh ) === false ) {\n\n        console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n        return;\n\n      }\n\n      mesh.matrixAutoUpdate && mesh.updateMatrix();\n\n      this.merge( mesh.geometry, mesh.matrix );\n\n    },\n\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n\n    mergeVertices: function () {\n\n      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n      var unique = [], changes = [];\n\n      var v, key;\n      var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n      var precision = Math.pow( 10, precisionPoints );\n      var i, il, face;\n      var indices, j, jl;\n\n      for ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n        v = this.vertices[ i ];\n        key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n        if ( verticesMap[ key ] === undefined ) {\n\n          verticesMap[ key ] = i;\n          unique.push( this.vertices[ i ] );\n          changes[ i ] = unique.length - 1;\n\n        } else {\n\n          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n          changes[ i ] = changes[ verticesMap[ key ] ];\n\n        }\n\n      }\n\n\n      // if faces are completely degenerate after merging vertices, we\n      // have to remove them from the geometry.\n      var faceIndicesToRemove = [];\n\n      for ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n        face = this.faces[ i ];\n\n        face.a = changes[ face.a ];\n        face.b = changes[ face.b ];\n        face.c = changes[ face.c ];\n\n        indices = [ face.a, face.b, face.c ];\n\n        // if any duplicate vertices are found in a Face3\n        // we have to remove the face as nothing can be saved\n        for ( var n = 0; n < 3; n ++ ) {\n\n          if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n            faceIndicesToRemove.push( i );\n            break;\n\n          }\n\n        }\n\n      }\n\n      for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n        var idx = faceIndicesToRemove[ i ];\n\n        this.faces.splice( idx, 1 );\n\n        for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n          this.faceVertexUvs[ j ].splice( idx, 1 );\n\n        }\n\n      }\n\n      // Use unique set of vertices\n\n      var diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n\n    },\n\n    sortFacesByMaterialIndex: function () {\n\n      var faces = this.faces;\n      var length = faces.length;\n\n      // tag faces\n\n      for ( var i = 0; i < length; i ++ ) {\n\n        faces[ i ]._id = i;\n\n      }\n\n      // sort faces\n\n      function materialIndexSort( a, b ) {\n\n        return a.materialIndex - b.materialIndex;\n\n      }\n\n      faces.sort( materialIndexSort );\n\n      // sort uvs\n\n      var uvs1 = this.faceVertexUvs[ 0 ];\n      var uvs2 = this.faceVertexUvs[ 1 ];\n\n      var newUvs1, newUvs2;\n\n      if ( uvs1 && uvs1.length === length ) newUvs1 = [];\n      if ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n      for ( var i = 0; i < length; i ++ ) {\n\n        var id = faces[ i ]._id;\n\n        if ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n        if ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n      }\n\n      if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n      if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n    },\n\n    toJSON: function () {\n\n      var data = {\n        metadata: {\n          version: 4.4,\n          type: 'Geometry',\n          generator: 'Geometry.toJSON'\n        }\n      };\n\n      // standard Geometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if ( this.name !== '' ) data.name = this.name;\n\n      if ( this.parameters !== undefined ) {\n\n        var parameters = this.parameters;\n\n        for ( var key in parameters ) {\n\n          if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n        }\n\n        return data;\n\n      }\n\n      var vertices = [];\n\n      for ( var i = 0; i < this.vertices.length; i ++ ) {\n\n        var vertex = this.vertices[ i ];\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n      }\n\n      var faces = [];\n      var normals = [];\n      var normalsHash = {};\n      var colors = [];\n      var colorsHash = {};\n      var uvs = [];\n      var uvsHash = {};\n\n      for ( var i = 0; i < this.faces.length; i ++ ) {\n\n        var face = this.faces[ i ];\n\n        var hasMaterial = true;\n        var hasFaceUv = false; // deprecated\n        var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n        var hasFaceNormal = face.normal.length() > 0;\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        var hasFaceVertexColor = face.vertexColors.length > 0;\n\n        var faceType = 0;\n\n        faceType = setBit( faceType, 0, 0 ); // isQuad\n        faceType = setBit( faceType, 1, hasMaterial );\n        faceType = setBit( faceType, 2, hasFaceUv );\n        faceType = setBit( faceType, 3, hasFaceVertexUv );\n        faceType = setBit( faceType, 4, hasFaceNormal );\n        faceType = setBit( faceType, 5, hasFaceVertexNormal );\n        faceType = setBit( faceType, 6, hasFaceColor );\n        faceType = setBit( faceType, 7, hasFaceVertexColor );\n\n        faces.push( faceType );\n        faces.push( face.a, face.b, face.c );\n        faces.push( face.materialIndex );\n\n        if ( hasFaceVertexUv ) {\n\n          var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n          faces.push(\n            getUvIndex( faceVertexUvs[ 0 ] ),\n            getUvIndex( faceVertexUvs[ 1 ] ),\n            getUvIndex( faceVertexUvs[ 2 ] )\n          );\n\n        }\n\n        if ( hasFaceNormal ) {\n\n          faces.push( getNormalIndex( face.normal ) );\n\n        }\n\n        if ( hasFaceVertexNormal ) {\n\n          var vertexNormals = face.vertexNormals;\n\n          faces.push(\n            getNormalIndex( vertexNormals[ 0 ] ),\n            getNormalIndex( vertexNormals[ 1 ] ),\n            getNormalIndex( vertexNormals[ 2 ] )\n          );\n\n        }\n\n        if ( hasFaceColor ) {\n\n          faces.push( getColorIndex( face.color ) );\n\n        }\n\n        if ( hasFaceVertexColor ) {\n\n          var vertexColors = face.vertexColors;\n\n          faces.push(\n            getColorIndex( vertexColors[ 0 ] ),\n            getColorIndex( vertexColors[ 1 ] ),\n            getColorIndex( vertexColors[ 2 ] )\n          );\n\n        }\n\n      }\n\n      function setBit( value, position, enabled ) {\n\n        return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n      }\n\n      function getNormalIndex( normal ) {\n\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n        if ( normalsHash[ hash ] !== undefined ) {\n\n          return normalsHash[ hash ];\n\n        }\n\n        normalsHash[ hash ] = normals.length / 3;\n        normals.push( normal.x, normal.y, normal.z );\n\n        return normalsHash[ hash ];\n\n      }\n\n      function getColorIndex( color ) {\n\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n        if ( colorsHash[ hash ] !== undefined ) {\n\n          return colorsHash[ hash ];\n\n        }\n\n        colorsHash[ hash ] = colors.length;\n        colors.push( color.getHex() );\n\n        return colorsHash[ hash ];\n\n      }\n\n      function getUvIndex( uv ) {\n\n        var hash = uv.x.toString() + uv.y.toString();\n\n        if ( uvsHash[ hash ] !== undefined ) {\n\n          return uvsHash[ hash ];\n\n        }\n\n        uvsHash[ hash ] = uvs.length / 2;\n        uvs.push( uv.x, uv.y );\n\n        return uvsHash[ hash ];\n\n      }\n\n      data.data = {};\n\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if ( colors.length > 0 ) data.data.colors = colors;\n      if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n      data.data.faces = faces;\n\n      return data;\n\n    },\n\n    clone: function () {\n\n      /*\n       // Handle primitives\n\n       var parameters = this.parameters;\n\n       if ( parameters !== undefined ) {\n\n       var values = [];\n\n       for ( var key in parameters ) {\n\n       values.push( parameters[ key ] );\n\n       }\n\n       var geometry = Object.create( this.constructor.prototype );\n       this.constructor.apply( geometry, values );\n       return geometry;\n\n       }\n\n       return new this.constructor().copy( this );\n       */\n\n      return new Geometry().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      var i, il, j, jl, k, kl;\n\n      // reset\n\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n\n      // name\n\n      this.name = source.name;\n\n      // vertices\n\n      var vertices = source.vertices;\n\n      for ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n        this.vertices.push( vertices[ i ].clone() );\n\n      }\n\n      // colors\n\n      var colors = source.colors;\n\n      for ( i = 0, il = colors.length; i < il; i ++ ) {\n\n        this.colors.push( colors[ i ].clone() );\n\n      }\n\n      // faces\n\n      var faces = source.faces;\n\n      for ( i = 0, il = faces.length; i < il; i ++ ) {\n\n        this.faces.push( faces[ i ].clone() );\n\n      }\n\n      // face vertex uvs\n\n      for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n        var faceVertexUvs = source.faceVertexUvs[ i ];\n\n        if ( this.faceVertexUvs[ i ] === undefined ) {\n\n          this.faceVertexUvs[ i ] = [];\n\n        }\n\n        for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n          var uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n          for ( k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n            var uv = uvs[ k ];\n\n            uvsCopy.push( uv.clone() );\n\n          }\n\n          this.faceVertexUvs[ i ].push( uvsCopy );\n\n        }\n\n      }\n\n      // morph targets\n\n      var morphTargets = source.morphTargets;\n\n      for ( i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n        var morphTarget = {};\n        morphTarget.name = morphTargets[ i ].name;\n\n        // vertices\n\n        if ( morphTargets[ i ].vertices !== undefined ) {\n\n          morphTarget.vertices = [];\n\n          for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n            morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n          }\n\n        }\n\n        // normals\n\n        if ( morphTargets[ i ].normals !== undefined ) {\n\n          morphTarget.normals = [];\n\n          for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n            morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n          }\n\n        }\n\n        this.morphTargets.push( morphTarget );\n\n      }\n\n      // morph normals\n\n      var morphNormals = source.morphNormals;\n\n      for ( i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n        var morphNormal = {};\n\n        // vertex normals\n\n        if ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n          morphNormal.vertexNormals = [];\n\n          for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n            var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n            var destVertexNormal = {};\n\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n\n            morphNormal.vertexNormals.push( destVertexNormal );\n\n          }\n\n        }\n\n        // face normals\n\n        if ( morphNormals[ i ].faceNormals !== undefined ) {\n\n          morphNormal.faceNormals = [];\n\n          for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n            morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n          }\n\n        }\n\n        this.morphNormals.push( morphNormal );\n\n      }\n\n      // skin weights\n\n      var skinWeights = source.skinWeights;\n\n      for ( i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n        this.skinWeights.push( skinWeights[ i ].clone() );\n\n      }\n\n      // skin indices\n\n      var skinIndices = source.skinIndices;\n\n      for ( i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n        this.skinIndices.push( skinIndices[ i ].clone() );\n\n      }\n\n      // line distances\n\n      var lineDistances = source.lineDistances;\n\n      for ( i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n        this.lineDistances.push( lineDistances[ i ] );\n\n      }\n\n      // bounding box\n\n      var boundingBox = source.boundingBox;\n\n      if ( boundingBox !== null ) {\n\n        this.boundingBox = boundingBox.clone();\n\n      }\n\n      // bounding sphere\n\n      var boundingSphere = source.boundingSphere;\n\n      if ( boundingSphere !== null ) {\n\n        this.boundingSphere = boundingSphere.clone();\n\n      }\n\n      // update flags\n\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n\n      return this;\n\n    },\n\n    dispose: function () {\n\n      this.dispatchEvent( { type: 'dispose' } );\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function BufferGeometry() {\n\n    Object.defineProperty( this, 'id', { value: GeometryIdCount() } );\n\n    this.uuid = _Math.generateUUID();\n\n    this.name = '';\n    this.type = 'BufferGeometry';\n\n    this.index = null;\n    this.attributes = {};\n\n    this.morphAttributes = {};\n\n    this.groups = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    this.drawRange = { start: 0, count: Infinity };\n\n  }\n\n  BufferGeometry.MaxIndex = 65535;\n\n  Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {\n\n    isBufferGeometry: true,\n\n    getIndex: function () {\n\n      return this.index;\n\n    },\n\n    setIndex: function ( index ) {\n\n      if ( Array.isArray( index ) ) {\n\n        this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n      } else {\n\n        this.index = index;\n\n      }\n\n    },\n\n    addAttribute: function ( name, attribute ) {\n\n      if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {\n\n        console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n        this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n        return;\n\n      }\n\n      if ( name === 'index' ) {\n\n        console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n        this.setIndex( attribute );\n\n        return;\n\n      }\n\n      this.attributes[ name ] = attribute;\n\n      return this;\n\n    },\n\n    getAttribute: function ( name ) {\n\n      return this.attributes[ name ];\n\n    },\n\n    removeAttribute: function ( name ) {\n\n      delete this.attributes[ name ];\n\n      return this;\n\n    },\n\n    addGroup: function ( start, count, materialIndex ) {\n\n      this.groups.push( {\n\n        start: start,\n        count: count,\n        materialIndex: materialIndex !== undefined ? materialIndex : 0\n\n      } );\n\n    },\n\n    clearGroups: function () {\n\n      this.groups = [];\n\n    },\n\n    setDrawRange: function ( start, count ) {\n\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n\n    },\n\n    applyMatrix: function ( matrix ) {\n\n      var position = this.attributes.position;\n\n      if ( position !== undefined ) {\n\n        matrix.applyToBufferAttribute( position );\n        position.needsUpdate = true;\n\n      }\n\n      var normal = this.attributes.normal;\n\n      if ( normal !== undefined ) {\n\n        var normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n        normalMatrix.applyToBufferAttribute( normal );\n        normal.needsUpdate = true;\n\n      }\n\n      if ( this.boundingBox !== null ) {\n\n        this.computeBoundingBox();\n\n      }\n\n      if ( this.boundingSphere !== null ) {\n\n        this.computeBoundingSphere();\n\n      }\n\n      return this;\n\n    },\n\n    rotateX: function () {\n\n      // rotate geometry around world x-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateX( angle ) {\n\n        m1.makeRotationX( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    rotateY: function () {\n\n      // rotate geometry around world y-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateY( angle ) {\n\n        m1.makeRotationY( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    rotateZ: function () {\n\n      // rotate geometry around world z-axis\n\n      var m1 = new Matrix4();\n\n      return function rotateZ( angle ) {\n\n        m1.makeRotationZ( angle );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    translate: function () {\n\n      // translate geometry\n\n      var m1 = new Matrix4();\n\n      return function translate( x, y, z ) {\n\n        m1.makeTranslation( x, y, z );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    scale: function () {\n\n      // scale geometry\n\n      var m1 = new Matrix4();\n\n      return function scale( x, y, z ) {\n\n        m1.makeScale( x, y, z );\n\n        this.applyMatrix( m1 );\n\n        return this;\n\n      };\n\n    }(),\n\n    lookAt: function () {\n\n      var obj = new Object3D();\n\n      return function lookAt( vector ) {\n\n        obj.lookAt( vector );\n\n        obj.updateMatrix();\n\n        this.applyMatrix( obj.matrix );\n\n      };\n\n    }(),\n\n    center: function () {\n\n      this.computeBoundingBox();\n\n      var offset = this.boundingBox.getCenter().negate();\n\n      this.translate( offset.x, offset.y, offset.z );\n\n      return offset;\n\n    },\n\n    setFromObject: function ( object ) {\n\n      // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n      var geometry = object.geometry;\n\n      if ( object.isPoints || object.isLine ) {\n\n        var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n        var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n        this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n        this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n        if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n          var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n          this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n        }\n\n        if ( geometry.boundingSphere !== null ) {\n\n          this.boundingSphere = geometry.boundingSphere.clone();\n\n        }\n\n        if ( geometry.boundingBox !== null ) {\n\n          this.boundingBox = geometry.boundingBox.clone();\n\n        }\n\n      } else if ( object.isMesh ) {\n\n        if ( geometry && geometry.isGeometry ) {\n\n          this.fromGeometry( geometry );\n\n        }\n\n      }\n\n      return this;\n\n    },\n\n    updateFromObject: function ( object ) {\n\n      var geometry = object.geometry;\n\n      if ( object.isMesh ) {\n\n        var direct = geometry.__directGeometry;\n\n        if ( geometry.elementsNeedUpdate === true ) {\n\n          direct = undefined;\n          geometry.elementsNeedUpdate = false;\n\n        }\n\n        if ( direct === undefined ) {\n\n          return this.fromGeometry( geometry );\n\n        }\n\n        direct.verticesNeedUpdate = geometry.verticesNeedUpdate;\n        direct.normalsNeedUpdate = geometry.normalsNeedUpdate;\n        direct.colorsNeedUpdate = geometry.colorsNeedUpdate;\n        direct.uvsNeedUpdate = geometry.uvsNeedUpdate;\n        direct.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n        geometry.verticesNeedUpdate = false;\n        geometry.normalsNeedUpdate = false;\n        geometry.colorsNeedUpdate = false;\n        geometry.uvsNeedUpdate = false;\n        geometry.groupsNeedUpdate = false;\n\n        geometry = direct;\n\n      }\n\n      var attribute;\n\n      if ( geometry.verticesNeedUpdate === true ) {\n\n        attribute = this.attributes.position;\n\n        if ( attribute !== undefined ) {\n\n          attribute.copyVector3sArray( geometry.vertices );\n          attribute.needsUpdate = true;\n\n        }\n\n        geometry.verticesNeedUpdate = false;\n\n      }\n\n      if ( geometry.normalsNeedUpdate === true ) {\n\n        attribute = this.attributes.normal;\n\n        if ( attribute !== undefined ) {\n\n          attribute.copyVector3sArray( geometry.normals );\n          attribute.needsUpdate = true;\n\n        }\n\n        geometry.normalsNeedUpdate = false;\n\n      }\n\n      if ( geometry.colorsNeedUpdate === true ) {\n\n        attribute = this.attributes.color;\n\n        if ( attribute !== undefined ) {\n\n          attribute.copyColorsArray( geometry.colors );\n          attribute.needsUpdate = true;\n\n        }\n\n        geometry.colorsNeedUpdate = false;\n\n      }\n\n      if ( geometry.uvsNeedUpdate ) {\n\n        attribute = this.attributes.uv;\n\n        if ( attribute !== undefined ) {\n\n          attribute.copyVector2sArray( geometry.uvs );\n          attribute.needsUpdate = true;\n\n        }\n\n        geometry.uvsNeedUpdate = false;\n\n      }\n\n      if ( geometry.lineDistancesNeedUpdate ) {\n\n        attribute = this.attributes.lineDistance;\n\n        if ( attribute !== undefined ) {\n\n          attribute.copyArray( geometry.lineDistances );\n          attribute.needsUpdate = true;\n\n        }\n\n        geometry.lineDistancesNeedUpdate = false;\n\n      }\n\n      if ( geometry.groupsNeedUpdate ) {\n\n        geometry.computeGroups( object.geometry );\n        this.groups = geometry.groups;\n\n        geometry.groupsNeedUpdate = false;\n\n      }\n\n      return this;\n\n    },\n\n    fromGeometry: function ( geometry ) {\n\n      geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\n\n      return this.fromDirectGeometry( geometry.__directGeometry );\n\n    },\n\n    fromDirectGeometry: function ( geometry ) {\n\n      var positions = new Float32Array( geometry.vertices.length * 3 );\n      this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n      if ( geometry.normals.length > 0 ) {\n\n        var normals = new Float32Array( geometry.normals.length * 3 );\n        this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n      }\n\n      if ( geometry.colors.length > 0 ) {\n\n        var colors = new Float32Array( geometry.colors.length * 3 );\n        this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n      }\n\n      if ( geometry.uvs.length > 0 ) {\n\n        var uvs = new Float32Array( geometry.uvs.length * 2 );\n        this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n      }\n\n      if ( geometry.uvs2.length > 0 ) {\n\n        var uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n        this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n      }\n\n      if ( geometry.indices.length > 0 ) {\n\n        var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\n        var indices = new TypeArray( geometry.indices.length * 3 );\n        this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n      }\n\n      // groups\n\n      this.groups = geometry.groups;\n\n      // morphs\n\n      for ( var name in geometry.morphTargets ) {\n\n        var array = [];\n        var morphTargets = geometry.morphTargets[ name ];\n\n        for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n          var morphTarget = morphTargets[ i ];\n\n          var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\n\n          array.push( attribute.copyVector3sArray( morphTarget ) );\n\n        }\n\n        this.morphAttributes[ name ] = array;\n\n      }\n\n      // skinning\n\n      if ( geometry.skinIndices.length > 0 ) {\n\n        var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n        this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n      }\n\n      if ( geometry.skinWeights.length > 0 ) {\n\n        var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n        this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n      }\n\n      //\n\n      if ( geometry.boundingSphere !== null ) {\n\n        this.boundingSphere = geometry.boundingSphere.clone();\n\n      }\n\n      if ( geometry.boundingBox !== null ) {\n\n        this.boundingBox = geometry.boundingBox.clone();\n\n      }\n\n      return this;\n\n    },\n\n    computeBoundingBox: function () {\n\n      if ( this.boundingBox === null ) {\n\n        this.boundingBox = new Box3();\n\n      }\n\n      var position = this.attributes.position;\n\n      if ( position !== undefined ) {\n\n        this.boundingBox.setFromBufferAttribute( position );\n\n      } else {\n\n        this.boundingBox.makeEmpty();\n\n      }\n\n      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n      }\n\n    },\n\n    computeBoundingSphere: function () {\n\n      var box = new Box3();\n      var vector = new Vector3();\n\n      return function computeBoundingSphere() {\n\n        if ( this.boundingSphere === null ) {\n\n          this.boundingSphere = new Sphere();\n\n        }\n\n        var position = this.attributes.position;\n\n        if ( position ) {\n\n          var center = this.boundingSphere.center;\n\n          box.setFromBufferAttribute( position );\n          box.getCenter( center );\n\n          // hoping to find a boundingSphere with a radius smaller than the\n          // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n          var maxRadiusSq = 0;\n\n          for ( var i = 0, il = position.count; i < il; i ++ ) {\n\n            vector.x = position.getX( i );\n            vector.y = position.getY( i );\n            vector.z = position.getZ( i );\n            maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n          }\n\n          this.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n          if ( isNaN( this.boundingSphere.radius ) ) {\n\n            console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n          }\n\n        }\n\n      };\n\n    }(),\n\n    computeFaceNormals: function () {\n\n      // backwards compatibility\n\n    },\n\n    computeVertexNormals: function () {\n\n      var index = this.index;\n      var attributes = this.attributes;\n      var groups = this.groups;\n\n      if ( attributes.position ) {\n\n        var positions = attributes.position.array;\n\n        if ( attributes.normal === undefined ) {\n\n          this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n        } else {\n\n          // reset existing normals to zero\n\n          var array = attributes.normal.array;\n\n          for ( var i = 0, il = array.length; i < il; i ++ ) {\n\n            array[ i ] = 0;\n\n          }\n\n        }\n\n        var normals = attributes.normal.array;\n\n        var vA, vB, vC;\n        var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        var cb = new Vector3(), ab = new Vector3();\n\n        // indexed elements\n\n        if ( index ) {\n\n          var indices = index.array;\n\n          if ( groups.length === 0 ) {\n\n            this.addGroup( 0, indices.length );\n\n          }\n\n          for ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n            var group = groups[ j ];\n\n            var start = group.start;\n            var count = group.count;\n\n            for ( var i = start, il = start + count; i < il; i += 3 ) {\n\n              vA = indices[ i + 0 ] * 3;\n              vB = indices[ i + 1 ] * 3;\n              vC = indices[ i + 2 ] * 3;\n\n              pA.fromArray( positions, vA );\n              pB.fromArray( positions, vB );\n              pC.fromArray( positions, vC );\n\n              cb.subVectors( pC, pB );\n              ab.subVectors( pA, pB );\n              cb.cross( ab );\n\n              normals[ vA ] += cb.x;\n              normals[ vA + 1 ] += cb.y;\n              normals[ vA + 2 ] += cb.z;\n\n              normals[ vB ] += cb.x;\n              normals[ vB + 1 ] += cb.y;\n              normals[ vB + 2 ] += cb.z;\n\n              normals[ vC ] += cb.x;\n              normals[ vC + 1 ] += cb.y;\n              normals[ vC + 2 ] += cb.z;\n\n            }\n\n          }\n\n        } else {\n\n          // non-indexed elements (unconnected triangle soup)\n\n          for ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n            pA.fromArray( positions, i );\n            pB.fromArray( positions, i + 3 );\n            pC.fromArray( positions, i + 6 );\n\n            cb.subVectors( pC, pB );\n            ab.subVectors( pA, pB );\n            cb.cross( ab );\n\n            normals[ i ] = cb.x;\n            normals[ i + 1 ] = cb.y;\n            normals[ i + 2 ] = cb.z;\n\n            normals[ i + 3 ] = cb.x;\n            normals[ i + 4 ] = cb.y;\n            normals[ i + 5 ] = cb.z;\n\n            normals[ i + 6 ] = cb.x;\n            normals[ i + 7 ] = cb.y;\n            normals[ i + 8 ] = cb.z;\n\n          }\n\n        }\n\n        this.normalizeNormals();\n\n        attributes.normal.needsUpdate = true;\n\n      }\n\n    },\n\n    merge: function ( geometry, offset ) {\n\n      if ( ( geometry && geometry.isBufferGeometry ) === false ) {\n\n        console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n        return;\n\n      }\n\n      if ( offset === undefined ) offset = 0;\n\n      var attributes = this.attributes;\n\n      for ( var key in attributes ) {\n\n        if ( geometry.attributes[ key ] === undefined ) continue;\n\n        var attribute1 = attributes[ key ];\n        var attributeArray1 = attribute1.array;\n\n        var attribute2 = geometry.attributes[ key ];\n        var attributeArray2 = attribute2.array;\n\n        var attributeSize = attribute2.itemSize;\n\n        for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n          attributeArray1[ j ] = attributeArray2[ i ];\n\n        }\n\n      }\n\n      return this;\n\n    },\n\n    normalizeNormals: function () {\n\n      var normals = this.attributes.normal.array;\n\n      var x, y, z, n;\n\n      for ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n        x = normals[ i ];\n        y = normals[ i + 1 ];\n        z = normals[ i + 2 ];\n\n        n = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n        normals[ i ] *= n;\n        normals[ i + 1 ] *= n;\n        normals[ i + 2 ] *= n;\n\n      }\n\n    },\n\n    toNonIndexed: function () {\n\n      if ( this.index === null ) {\n\n        console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n        return this;\n\n      }\n\n      var geometry2 = new BufferGeometry();\n\n      var indices = this.index.array;\n      var attributes = this.attributes;\n\n      for ( var name in attributes ) {\n\n        var attribute = attributes[ name ];\n\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n\n        var array2 = new array.constructor( indices.length * itemSize );\n\n        var index = 0, index2 = 0;\n\n        for ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n          index = indices[ i ] * itemSize;\n\n          for ( var j = 0; j < itemSize; j ++ ) {\n\n            array2[ index2 ++ ] = array[ index ++ ];\n\n          }\n\n        }\n\n        geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\n\n      }\n\n      return geometry2;\n\n    },\n\n    toJSON: function () {\n\n      var data = {\n        metadata: {\n          version: 4.4,\n          type: 'BufferGeometry',\n          generator: 'BufferGeometry.toJSON'\n        }\n      };\n\n      // standard BufferGeometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if ( this.name !== '' ) data.name = this.name;\n\n      if ( this.parameters !== undefined ) {\n\n        var parameters = this.parameters;\n\n        for ( var key in parameters ) {\n\n          if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n        }\n\n        return data;\n\n      }\n\n      data.data = { attributes: {} };\n\n      var index = this.index;\n\n      if ( index !== null ) {\n\n        var array = Array.prototype.slice.call( index.array );\n\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: array\n        };\n\n      }\n\n      var attributes = this.attributes;\n\n      for ( var key in attributes ) {\n\n        var attribute = attributes[ key ];\n\n        var array = Array.prototype.slice.call( attribute.array );\n\n        data.data.attributes[ key ] = {\n          itemSize: attribute.itemSize,\n          type: attribute.array.constructor.name,\n          array: array,\n          normalized: attribute.normalized\n        };\n\n      }\n\n      var groups = this.groups;\n\n      if ( groups.length > 0 ) {\n\n        data.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n      }\n\n      var boundingSphere = this.boundingSphere;\n\n      if ( boundingSphere !== null ) {\n\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n\n      }\n\n      return data;\n\n    },\n\n    clone: function () {\n\n      /*\n       // Handle primitives\n\n       var parameters = this.parameters;\n\n       if ( parameters !== undefined ) {\n\n       var values = [];\n\n       for ( var key in parameters ) {\n\n       values.push( parameters[ key ] );\n\n       }\n\n       var geometry = Object.create( this.constructor.prototype );\n       this.constructor.apply( geometry, values );\n       return geometry;\n\n       }\n\n       return new this.constructor().copy( this );\n       */\n\n      return new BufferGeometry().copy( this );\n\n    },\n\n    copy: function ( source ) {\n\n      var name, i, l;\n\n      // reset\n\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n\n      // name\n\n      this.name = source.name;\n\n      // index\n\n      var index = source.index;\n\n      if ( index !== null ) {\n\n        this.setIndex( index.clone() );\n\n      }\n\n      // attributes\n\n      var attributes = source.attributes;\n\n      for ( name in attributes ) {\n\n        var attribute = attributes[ name ];\n        this.addAttribute( name, attribute.clone() );\n\n      }\n\n      // morph attributes\n\n      var morphAttributes = source.morphAttributes;\n\n      for ( name in morphAttributes ) {\n\n        var array = [];\n        var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n        for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n          array.push( morphAttribute[ i ].clone() );\n\n        }\n\n        this.morphAttributes[ name ] = array;\n\n      }\n\n      // groups\n\n      var groups = source.groups;\n\n      for ( i = 0, l = groups.length; i < l; i ++ ) {\n\n        var group = groups[ i ];\n        this.addGroup( group.start, group.count, group.materialIndex );\n\n      }\n\n      // bounding box\n\n      var boundingBox = source.boundingBox;\n\n      if ( boundingBox !== null ) {\n\n        this.boundingBox = boundingBox.clone();\n\n      }\n\n      // bounding sphere\n\n      var boundingSphere = source.boundingSphere;\n\n      if ( boundingSphere !== null ) {\n\n        this.boundingSphere = boundingSphere.clone();\n\n      }\n\n      // draw range\n\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n\n      return this;\n\n    },\n\n    dispose: function () {\n\n      this.dispatchEvent( { type: 'dispose' } );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   * @author mikael emtinger / http://gomo.se/\n   * @author jonobr1 / http://jonobr1.com/\n   */\n\n  function Mesh( geometry, material ) {\n\n    Object3D.call( this );\n\n    this.type = 'Mesh';\n\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n    this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n    this.drawMode = TrianglesDrawMode;\n\n    this.updateMorphTargets();\n\n  }\n\n  Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Mesh,\n\n    isMesh: true,\n\n    setDrawMode: function ( value ) {\n\n      this.drawMode = value;\n\n    },\n\n    copy: function ( source ) {\n\n      Object3D.prototype.copy.call( this, source );\n\n      this.drawMode = source.drawMode;\n\n      return this;\n\n    },\n\n    updateMorphTargets: function () {\n\n      var morphTargets = this.geometry.morphTargets;\n\n      if ( morphTargets !== undefined && morphTargets.length > 0 ) {\n\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n\n        for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {\n\n          this.morphTargetInfluences.push( 0 );\n          this.morphTargetDictionary[ morphTargets[ m ].name ] = m;\n\n        }\n\n      }\n\n    },\n\n    raycast: ( function () {\n\n      var inverseMatrix = new Matrix4();\n      var ray = new Ray();\n      var sphere = new Sphere();\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n\n      var tempA = new Vector3();\n      var tempB = new Vector3();\n      var tempC = new Vector3();\n\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      var barycoord = new Vector3();\n\n      var intersectionPoint = new Vector3();\n      var intersectionPointWorld = new Vector3();\n\n      function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n        Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n        uv1.multiplyScalar( barycoord.x );\n        uv2.multiplyScalar( barycoord.y );\n        uv3.multiplyScalar( barycoord.z );\n\n        uv1.add( uv2 ).add( uv3 );\n\n        return uv1.clone();\n\n      }\n\n      function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n        var intersect;\n        var material = object.material;\n\n        if ( material.side === BackSide ) {\n\n          intersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n        } else {\n\n          intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\n\n        }\n\n        if ( intersect === null ) return null;\n\n        intersectionPointWorld.copy( point );\n        intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n        var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n        if ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n        return {\n          distance: distance,\n          point: intersectionPointWorld.clone(),\n          object: object\n        };\n\n      }\n\n      function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\n\n        vA.fromBufferAttribute( position, a );\n        vB.fromBufferAttribute( position, b );\n        vC.fromBufferAttribute( position, c );\n\n        var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n        if ( intersection ) {\n\n          if ( uv ) {\n\n            uvA.fromBufferAttribute( uv, a );\n            uvB.fromBufferAttribute( uv, b );\n            uvC.fromBufferAttribute( uv, c );\n\n            intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC, uvA, uvB, uvC );\n\n          }\n\n          intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\n          intersection.faceIndex = a;\n\n        }\n\n        return intersection;\n\n      }\n\n      return function raycast( raycaster, intersects ) {\n\n        var geometry = this.geometry;\n        var material = this.material;\n        var matrixWorld = this.matrixWorld;\n\n        if ( material === undefined ) return;\n\n        // Checking boundingSphere distance to ray\n\n        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n        sphere.copy( geometry.boundingSphere );\n        sphere.applyMatrix4( matrixWorld );\n\n        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n        //\n\n        inverseMatrix.getInverse( matrixWorld );\n        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n        // Check boundingBox before continuing\n\n        if ( geometry.boundingBox !== null ) {\n\n          if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n        }\n\n        var intersection;\n\n        if ( geometry.isBufferGeometry ) {\n\n          var a, b, c;\n          var index = geometry.index;\n          var position = geometry.attributes.position;\n          var uv = geometry.attributes.uv;\n          var i, l;\n\n          if ( index !== null ) {\n\n            // indexed buffer geometry\n\n            for ( i = 0, l = index.count; i < l; i += 3 ) {\n\n              a = index.getX( i );\n              b = index.getX( i + 1 );\n              c = index.getX( i + 2 );\n\n              intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\n              if ( intersection ) {\n\n                intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n                intersects.push( intersection );\n\n              }\n\n            }\n\n          } else {\n\n            // non-indexed buffer geometry\n\n            for ( i = 0, l = position.count; i < l; i += 3 ) {\n\n              a = i;\n              b = i + 1;\n              c = i + 2;\n\n              intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\n\n              if ( intersection ) {\n\n                intersection.index = a; // triangle number in positions buffer semantics\n                intersects.push( intersection );\n\n              }\n\n            }\n\n          }\n\n        } else if ( geometry.isGeometry ) {\n\n          var fvA, fvB, fvC;\n          var isFaceMaterial = ( material && material.isMultiMaterial );\n          var materials = isFaceMaterial === true ? material.materials : null;\n\n          var vertices = geometry.vertices;\n          var faces = geometry.faces;\n          var uvs;\n\n          var faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n          if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n          for ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n            var face = faces[ f ];\n            var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n            if ( faceMaterial === undefined ) continue;\n\n            fvA = vertices[ face.a ];\n            fvB = vertices[ face.b ];\n            fvC = vertices[ face.c ];\n\n            if ( faceMaterial.morphTargets === true ) {\n\n              var morphTargets = geometry.morphTargets;\n              var morphInfluences = this.morphTargetInfluences;\n\n              vA.set( 0, 0, 0 );\n              vB.set( 0, 0, 0 );\n              vC.set( 0, 0, 0 );\n\n              for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n                var influence = morphInfluences[ t ];\n\n                if ( influence === 0 ) continue;\n\n                var targets = morphTargets[ t ].vertices;\n\n                vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n                vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n                vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n              }\n\n              vA.add( fvA );\n              vB.add( fvB );\n              vC.add( fvC );\n\n              fvA = vA;\n              fvB = vB;\n              fvC = vC;\n\n            }\n\n            intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n            if ( intersection ) {\n\n              if ( uvs ) {\n\n                var uvs_f = uvs[ f ];\n                uvA.copy( uvs_f[ 0 ] );\n                uvB.copy( uvs_f[ 1 ] );\n                uvC.copy( uvs_f[ 2 ] );\n\n                intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n              }\n\n              intersection.face = face;\n              intersection.faceIndex = f;\n              intersects.push( intersection );\n\n            }\n\n          }\n\n        }\n\n      };\n\n    }() ),\n\n    clone: function () {\n\n      return new this.constructor( this.geometry, this.material ).copy( this );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n   */\n\n  function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n    Geometry.call( this );\n\n    this.type = 'BoxGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n\n    this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n    this.mergeVertices();\n\n  }\n\n  BoxGeometry.prototype = Object.create( Geometry.prototype );\n  BoxGeometry.prototype.constructor = BoxGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'BoxBufferGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n\n    var scope = this;\n\n    // segments\n\n    widthSegments = Math.floor( widthSegments ) || 1;\n    heightSegments = Math.floor( heightSegments ) || 1;\n    depthSegments = Math.floor( depthSegments ) || 1;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var numberOfVertices = 0;\n    var groupStart = 0;\n\n    // build each side of the box geometry\n\n    buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n    buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n    buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n    buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n    buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n    buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n      var segmentWidth = width / gridX;\n      var segmentHeight = height / gridY;\n\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      var depthHalf = depth / 2;\n\n      var gridX1 = gridX + 1;\n      var gridY1 = gridY + 1;\n\n      var vertexCounter = 0;\n      var groupCount = 0;\n\n      var ix, iy;\n\n      var vector = new Vector3();\n\n      // generate vertices, normals and uvs\n\n      for ( iy = 0; iy < gridY1; iy ++ ) {\n\n        var y = iy * segmentHeight - heightHalf;\n\n        for ( ix = 0; ix < gridX1; ix ++ ) {\n\n          var x = ix * segmentWidth - widthHalf;\n\n          // set values to correct vector component\n\n          vector[ u ] = x * udir;\n          vector[ v ] = y * vdir;\n          vector[ w ] = depthHalf;\n\n          // now apply vector to vertex buffer\n\n          vertices.push( vector.x, vector.y, vector.z );\n\n          // set values to correct vector component\n\n          vector[ u ] = 0;\n          vector[ v ] = 0;\n          vector[ w ] = depth > 0 ? 1 : - 1;\n\n          // now apply vector to normal buffer\n\n          normals.push( vector.x, vector.y, vector.z );\n\n          // uvs\n\n          uvs.push( ix / gridX );\n          uvs.push( 1 - ( iy / gridY ) );\n\n          // counters\n\n          vertexCounter += 1;\n\n        }\n\n      }\n\n      // indices\n\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n      for ( iy = 0; iy < gridY; iy ++ ) {\n\n        for ( ix = 0; ix < gridX; ix ++ ) {\n\n          var a = numberOfVertices + ix + gridX1 * iy;\n          var b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n          var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n          var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n          // faces\n\n          indices.push( a, b, d );\n          indices.push( b, c, d );\n\n          // increase counter\n\n          groupCount += 6;\n\n        }\n\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup( groupStart, groupCount, materialIndex );\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n      // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n\n    }\n\n  }\n\n  BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n   */\n\n  function PlaneGeometry( width, height, widthSegments, heightSegments ) {\n\n    Geometry.call( this );\n\n    this.type = 'PlaneGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n\n    this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n  }\n\n  PlaneGeometry.prototype = Object.create( Geometry.prototype );\n  PlaneGeometry.prototype.constructor = PlaneGeometry;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author Mugen87 / https://github.com/Mugen87\n   *\n   * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n   */\n\n  function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'PlaneBufferGeometry';\n\n    this.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n\n    var width_half = width / 2;\n    var height_half = height / 2;\n\n    var gridX = Math.floor( widthSegments ) || 1;\n    var gridY = Math.floor( heightSegments ) || 1;\n\n    var gridX1 = gridX + 1;\n    var gridY1 = gridY + 1;\n\n    var segment_width = width / gridX;\n    var segment_height = height / gridY;\n\n    var ix, iy;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // generate vertices, normals and uvs\n\n    for ( iy = 0; iy < gridY1; iy ++ ) {\n\n      var y = iy * segment_height - height_half;\n\n      for ( ix = 0; ix < gridX1; ix ++ ) {\n\n        var x = ix * segment_width - width_half;\n\n        vertices.push( x, - y, 0 );\n\n        normals.push( 0, 0, 1 );\n\n        uvs.push( ix / gridX );\n        uvs.push( 1 - ( iy / gridY ) );\n\n      }\n\n    }\n\n    // indices\n\n    for ( iy = 0; iy < gridY; iy ++ ) {\n\n      for ( ix = 0; ix < gridX; ix ++ ) {\n\n        var a = ix + gridX1 * iy;\n        var b = ix + gridX1 * ( iy + 1 );\n        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n        var d = ( ix + 1 ) + gridX1 * iy;\n\n        // faces\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author mikael emtinger / http://gomo.se/\n   * @author WestLangley / http://github.com/WestLangley\n  */\n\n  function Camera() {\n\n    Object3D.call( this );\n\n    this.type = 'Camera';\n\n    this.matrixWorldInverse = new Matrix4();\n    this.projectionMatrix = new Matrix4();\n\n  }\n\n  Camera.prototype = Object.create( Object3D.prototype );\n  Camera.prototype.constructor = Camera;\n\n  Camera.prototype.isCamera = true;\n\n  Camera.prototype.getWorldDirection = function () {\n\n    var quaternion = new Quaternion();\n\n    return function getWorldDirection( optionalTarget ) {\n\n      var result = optionalTarget || new Vector3();\n\n      this.getWorldQuaternion( quaternion );\n\n      return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n    };\n\n  }();\n\n  Camera.prototype.lookAt = function () {\n\n    // This routine does not support cameras with rotated and/or translated parent(s)\n\n    var m1 = new Matrix4();\n\n    return function lookAt( vector ) {\n\n      m1.lookAt( this.position, vector, this.up );\n\n      this.quaternion.setFromRotationMatrix( m1 );\n\n    };\n\n  }();\n\n  Camera.prototype.clone = function () {\n\n    return new this.constructor().copy( this );\n\n  };\n\n  Camera.prototype.copy = function ( source ) {\n\n    Object3D.prototype.copy.call( this, source );\n\n    this.matrixWorldInverse.copy( source.matrixWorldInverse );\n    this.projectionMatrix.copy( source.projectionMatrix );\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author greggman / http://games.greggman.com/\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * @author tschw\n   */\n\n  function PerspectiveCamera( fov, aspect, near, far ) {\n\n    Camera.call( this );\n\n    this.type = 'PerspectiveCamera';\n\n    this.fov = fov !== undefined ? fov : 50;\n    this.zoom = 1;\n\n    this.near = near !== undefined ? near : 0.1;\n    this.far = far !== undefined ? far : 2000;\n    this.focus = 10;\n\n    this.aspect = aspect !== undefined ? aspect : 1;\n    this.view = null;\n\n    this.filmGauge = 35;  // width of the film (default in millimeters)\n    this.filmOffset = 0;  // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n\n  }\n\n  PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n    constructor: PerspectiveCamera,\n\n    isPerspectiveCamera: true,\n\n    copy: function ( source ) {\n\n      Camera.prototype.copy.call( this, source );\n\n      this.fov = source.fov;\n      this.zoom = source.zoom;\n\n      this.near = source.near;\n      this.far = source.far;\n      this.focus = source.focus;\n\n      this.aspect = source.aspect;\n      this.view = source.view === null ? null : Object.assign( {}, source.view );\n\n      this.filmGauge = source.filmGauge;\n      this.filmOffset = source.filmOffset;\n\n      return this;\n\n    },\n\n    /**\n     * Sets the FOV by focal length in respect to the current .filmGauge.\n     *\n     * The default film gauge is 35, so that the focal length can be specified for\n     * a 35mm (full frame) camera.\n     *\n     * Values for focal length and film gauge must have the same unit.\n     */\n    setFocalLength: function ( focalLength ) {\n\n      // see http://www.bobatkins.com/photography/technical/field_of_view.html\n      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n      this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n      this.updateProjectionMatrix();\n\n    },\n\n    /**\n     * Calculates the focal length from the current .fov and .filmGauge.\n     */\n    getFocalLength: function () {\n\n      var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\n\n      return 0.5 * this.getFilmHeight() / vExtentSlope;\n\n    },\n\n    getEffectiveFOV: function () {\n\n      return _Math.RAD2DEG * 2 * Math.atan(\n          Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n    },\n\n    getFilmWidth: function () {\n\n      // film not completely covered in portrait format (aspect < 1)\n      return this.filmGauge * Math.min( this.aspect, 1 );\n\n    },\n\n    getFilmHeight: function () {\n\n      // film not completely covered in landscape format (aspect > 1)\n      return this.filmGauge / Math.max( this.aspect, 1 );\n\n    },\n\n    /**\n     * Sets an offset in a larger frustum. This is useful for multi-window or\n     * multi-monitor/multi-machine setups.\n     *\n     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n     * the monitors are in grid like this\n     *\n     *   +---+---+---+\n     *   | A | B | C |\n     *   +---+---+---+\n     *   | D | E | F |\n     *   +---+---+---+\n     *\n     * then for each monitor you would call it like this\n     *\n     *   var w = 1920;\n     *   var h = 1080;\n     *   var fullWidth = w * 3;\n     *   var fullHeight = h * 2;\n     *\n     *   --A--\n     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n     *   --B--\n     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n     *   --C--\n     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n     *   --D--\n     *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n     *   --E--\n     *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n     *   --F--\n     *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n     *\n     *   Note there is no reason monitors have to be the same size or in a grid.\n     */\n    setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n      this.aspect = fullWidth / fullHeight;\n\n      this.view = {\n        fullWidth: fullWidth,\n        fullHeight: fullHeight,\n        offsetX: x,\n        offsetY: y,\n        width: width,\n        height: height\n      };\n\n      this.updateProjectionMatrix();\n\n    },\n\n    clearViewOffset: function() {\n\n      this.view = null;\n      this.updateProjectionMatrix();\n\n    },\n\n    updateProjectionMatrix: function () {\n\n      var near = this.near,\n        top = near * Math.tan(\n            _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n        height = 2 * top,\n        width = this.aspect * height,\n        left = - 0.5 * width,\n        view = this.view;\n\n      if ( view !== null ) {\n\n        var fullWidth = view.fullWidth,\n          fullHeight = view.fullHeight;\n\n        left += view.offsetX * width / fullWidth;\n        top -= view.offsetY * height / fullHeight;\n        width *= view.width / fullWidth;\n        height *= view.height / fullHeight;\n\n      }\n\n      var skew = this.filmOffset;\n      if ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n      this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n    },\n\n    toJSON: function ( meta ) {\n\n      var data = Object3D.prototype.toJSON.call( this, meta );\n\n      data.object.fov = this.fov;\n      data.object.zoom = this.zoom;\n\n      data.object.near = this.near;\n      data.object.far = this.far;\n      data.object.focus = this.focus;\n\n      data.object.aspect = this.aspect;\n\n      if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n      data.object.filmGauge = this.filmGauge;\n      data.object.filmOffset = this.filmOffset;\n\n      return data;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author arose / http://github.com/arose\n   */\n\n  function OrthographicCamera( left, right, top, bottom, near, far ) {\n\n    Camera.call( this );\n\n    this.type = 'OrthographicCamera';\n\n    this.zoom = 1;\n    this.view = null;\n\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n\n    this.near = ( near !== undefined ) ? near : 0.1;\n    this.far = ( far !== undefined ) ? far : 2000;\n\n    this.updateProjectionMatrix();\n\n  }\n\n  OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\n\n    constructor: OrthographicCamera,\n\n    isOrthographicCamera: true,\n\n    copy: function ( source ) {\n\n      Camera.prototype.copy.call( this, source );\n\n      this.left = source.left;\n      this.right = source.right;\n      this.top = source.top;\n      this.bottom = source.bottom;\n      this.near = source.near;\n      this.far = source.far;\n\n      this.zoom = source.zoom;\n      this.view = source.view === null ? null : Object.assign( {}, source.view );\n\n      return this;\n\n    },\n\n    setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n      this.view = {\n        fullWidth: fullWidth,\n        fullHeight: fullHeight,\n        offsetX: x,\n        offsetY: y,\n        width: width,\n        height: height\n      };\n\n      this.updateProjectionMatrix();\n\n    },\n\n    clearViewOffset: function() {\n\n      this.view = null;\n      this.updateProjectionMatrix();\n\n    },\n\n    updateProjectionMatrix: function () {\n\n      var dx = ( this.right - this.left ) / ( 2 * this.zoom );\n      var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n      var cx = ( this.right + this.left ) / 2;\n      var cy = ( this.top + this.bottom ) / 2;\n\n      var left = cx - dx;\n      var right = cx + dx;\n      var top = cy + dy;\n      var bottom = cy - dy;\n\n      if ( this.view !== null ) {\n\n        var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n        var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n        var scaleW = ( this.right - this.left ) / this.view.width;\n        var scaleH = ( this.top - this.bottom ) / this.view.height;\n\n        left += scaleW * ( this.view.offsetX / zoomW );\n        right = left + scaleW * ( this.view.width / zoomW );\n        top -= scaleH * ( this.view.offsetY / zoomH );\n        bottom = top - scaleH * ( this.view.height / zoomH );\n\n      }\n\n      this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n    },\n\n    toJSON: function ( meta ) {\n\n      var data = Object3D.prototype.toJSON.call( this, meta );\n\n      data.object.zoom = this.zoom;\n      data.object.left = this.left;\n      data.object.right = this.right;\n      data.object.top = this.top;\n      data.object.bottom = this.bottom;\n      data.object.near = this.near;\n      data.object.far = this.far;\n\n      if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n      return data;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\n\n    var mode;\n\n    function setMode( value ) {\n\n      mode = value;\n\n    }\n\n    var type, size;\n\n    function setIndex( index ) {\n\n      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n        type = gl.UNSIGNED_INT;\n        size = 4;\n\n      } else if ( index.array instanceof Uint16Array ) {\n\n        type = gl.UNSIGNED_SHORT;\n        size = 2;\n\n      } else {\n\n        type = gl.UNSIGNED_BYTE;\n        size = 1;\n\n      }\n\n    }\n\n    function render( start, count ) {\n\n      gl.drawElements( mode, count, type, start * size );\n\n      infoRender.calls ++;\n      infoRender.vertices += count;\n\n      if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n    }\n\n    function renderInstances( geometry, start, count ) {\n\n      var extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n      if ( extension === null ) {\n\n        console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n        return;\n\n      }\n\n      extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n      infoRender.calls ++;\n      infoRender.vertices += count * geometry.maxInstancedCount;\n\n      if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n    }\n\n    return {\n\n      setMode: setMode,\n      setIndex: setIndex,\n      render: render,\n      renderInstances: renderInstances\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLBufferRenderer( gl, extensions, infoRender ) {\n\n    var mode;\n\n    function setMode( value ) {\n\n      mode = value;\n\n    }\n\n    function render( start, count ) {\n\n      gl.drawArrays( mode, start, count );\n\n      infoRender.calls ++;\n      infoRender.vertices += count;\n\n      if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\n\n    }\n\n    function renderInstances( geometry ) {\n\n      var extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n      if ( extension === null ) {\n\n        console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n        return;\n\n      }\n\n      var position = geometry.attributes.position;\n\n      var count = 0;\n\n      if ( position.isInterleavedBufferAttribute ) {\n\n        count = position.data.count;\n\n        extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n      } else {\n\n        count = position.count;\n\n        extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n      }\n\n      infoRender.calls ++;\n      infoRender.vertices += count * geometry.maxInstancedCount;\n\n      if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n    }\n\n    return {\n      setMode: setMode,\n      render: render,\n      renderInstances: renderInstances\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLLights() {\n\n    var lights = {};\n\n    return {\n\n      get: function ( light ) {\n\n        if ( lights[ light.id ] !== undefined ) {\n\n          return lights[ light.id ];\n\n        }\n\n        var uniforms;\n\n        switch ( light.type ) {\n\n          case 'DirectionalLight':\n            uniforms = {\n              direction: new Vector3(),\n              color: new Color(),\n\n              shadow: false,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new Vector2()\n            };\n            break;\n\n          case 'SpotLight':\n            uniforms = {\n              position: new Vector3(),\n              direction: new Vector3(),\n              color: new Color(),\n              distance: 0,\n              coneCos: 0,\n              penumbraCos: 0,\n              decay: 0,\n\n              shadow: false,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new Vector2()\n            };\n            break;\n\n          case 'PointLight':\n            uniforms = {\n              position: new Vector3(),\n              color: new Color(),\n              distance: 0,\n              decay: 0,\n\n              shadow: false,\n              shadowBias: 0,\n              shadowRadius: 1,\n              shadowMapSize: new Vector2()\n            };\n            break;\n\n          case 'HemisphereLight':\n            uniforms = {\n              direction: new Vector3(),\n              skyColor: new Color(),\n              groundColor: new Color()\n            };\n            break;\n\n          case 'RectAreaLight':\n            uniforms = {\n              color: new Color(),\n              position: new Vector3(),\n              halfWidth: new Vector3(),\n              halfHeight: new Vector3()\n              // TODO (abelnation): set RectAreaLight shadow uniforms\n            };\n            break;\n\n        }\n\n        lights[ light.id ] = uniforms;\n\n        return uniforms;\n\n      }\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function addLineNumbers( string ) {\n\n    var lines = string.split( '\\n' );\n\n    for ( var i = 0; i < lines.length; i ++ ) {\n\n      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n    }\n\n    return lines.join( '\\n' );\n\n  }\n\n  function WebGLShader( gl, type, string ) {\n\n    var shader = gl.createShader( type );\n\n    gl.shaderSource( shader, string );\n    gl.compileShader( shader );\n\n    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n      console.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n    }\n\n    if ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n    }\n\n    // --enable-privileged-webgl-extension\n    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n    return shader;\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  var programIdCount = 0;\n\n  function getEncodingComponents( encoding ) {\n\n    switch ( encoding ) {\n\n      case LinearEncoding:\n        return [ 'Linear','( value )' ];\n      case sRGBEncoding:\n        return [ 'sRGB','( value )' ];\n      case RGBEEncoding:\n        return [ 'RGBE','( value )' ];\n      case RGBM7Encoding:\n        return [ 'RGBM','( value, 7.0 )' ];\n      case RGBM16Encoding:\n        return [ 'RGBM','( value, 16.0 )' ];\n      case RGBDEncoding:\n        return [ 'RGBD','( value, 256.0 )' ];\n      case GammaEncoding:\n        return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n      default:\n        throw new Error( 'unsupported encoding: ' + encoding );\n\n    }\n\n  }\n\n  function getTexelDecodingFunction( functionName, encoding ) {\n\n    var components = getEncodingComponents( encoding );\n    return \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n  }\n\n  function getTexelEncodingFunction( functionName, encoding ) {\n\n    var components = getEncodingComponents( encoding );\n    return \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n  }\n\n  function getToneMappingFunction( functionName, toneMapping ) {\n\n    var toneMappingName;\n\n    switch ( toneMapping ) {\n\n      case LinearToneMapping:\n        toneMappingName = \"Linear\";\n        break;\n\n      case ReinhardToneMapping:\n        toneMappingName = \"Reinhard\";\n        break;\n\n      case Uncharted2ToneMapping:\n        toneMappingName = \"Uncharted2\";\n        break;\n\n      case CineonToneMapping:\n        toneMappingName = \"OptimizedCineon\";\n        break;\n\n      default:\n        throw new Error( 'unsupported toneMapping: ' + toneMapping );\n\n    }\n\n    return \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n  }\n\n  function generateExtensions( extensions, parameters, rendererExtensions ) {\n\n    extensions = extensions || {};\n\n    var chunks = [\n      ( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n      ( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n      ( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n      ( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n    ];\n\n    return chunks.filter( filterEmptyLine ).join( '\\n' );\n\n  }\n\n  function generateDefines( defines ) {\n\n    var chunks = [];\n\n    for ( var name in defines ) {\n\n      var value = defines[ name ];\n\n      if ( value === false ) continue;\n\n      chunks.push( '#define ' + name + ' ' + value );\n\n    }\n\n    return chunks.join( '\\n' );\n\n  }\n\n  function fetchAttributeLocations( gl, program, identifiers ) {\n\n    var attributes = {};\n\n    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n    for ( var i = 0; i < n; i ++ ) {\n\n      var info = gl.getActiveAttrib( program, i );\n      var name = info.name;\n\n      // console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n      attributes[ name ] = gl.getAttribLocation( program, name );\n\n    }\n\n    return attributes;\n\n  }\n\n  function filterEmptyLine( string ) {\n\n    return string !== '';\n\n  }\n\n  function replaceLightNums( string, parameters ) {\n\n    return string\n      .replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n      .replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n      .replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n      .replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n      .replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n  }\n\n  function parseIncludes( string ) {\n\n    var pattern = /#include +<([\\w\\d.]+)>/g;\n\n    function replace( match, include ) {\n\n      var replace = ShaderChunk[ include ];\n\n      if ( replace === undefined ) {\n\n        throw new Error( 'Can not resolve #include <' + include + '>' );\n\n      }\n\n      return parseIncludes( replace );\n\n    }\n\n    return string.replace( pattern, replace );\n\n  }\n\n  function unrollLoops( string ) {\n\n    var pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n    function replace( match, start, end, snippet ) {\n\n      var unroll = '';\n\n      for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n        unroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n      }\n\n      return unroll;\n\n    }\n\n    return string.replace( pattern, replace );\n\n  }\n\n  function WebGLProgram( renderer, code, material, parameters ) {\n\n    var gl = renderer.context;\n\n    var extensions = material.extensions;\n    var defines = material.defines;\n\n    var vertexShader = material.__webglShader.vertexShader;\n    var fragmentShader = material.__webglShader.fragmentShader;\n\n    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n    if ( parameters.shadowMapType === PCFShadowMap ) {\n\n      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n    } else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n    }\n\n    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n    if ( parameters.envMap ) {\n\n      switch ( material.envMap.mapping ) {\n\n        case CubeReflectionMapping:\n        case CubeRefractionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n          break;\n\n        case CubeUVReflectionMapping:\n        case CubeUVRefractionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n          break;\n\n        case EquirectangularReflectionMapping:\n        case EquirectangularRefractionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n          break;\n\n        case SphericalReflectionMapping:\n          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n          break;\n\n      }\n\n      switch ( material.envMap.mapping ) {\n\n        case CubeRefractionMapping:\n        case EquirectangularRefractionMapping:\n          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n          break;\n\n      }\n\n      switch ( material.combine ) {\n\n        case MultiplyOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n          break;\n\n        case MixOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n          break;\n\n        case AddOperation:\n          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n          break;\n\n      }\n\n    }\n\n    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n    // console.log( 'building new program ' );\n\n    //\n\n    var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n    var customDefines = generateDefines( defines );\n\n    //\n\n    var program = gl.createProgram();\n\n    var prefixVertex, prefixFragment;\n\n    if ( material.isRawShaderMaterial ) {\n\n      prefixVertex = [\n\n        customDefines,\n\n        '\\n'\n\n      ].filter( filterEmptyLine ).join( '\\n' );\n\n      prefixFragment = [\n\n        customExtensions,\n        customDefines,\n\n        '\\n'\n\n      ].filter( filterEmptyLine ).join( '\\n' );\n\n    } else {\n\n      prefixVertex = [\n\n\n        'precision ' + parameters.precision + ' float;',\n        'precision ' + parameters.precision + ' int;',\n\n        '#define SHADER_NAME ' + material.__webglShader.name,\n\n        customDefines,\n\n        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n        '#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n        '#define MAX_BONES ' + parameters.maxBones,\n        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\n        parameters.map ? '#define USE_MAP' : '',\n        parameters.envMap ? '#define USE_ENVMAP' : '',\n        parameters.envMap ? '#define ' + envMapModeDefine : '',\n        parameters.lightMap ? '#define USE_LIGHTMAP' : '',\n        parameters.aoMap ? '#define USE_AOMAP' : '',\n        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n        parameters.bumpMap ? '#define USE_BUMPMAP' : '',\n        parameters.normalMap ? '#define USE_NORMALMAP' : '',\n        parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n        parameters.specularMap ? '#define USE_SPECULARMAP' : '',\n        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n        parameters.vertexColors ? '#define USE_COLOR' : '',\n\n        parameters.flatShading ? '#define FLAT_SHADED' : '',\n\n        parameters.skinning ? '#define USE_SKINNING' : '',\n        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n        parameters.flipSided ? '#define FLIP_SIDED' : '',\n\n        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n        'uniform mat4 modelMatrix;',\n        'uniform mat4 modelViewMatrix;',\n        'uniform mat4 projectionMatrix;',\n        'uniform mat4 viewMatrix;',\n        'uniform mat3 normalMatrix;',\n        'uniform vec3 cameraPosition;',\n\n        'attribute vec3 position;',\n        'attribute vec3 normal;',\n        'attribute vec2 uv;',\n\n        '#ifdef USE_COLOR',\n\n        ' attribute vec3 color;',\n\n        '#endif',\n\n        '#ifdef USE_MORPHTARGETS',\n\n        ' attribute vec3 morphTarget0;',\n        ' attribute vec3 morphTarget1;',\n        ' attribute vec3 morphTarget2;',\n        ' attribute vec3 morphTarget3;',\n\n        ' #ifdef USE_MORPHNORMALS',\n\n        '   attribute vec3 morphNormal0;',\n        '   attribute vec3 morphNormal1;',\n        '   attribute vec3 morphNormal2;',\n        '   attribute vec3 morphNormal3;',\n\n        ' #else',\n\n        '   attribute vec3 morphTarget4;',\n        '   attribute vec3 morphTarget5;',\n        '   attribute vec3 morphTarget6;',\n        '   attribute vec3 morphTarget7;',\n\n        ' #endif',\n\n        '#endif',\n\n        '#ifdef USE_SKINNING',\n\n        ' attribute vec4 skinIndex;',\n        ' attribute vec4 skinWeight;',\n\n        '#endif',\n\n        '\\n'\n\n      ].filter( filterEmptyLine ).join( '\\n' );\n\n      prefixFragment = [\n\n        customExtensions,\n\n        'precision ' + parameters.precision + ' float;',\n        'precision ' + parameters.precision + ' int;',\n\n        '#define SHADER_NAME ' + material.__webglShader.name,\n\n        customDefines,\n\n        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n        '#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n        parameters.map ? '#define USE_MAP' : '',\n        parameters.envMap ? '#define USE_ENVMAP' : '',\n        parameters.envMap ? '#define ' + envMapTypeDefine : '',\n        parameters.envMap ? '#define ' + envMapModeDefine : '',\n        parameters.envMap ? '#define ' + envMapBlendingDefine : '',\n        parameters.lightMap ? '#define USE_LIGHTMAP' : '',\n        parameters.aoMap ? '#define USE_AOMAP' : '',\n        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n        parameters.bumpMap ? '#define USE_BUMPMAP' : '',\n        parameters.normalMap ? '#define USE_NORMALMAP' : '',\n        parameters.specularMap ? '#define USE_SPECULARMAP' : '',\n        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n        parameters.vertexColors ? '#define USE_COLOR' : '',\n\n        parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n        parameters.flatShading ? '#define FLAT_SHADED' : '',\n\n        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n        parameters.flipSided ? '#define FLIP_SIDED' : '',\n\n        '#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n        '#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),\n\n        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n        parameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n        parameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n        parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n        'uniform mat4 viewMatrix;',\n        'uniform vec3 cameraPosition;',\n\n        ( parameters.toneMapping !== NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n        ( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n        ( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n        ( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n        parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n        parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n        parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n        parameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n        parameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n        '\\n'\n\n      ].filter( filterEmptyLine ).join( '\\n' );\n\n    }\n\n    vertexShader = parseIncludes( vertexShader, parameters );\n    vertexShader = replaceLightNums( vertexShader, parameters );\n\n    fragmentShader = parseIncludes( fragmentShader, parameters );\n    fragmentShader = replaceLightNums( fragmentShader, parameters );\n\n    if ( ! material.isShaderMaterial ) {\n\n      vertexShader = unrollLoops( vertexShader );\n      fragmentShader = unrollLoops( fragmentShader );\n\n    }\n\n    var vertexGlsl = prefixVertex + vertexShader;\n    var fragmentGlsl = prefixFragment + fragmentShader;\n\n    // console.log( '*VERTEX*', vertexGlsl );\n    // console.log( '*FRAGMENT*', fragmentGlsl );\n\n    var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n    var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n    gl.attachShader( program, glVertexShader );\n    gl.attachShader( program, glFragmentShader );\n\n    // Force a particular attribute to index 0.\n\n    if ( material.index0AttributeName !== undefined ) {\n\n      gl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n    } else if ( parameters.morphTargets === true ) {\n\n      // programs with morphTargets displace position out of attribute 0\n      gl.bindAttribLocation( program, 0, 'position' );\n\n    }\n\n    gl.linkProgram( program );\n\n    var programLog = gl.getProgramInfoLog( program );\n    var vertexLog = gl.getShaderInfoLog( glVertexShader );\n    var fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n    var runnable = true;\n    var haveDiagnostics = true;\n\n    // console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n    // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n      runnable = false;\n\n      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n    } else if ( programLog !== '' ) {\n\n      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n    } else if ( vertexLog === '' || fragmentLog === '' ) {\n\n      haveDiagnostics = false;\n\n    }\n\n    if ( haveDiagnostics ) {\n\n      this.diagnostics = {\n\n        runnable: runnable,\n        material: material,\n\n        programLog: programLog,\n\n        vertexShader: {\n\n          log: vertexLog,\n          prefix: prefixVertex\n\n        },\n\n        fragmentShader: {\n\n          log: fragmentLog,\n          prefix: prefixFragment\n\n        }\n\n      };\n\n    }\n\n    // clean up\n\n    gl.deleteShader( glVertexShader );\n    gl.deleteShader( glFragmentShader );\n\n    // set up caching for uniform locations\n\n    var cachedUniforms;\n\n    this.getUniforms = function() {\n\n      if ( cachedUniforms === undefined ) {\n\n        cachedUniforms =\n          new WebGLUniforms( gl, program, renderer );\n\n      }\n\n      return cachedUniforms;\n\n    };\n\n    // set up caching for attribute locations\n\n    var cachedAttributes;\n\n    this.getAttributes = function() {\n\n      if ( cachedAttributes === undefined ) {\n\n        cachedAttributes = fetchAttributeLocations( gl, program );\n\n      }\n\n      return cachedAttributes;\n\n    };\n\n    // free resource\n\n    this.destroy = function() {\n\n      gl.deleteProgram( program );\n      this.program = undefined;\n\n    };\n\n    // DEPRECATED\n\n    Object.defineProperties( this, {\n\n      uniforms: {\n        get: function() {\n\n          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n          return this.getUniforms();\n\n        }\n      },\n\n      attributes: {\n        get: function() {\n\n          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n          return this.getAttributes();\n\n        }\n      }\n\n    } );\n\n\n    //\n\n    this.id = programIdCount ++;\n    this.code = code;\n    this.usedTimes = 1;\n    this.program = program;\n    this.vertexShader = glVertexShader;\n    this.fragmentShader = glFragmentShader;\n\n    return this;\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLPrograms( renderer, capabilities ) {\n\n    var programs = [];\n\n    var shaderIDs = {\n      MeshDepthMaterial: 'depth',\n      MeshNormalMaterial: 'normal',\n      MeshBasicMaterial: 'basic',\n      MeshLambertMaterial: 'lambert',\n      MeshPhongMaterial: 'phong',\n      MeshToonMaterial: 'phong',\n      MeshStandardMaterial: 'physical',\n      MeshPhysicalMaterial: 'physical',\n      LineBasicMaterial: 'basic',\n      LineDashedMaterial: 'dashed',\n      PointsMaterial: 'points'\n    };\n\n    var parameterNames = [\n      \"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n      \"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n      \"roughnessMap\", \"metalnessMap\", \"gradientMap\",\n      \"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n      \"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n      \"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n      \"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n      \"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\", \"numRectAreaLights\",\n      \"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n      \"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"numClipIntersection\", \"depthPacking\"\n    ];\n\n\n    function allocateBones( object ) {\n\n      if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n        return 1024;\n\n      } else {\n\n        // default for when object is not specified\n        // ( for example when prebuilding shader to be used with multiple objects )\n        //\n        //  - leave some extra space for other uniforms\n        //  - limit here is ANGLE's 254 max uniform vectors\n        //    (up to 54 should be safe)\n\n        var nVertexUniforms = capabilities.maxVertexUniforms;\n        var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n        var maxBones = nVertexMatrices;\n\n        if ( object !== undefined && (object && object.isSkinnedMesh) ) {\n\n          maxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n          if ( maxBones < object.skeleton.bones.length ) {\n\n            console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n          }\n\n        }\n\n        return maxBones;\n\n      }\n\n    }\n\n    function getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n      var encoding;\n\n      if ( ! map ) {\n\n        encoding = LinearEncoding;\n\n      } else if ( map.isTexture ) {\n\n        encoding = map.encoding;\n\n      } else if ( map.isWebGLRenderTarget ) {\n\n        console.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n        encoding = map.texture.encoding;\n\n      }\n\n      // add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n      if ( encoding === LinearEncoding && gammaOverrideLinear ) {\n\n        encoding = GammaEncoding;\n\n      }\n\n      return encoding;\n\n    }\n\n    this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {\n\n      var shaderID = shaderIDs[ material.type ];\n\n      // heuristics to create shader parameters according to lights in the scene\n      // (not to blow over maxLights budget)\n\n      var maxBones = allocateBones( object );\n      var precision = renderer.getPrecision();\n\n      if ( material.precision !== null ) {\n\n        precision = capabilities.getMaxPrecision( material.precision );\n\n        if ( precision !== material.precision ) {\n\n          console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n        }\n\n      }\n\n      var currentRenderTarget = renderer.getCurrentRenderTarget();\n\n      var parameters = {\n\n        shaderID: shaderID,\n\n        precision: precision,\n        supportsVertexTextures: capabilities.vertexTextures,\n        outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n        map: !! material.map,\n        mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n        envMap: !! material.envMap,\n        envMapMode: material.envMap && material.envMap.mapping,\n        envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n        envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\n        lightMap: !! material.lightMap,\n        aoMap: !! material.aoMap,\n        emissiveMap: !! material.emissiveMap,\n        emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n        bumpMap: !! material.bumpMap,\n        normalMap: !! material.normalMap,\n        displacementMap: !! material.displacementMap,\n        roughnessMap: !! material.roughnessMap,\n        metalnessMap: !! material.metalnessMap,\n        specularMap: !! material.specularMap,\n        alphaMap: !! material.alphaMap,\n\n        gradientMap: !! material.gradientMap,\n\n        combine: material.combine,\n\n        vertexColors: material.vertexColors,\n\n        fog: !! fog,\n        useFog: material.fog,\n        fogExp: (fog && fog.isFogExp2),\n\n        flatShading: material.shading === FlatShading,\n\n        sizeAttenuation: material.sizeAttenuation,\n        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n        skinning: material.skinning,\n        maxBones: maxBones,\n        useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n        morphTargets: material.morphTargets,\n        morphNormals: material.morphNormals,\n        maxMorphTargets: renderer.maxMorphTargets,\n        maxMorphNormals: renderer.maxMorphNormals,\n\n        numDirLights: lights.directional.length,\n        numPointLights: lights.point.length,\n        numSpotLights: lights.spot.length,\n        numRectAreaLights: lights.rectArea.length,\n        numHemiLights: lights.hemi.length,\n\n        numClippingPlanes: nClipPlanes,\n        numClipIntersection: nClipIntersection,\n\n        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n        shadowMapType: renderer.shadowMap.type,\n\n        toneMapping: renderer.toneMapping,\n        physicallyCorrectLights: renderer.physicallyCorrectLights,\n\n        premultipliedAlpha: material.premultipliedAlpha,\n\n        alphaTest: material.alphaTest,\n        doubleSided: material.side === DoubleSide,\n        flipSided: material.side === BackSide,\n\n        depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n      };\n\n      return parameters;\n\n    };\n\n    this.getProgramCode = function ( material, parameters ) {\n\n      var array = [];\n\n      if ( parameters.shaderID ) {\n\n        array.push( parameters.shaderID );\n\n      } else {\n\n        array.push( material.fragmentShader );\n        array.push( material.vertexShader );\n\n      }\n\n      if ( material.defines !== undefined ) {\n\n        for ( var name in material.defines ) {\n\n          array.push( name );\n          array.push( material.defines[ name ] );\n\n        }\n\n      }\n\n      for ( var i = 0; i < parameterNames.length; i ++ ) {\n\n        array.push( parameters[ parameterNames[ i ] ] );\n\n      }\n\n      return array.join();\n\n    };\n\n    this.acquireProgram = function ( material, parameters, code ) {\n\n      var program;\n\n      // Check if code has been already compiled\n      for ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n        var programInfo = programs[ p ];\n\n        if ( programInfo.code === code ) {\n\n          program = programInfo;\n          ++ program.usedTimes;\n\n          break;\n\n        }\n\n      }\n\n      if ( program === undefined ) {\n\n        program = new WebGLProgram( renderer, code, material, parameters );\n        programs.push( program );\n\n      }\n\n      return program;\n\n    };\n\n    this.releaseProgram = function( program ) {\n\n      if ( -- program.usedTimes === 0 ) {\n\n        // Remove from unordered set\n        var i = programs.indexOf( program );\n        programs[ i ] = programs[ programs.length - 1 ];\n        programs.pop();\n\n        // Free WebGL resources\n        program.destroy();\n\n      }\n\n    };\n\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    this.programs = programs;\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLGeometries( gl, properties, info ) {\n\n    var geometries = {};\n\n    function onGeometryDispose( event ) {\n\n      var geometry = event.target;\n      var buffergeometry = geometries[ geometry.id ];\n\n      if ( buffergeometry.index !== null ) {\n\n        deleteAttribute( buffergeometry.index );\n\n      }\n\n      deleteAttributes( buffergeometry.attributes );\n\n      geometry.removeEventListener( 'dispose', onGeometryDispose );\n\n      delete geometries[ geometry.id ];\n\n      // TODO\n\n      var property = properties.get( geometry );\n\n      if ( property.wireframe ) {\n\n        deleteAttribute( property.wireframe );\n\n      }\n\n      properties.delete( geometry );\n\n      var bufferproperty = properties.get( buffergeometry );\n\n      if ( bufferproperty.wireframe ) {\n\n        deleteAttribute( bufferproperty.wireframe );\n\n      }\n\n      properties.delete( buffergeometry );\n\n      //\n\n      info.memory.geometries --;\n\n    }\n\n    function getAttributeBuffer( attribute ) {\n\n      if ( attribute.isInterleavedBufferAttribute ) {\n\n        return properties.get( attribute.data ).__webglBuffer;\n\n      }\n\n      return properties.get( attribute ).__webglBuffer;\n\n    }\n\n    function deleteAttribute( attribute ) {\n\n      var buffer = getAttributeBuffer( attribute );\n\n      if ( buffer !== undefined ) {\n\n        gl.deleteBuffer( buffer );\n        removeAttributeBuffer( attribute );\n\n      }\n\n    }\n\n    function deleteAttributes( attributes ) {\n\n      for ( var name in attributes ) {\n\n        deleteAttribute( attributes[ name ] );\n\n      }\n\n    }\n\n    function removeAttributeBuffer( attribute ) {\n\n      if ( attribute.isInterleavedBufferAttribute ) {\n\n        properties.delete( attribute.data );\n\n      } else {\n\n        properties.delete( attribute );\n\n      }\n\n    }\n\n    return {\n\n      get: function ( object ) {\n\n        var geometry = object.geometry;\n\n        if ( geometries[ geometry.id ] !== undefined ) {\n\n          return geometries[ geometry.id ];\n\n        }\n\n        geometry.addEventListener( 'dispose', onGeometryDispose );\n\n        var buffergeometry;\n\n        if ( geometry.isBufferGeometry ) {\n\n          buffergeometry = geometry;\n\n        } else if ( geometry.isGeometry ) {\n\n          if ( geometry._bufferGeometry === undefined ) {\n\n            geometry._bufferGeometry = new BufferGeometry().setFromObject( object );\n\n          }\n\n          buffergeometry = geometry._bufferGeometry;\n\n        }\n\n        geometries[ geometry.id ] = buffergeometry;\n\n        info.memory.geometries ++;\n\n        return buffergeometry;\n\n      }\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLObjects( gl, properties, info ) {\n\n    var geometries = new WebGLGeometries( gl, properties, info );\n\n    //\n\n    function update( object ) {\n\n      // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n      var geometry = geometries.get( object );\n\n      if ( object.geometry.isGeometry ) {\n\n        geometry.updateFromObject( object );\n\n      }\n\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n\n      if ( index !== null ) {\n\n        updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n      }\n\n      for ( var name in attributes ) {\n\n        updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n      }\n\n      // morph targets\n\n      var morphAttributes = geometry.morphAttributes;\n\n      for ( var name in morphAttributes ) {\n\n        var array = morphAttributes[ name ];\n\n        for ( var i = 0, l = array.length; i < l; i ++ ) {\n\n          updateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n        }\n\n      }\n\n      return geometry;\n\n    }\n\n    function updateAttribute( attribute, bufferType ) {\n\n      var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;\n\n      var attributeProperties = properties.get( data );\n\n      if ( attributeProperties.__webglBuffer === undefined ) {\n\n        createBuffer( attributeProperties, data, bufferType );\n\n      } else if ( attributeProperties.version !== data.version ) {\n\n        updateBuffer( attributeProperties, data, bufferType );\n\n      }\n\n    }\n\n    function createBuffer( attributeProperties, data, bufferType ) {\n\n      attributeProperties.__webglBuffer = gl.createBuffer();\n      gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n      var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n      gl.bufferData( bufferType, data.array, usage );\n\n      var type = gl.FLOAT;\n      var array = data.array;\n\n      if ( array instanceof Float32Array ) {\n\n        type = gl.FLOAT;\n\n      } else if ( array instanceof Float64Array ) {\n\n        console.warn( \"Unsupported data buffer format: Float64Array\" );\n\n      } else if ( array instanceof Uint16Array ) {\n\n        type = gl.UNSIGNED_SHORT;\n\n      } else if ( array instanceof Int16Array ) {\n\n        type = gl.SHORT;\n\n      } else if ( array instanceof Uint32Array ) {\n\n        type = gl.UNSIGNED_INT;\n\n      } else if ( array instanceof Int32Array ) {\n\n        type = gl.INT;\n\n      } else if ( array instanceof Int8Array ) {\n\n        type = gl.BYTE;\n\n      } else if ( array instanceof Uint8Array ) {\n\n        type = gl.UNSIGNED_BYTE;\n\n      }\n\n      attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;\n      attributeProperties.type = type;\n      attributeProperties.version = data.version;\n\n      data.onUploadCallback();\n\n    }\n\n    function updateBuffer( attributeProperties, data, bufferType ) {\n\n      gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n      if ( data.dynamic === false ) {\n\n        gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );\n\n      } else if ( data.updateRange.count === - 1 ) {\n\n        // Not using update ranges\n\n        gl.bufferSubData( bufferType, 0, data.array );\n\n      } else if ( data.updateRange.count === 0 ) {\n\n        console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n      } else {\n\n        gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n                  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n        data.updateRange.count = 0; // reset range\n\n      }\n\n      attributeProperties.version = data.version;\n\n    }\n\n    function getAttributeBuffer( attribute ) {\n\n      if ( attribute.isInterleavedBufferAttribute ) {\n\n        return properties.get( attribute.data ).__webglBuffer;\n\n      }\n\n      return properties.get( attribute ).__webglBuffer;\n\n    }\n\n    function getAttributeProperties( attribute ) {\n\n      if ( attribute.isInterleavedBufferAttribute ) {\n\n        return properties.get( attribute.data );\n\n      }\n\n      return properties.get( attribute );\n\n    }\n\n    function getWireframeAttribute( geometry ) {\n\n      var property = properties.get( geometry );\n\n      if ( property.wireframe !== undefined ) {\n\n        return property.wireframe;\n\n      }\n\n      var indices = [];\n\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n\n      // console.time( 'wireframe' );\n\n      if ( index !== null ) {\n\n        var array = index.array;\n\n        for ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n          var a = array[ i + 0 ];\n          var b = array[ i + 1 ];\n          var c = array[ i + 2 ];\n\n          indices.push( a, b, b, c, c, a );\n\n        }\n\n      } else {\n\n        var array = attributes.position.array;\n\n        for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n          var a = i + 0;\n          var b = i + 1;\n          var c = i + 2;\n\n          indices.push( a, b, b, c, c, a );\n\n        }\n\n      }\n\n      // console.timeEnd( 'wireframe' );\n\n      var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\n      updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n      property.wireframe = attribute;\n\n      return attribute;\n\n    }\n\n    return {\n\n      getAttributeBuffer: getAttributeBuffer,\n      getAttributeProperties: getAttributeProperties,\n      getWireframeAttribute: getWireframeAttribute,\n\n      update: update\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n    var _infoMemory = info.memory;\n    var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n    //\n\n    function clampToMaxSize( image, maxSize ) {\n\n      if ( image.width > maxSize || image.height > maxSize ) {\n\n        // Warning: Scaling through the canvas will only work with images that use\n        // premultiplied alpha.\n\n        var scale = maxSize / Math.max( image.width, image.height );\n\n        var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n        canvas.width = Math.floor( image.width * scale );\n        canvas.height = Math.floor( image.height * scale );\n\n        var context = canvas.getContext( '2d' );\n        context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n        console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n        return canvas;\n\n      }\n\n      return image;\n\n    }\n\n    function isPowerOfTwo( image ) {\n\n      return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\n\n    }\n\n    function makePowerOfTwo( image ) {\n\n      if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n        var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n        canvas.width = _Math.nearestPowerOfTwo( image.width );\n        canvas.height = _Math.nearestPowerOfTwo( image.height );\n\n        var context = canvas.getContext( '2d' );\n        context.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n        console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n        return canvas;\n\n      }\n\n      return image;\n\n    }\n\n    function textureNeedsPowerOfTwo( texture ) {\n\n      return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n        ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n    }\n\n    // Fallback filters for non-power-of-2 textures\n\n    function filterFallback( f ) {\n\n      if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\n\n        return _gl.NEAREST;\n\n      }\n\n      return _gl.LINEAR;\n\n    }\n\n    //\n\n    function onTextureDispose( event ) {\n\n      var texture = event.target;\n\n      texture.removeEventListener( 'dispose', onTextureDispose );\n\n      deallocateTexture( texture );\n\n      _infoMemory.textures --;\n\n\n    }\n\n    function onRenderTargetDispose( event ) {\n\n      var renderTarget = event.target;\n\n      renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n      deallocateRenderTarget( renderTarget );\n\n      _infoMemory.textures --;\n\n    }\n\n    //\n\n    function deallocateTexture( texture ) {\n\n      var textureProperties = properties.get( texture );\n\n      if ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n        // cube texture\n\n        _gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n      } else {\n\n        // 2D texture\n\n        if ( textureProperties.__webglInit === undefined ) return;\n\n        _gl.deleteTexture( textureProperties.__webglTexture );\n\n      }\n\n      // remove all webgl properties\n      properties.delete( texture );\n\n    }\n\n    function deallocateRenderTarget( renderTarget ) {\n\n      var renderTargetProperties = properties.get( renderTarget );\n      var textureProperties = properties.get( renderTarget.texture );\n\n      if ( ! renderTarget ) return;\n\n      if ( textureProperties.__webglTexture !== undefined ) {\n\n        _gl.deleteTexture( textureProperties.__webglTexture );\n\n      }\n\n      if ( renderTarget.depthTexture ) {\n\n        renderTarget.depthTexture.dispose();\n\n      }\n\n      if ( renderTarget.isWebGLRenderTargetCube ) {\n\n        for ( var i = 0; i < 6; i ++ ) {\n\n          _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n          if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n        }\n\n      } else {\n\n        _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n        if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n      }\n\n      properties.delete( renderTarget.texture );\n      properties.delete( renderTarget );\n\n    }\n\n    //\n\n\n\n    function setTexture2D( texture, slot ) {\n\n      var textureProperties = properties.get( texture );\n\n      if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n        var image = texture.image;\n\n        if ( image === undefined ) {\n\n          console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n        } else if ( image.complete === false ) {\n\n          console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n        } else {\n\n          uploadTexture( textureProperties, texture, slot );\n          return;\n\n        }\n\n      }\n\n      state.activeTexture( _gl.TEXTURE0 + slot );\n      state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n    }\n\n    function setTextureCube( texture, slot ) {\n\n      var textureProperties = properties.get( texture );\n\n      if ( texture.image.length === 6 ) {\n\n        if ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n          if ( ! textureProperties.__image__webglTextureCube ) {\n\n            texture.addEventListener( 'dispose', onTextureDispose );\n\n            textureProperties.__image__webglTextureCube = _gl.createTexture();\n\n            _infoMemory.textures ++;\n\n          }\n\n          state.activeTexture( _gl.TEXTURE0 + slot );\n          state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n          _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n          var isCompressed = ( texture && texture.isCompressedTexture );\n          var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n          var cubeImage = [];\n\n          for ( var i = 0; i < 6; i ++ ) {\n\n            if ( ! isCompressed && ! isDataTexture ) {\n\n              cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n            } else {\n\n              cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n            }\n\n          }\n\n          var image = cubeImage[ 0 ],\n          isPowerOfTwoImage = isPowerOfTwo( image ),\n          glFormat = paramThreeToGL( texture.format ),\n          glType = paramThreeToGL( texture.type );\n\n          setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n          for ( var i = 0; i < 6; i ++ ) {\n\n            if ( ! isCompressed ) {\n\n              if ( isDataTexture ) {\n\n                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n              } else {\n\n                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n              }\n\n            } else {\n\n              var mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n              for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n                mipmap = mipmaps[ j ];\n\n                if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n                  if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n                    state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n                  } else {\n\n                    console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n                  }\n\n                } else {\n\n                  state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n                }\n\n              }\n\n            }\n\n          }\n\n          if ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n            _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n          }\n\n          textureProperties.__version = texture.version;\n\n          if ( texture.onUpdate ) texture.onUpdate( texture );\n\n        } else {\n\n          state.activeTexture( _gl.TEXTURE0 + slot );\n          state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n        }\n\n      }\n\n    }\n\n    function setTextureCubeDynamic( texture, slot ) {\n\n      state.activeTexture( _gl.TEXTURE0 + slot );\n      state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n    }\n\n    function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\n\n      var extension;\n\n      if ( isPowerOfTwoImage ) {\n\n        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n        _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n        _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n      } else {\n\n        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n        _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n        if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n          console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n        }\n\n        _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n        _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n        if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n          console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n        }\n\n      }\n\n      extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n      if ( extension ) {\n\n        if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n        if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n        if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n          _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n          properties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n        }\n\n      }\n\n    }\n\n    function uploadTexture( textureProperties, texture, slot ) {\n\n      if ( textureProperties.__webglInit === undefined ) {\n\n        textureProperties.__webglInit = true;\n\n        texture.addEventListener( 'dispose', onTextureDispose );\n\n        textureProperties.__webglTexture = _gl.createTexture();\n\n        _infoMemory.textures ++;\n\n      }\n\n      state.activeTexture( _gl.TEXTURE0 + slot );\n      state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n      _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n      _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n      _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n      var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n      if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n        image = makePowerOfTwo( image );\n\n      }\n\n      var isPowerOfTwoImage = isPowerOfTwo( image ),\n      glFormat = paramThreeToGL( texture.format ),\n      glType = paramThreeToGL( texture.type );\n\n      setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n      var mipmap, mipmaps = texture.mipmaps;\n\n      if ( texture.isDepthTexture ) {\n\n        // populate depth texture with dummy data\n\n        var internalFormat = _gl.DEPTH_COMPONENT;\n\n        if ( texture.type === FloatType ) {\n\n          if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n          internalFormat = _gl.DEPTH_COMPONENT32F;\n\n        } else if ( _isWebGL2 ) {\n\n          // WebGL 2.0 requires signed internalformat for glTexImage2D\n          internalFormat = _gl.DEPTH_COMPONENT16;\n\n        }\n\n        if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\n\n          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n          // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n          if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n                  console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n            texture.type = UnsignedShortType;\n            glType = paramThreeToGL( texture.type );\n\n          }\n\n        }\n\n        // Depth stencil textures need the DEPTH_STENCIL internal format\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        if ( texture.format === DepthStencilFormat ) {\n\n          internalFormat = _gl.DEPTH_STENCIL;\n\n          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n          // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n          if ( texture.type !== UnsignedInt248Type ) {\n\n                  console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n            texture.type = UnsignedInt248Type;\n            glType = paramThreeToGL( texture.type );\n\n          }\n\n        }\n\n        state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n      } else if ( texture.isDataTexture ) {\n\n        // use manually created mipmaps if available\n        // if there are no manual mipmaps\n        // set 0 level mipmap and then use GL to generate other mipmap levels\n\n        if ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n          for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n            mipmap = mipmaps[ i ];\n            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n          }\n\n          texture.generateMipmaps = false;\n\n        } else {\n\n          state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n        }\n\n      } else if ( texture.isCompressedTexture ) {\n\n        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n          mipmap = mipmaps[ i ];\n\n          if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\n\n            if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n              state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n            } else {\n\n              console.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n            }\n\n          } else {\n\n            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n          }\n\n        }\n\n      } else {\n\n        // regular Texture (image, video, canvas)\n\n        // use manually created mipmaps if available\n        // if there are no manual mipmaps\n        // set 0 level mipmap and then use GL to generate other mipmap levels\n\n        if ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n          for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n            mipmap = mipmaps[ i ];\n            state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n          }\n\n          texture.generateMipmaps = false;\n\n        } else {\n\n          state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n        }\n\n      }\n\n      if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n      textureProperties.__version = texture.version;\n\n      if ( texture.onUpdate ) texture.onUpdate( texture );\n\n    }\n\n    // Render targets\n\n    // Setup storage for target texture and bind it to correct framebuffer\n    function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\n\n      var glFormat = paramThreeToGL( renderTarget.texture.format );\n      var glType = paramThreeToGL( renderTarget.texture.type );\n      state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n      _gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n    }\n\n    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n    function setupRenderBufferStorage( renderbuffer, renderTarget ) {\n\n      _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n      if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n      } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n        _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n      } else {\n\n        // FIXME: We don't support !depth !stencil\n        _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n      }\n\n      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n    }\n\n    // Setup resources for a Depth Texture for a FBO (needs an extension)\n    function setupDepthTexture( framebuffer, renderTarget ) {\n\n      var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n      if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n      if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n        throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n      }\n\n      // upload an empty depth texture with framebuffer size\n      if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n          renderTarget.depthTexture.image.width !== renderTarget.width ||\n          renderTarget.depthTexture.image.height !== renderTarget.height ) {\n        renderTarget.depthTexture.image.width = renderTarget.width;\n        renderTarget.depthTexture.image.height = renderTarget.height;\n        renderTarget.depthTexture.needsUpdate = true;\n      }\n\n      setTexture2D( renderTarget.depthTexture, 0 );\n\n      var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\n      if ( renderTarget.depthTexture.format === DepthFormat ) {\n\n        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n      } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n      } else {\n\n        throw new Error('Unknown depthTexture format')\n\n      }\n\n    }\n\n    // Setup GL resources for a non-texture depth buffer\n    function setupDepthRenderbuffer( renderTarget ) {\n\n      var renderTargetProperties = properties.get( renderTarget );\n\n      var isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n\n      if ( renderTarget.depthTexture ) {\n\n        if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n        setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n      } else {\n\n        if ( isCube ) {\n\n          renderTargetProperties.__webglDepthbuffer = [];\n\n          for ( var i = 0; i < 6; i ++ ) {\n\n            _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n            renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n            setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n          }\n\n        } else {\n\n          _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n          setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n        }\n\n      }\n\n      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n    }\n\n    // Set up GL resources for the render target\n    function setupRenderTarget( renderTarget ) {\n\n      var renderTargetProperties = properties.get( renderTarget );\n      var textureProperties = properties.get( renderTarget.texture );\n\n      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n      textureProperties.__webglTexture = _gl.createTexture();\n\n      _infoMemory.textures ++;\n\n      var isCube = ( renderTarget.isWebGLRenderTargetCube === true );\n      var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n      // Setup framebuffer\n\n      if ( isCube ) {\n\n        renderTargetProperties.__webglFramebuffer = [];\n\n        for ( var i = 0; i < 6; i ++ ) {\n\n          renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n        }\n\n      } else {\n\n        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n      }\n\n      // Setup color buffer\n\n      if ( isCube ) {\n\n        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n        for ( var i = 0; i < 6; i ++ ) {\n\n          setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n        }\n\n        if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n        state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n      } else {\n\n        state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n        setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n        setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n        if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n        state.bindTexture( _gl.TEXTURE_2D, null );\n\n      }\n\n      // Setup depth and stencil buffers\n\n      if ( renderTarget.depthBuffer ) {\n\n        setupDepthRenderbuffer( renderTarget );\n\n      }\n\n    }\n\n    function updateRenderTargetMipmap( renderTarget ) {\n\n      var texture = renderTarget.texture;\n\n      if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n          texture.minFilter !== NearestFilter &&\n          texture.minFilter !== LinearFilter ) {\n\n        var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n        var webglTexture = properties.get( texture ).__webglTexture;\n\n        state.bindTexture( target, webglTexture );\n        _gl.generateMipmap( target );\n        state.bindTexture( target, null );\n\n      }\n\n    }\n\n    this.setTexture2D = setTexture2D;\n    this.setTextureCube = setTextureCube;\n    this.setTextureCubeDynamic = setTextureCubeDynamic;\n    this.setupRenderTarget = setupRenderTarget;\n    this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n  }\n\n  /**\n   * @author fordacious / fordacious.github.io\n   */\n\n  function WebGLProperties() {\n\n    var properties = {};\n\n    return {\n\n      get: function ( object ) {\n\n        var uuid = object.uuid;\n        var map = properties[ uuid ];\n\n        if ( map === undefined ) {\n\n          map = {};\n          properties[ uuid ] = map;\n\n        }\n\n        return map;\n\n      },\n\n      delete: function ( object ) {\n\n        delete properties[ object.uuid ];\n\n      },\n\n      clear: function () {\n\n        properties = {};\n\n      }\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLState( gl, extensions, paramThreeToGL ) {\n\n    function ColorBuffer() {\n\n      var locked = false;\n\n      var color = new Vector4();\n      var currentColorMask = null;\n      var currentColorClear = new Vector4();\n\n      return {\n\n        setMask: function ( colorMask ) {\n\n          if ( currentColorMask !== colorMask && ! locked ) {\n\n            gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n            currentColorMask = colorMask;\n\n          }\n\n        },\n\n        setLocked: function ( lock ) {\n\n          locked = lock;\n\n        },\n\n        setClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n          if ( premultipliedAlpha === true ) {\n\n            r *= a; g *= a; b *= a;\n\n          }\n\n          color.set( r, g, b, a );\n\n          if ( currentColorClear.equals( color ) === false ) {\n\n            gl.clearColor( r, g, b, a );\n            currentColorClear.copy( color );\n\n          }\n\n        },\n\n        reset: function () {\n\n          locked = false;\n\n          currentColorMask = null;\n          currentColorClear.set( 0, 0, 0, 1 );\n\n        }\n\n      };\n\n    }\n\n    function DepthBuffer() {\n\n      var locked = false;\n\n      var currentDepthMask = null;\n      var currentDepthFunc = null;\n      var currentDepthClear = null;\n\n      return {\n\n        setTest: function ( depthTest ) {\n\n          if ( depthTest ) {\n\n            enable( gl.DEPTH_TEST );\n\n          } else {\n\n            disable( gl.DEPTH_TEST );\n\n          }\n\n        },\n\n        setMask: function ( depthMask ) {\n\n          if ( currentDepthMask !== depthMask && ! locked ) {\n\n            gl.depthMask( depthMask );\n            currentDepthMask = depthMask;\n\n          }\n\n        },\n\n        setFunc: function ( depthFunc ) {\n\n          if ( currentDepthFunc !== depthFunc ) {\n\n            if ( depthFunc ) {\n\n              switch ( depthFunc ) {\n\n                case NeverDepth:\n\n                  gl.depthFunc( gl.NEVER );\n                  break;\n\n                case AlwaysDepth:\n\n                  gl.depthFunc( gl.ALWAYS );\n                  break;\n\n                case LessDepth:\n\n                  gl.depthFunc( gl.LESS );\n                  break;\n\n                case LessEqualDepth:\n\n                  gl.depthFunc( gl.LEQUAL );\n                  break;\n\n                case EqualDepth:\n\n                  gl.depthFunc( gl.EQUAL );\n                  break;\n\n                case GreaterEqualDepth:\n\n                  gl.depthFunc( gl.GEQUAL );\n                  break;\n\n                case GreaterDepth:\n\n                  gl.depthFunc( gl.GREATER );\n                  break;\n\n                case NotEqualDepth:\n\n                  gl.depthFunc( gl.NOTEQUAL );\n                  break;\n\n                default:\n\n                  gl.depthFunc( gl.LEQUAL );\n\n              }\n\n            } else {\n\n              gl.depthFunc( gl.LEQUAL );\n\n            }\n\n            currentDepthFunc = depthFunc;\n\n          }\n\n        },\n\n        setLocked: function ( lock ) {\n\n          locked = lock;\n\n        },\n\n        setClear: function ( depth ) {\n\n          if ( currentDepthClear !== depth ) {\n\n            gl.clearDepth( depth );\n            currentDepthClear = depth;\n\n          }\n\n        },\n\n        reset: function () {\n\n          locked = false;\n\n          currentDepthMask = null;\n          currentDepthFunc = null;\n          currentDepthClear = null;\n\n        }\n\n      };\n\n    }\n\n    function StencilBuffer() {\n\n      var locked = false;\n\n      var currentStencilMask = null;\n      var currentStencilFunc = null;\n      var currentStencilRef = null;\n      var currentStencilFuncMask = null;\n      var currentStencilFail = null;\n      var currentStencilZFail = null;\n      var currentStencilZPass = null;\n      var currentStencilClear = null;\n\n      return {\n\n        setTest: function ( stencilTest ) {\n\n          if ( stencilTest ) {\n\n            enable( gl.STENCIL_TEST );\n\n          } else {\n\n            disable( gl.STENCIL_TEST );\n\n          }\n\n        },\n\n        setMask: function ( stencilMask ) {\n\n          if ( currentStencilMask !== stencilMask && ! locked ) {\n\n            gl.stencilMask( stencilMask );\n            currentStencilMask = stencilMask;\n\n          }\n\n        },\n\n        setFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n          if ( currentStencilFunc !== stencilFunc ||\n               currentStencilRef  !== stencilRef  ||\n               currentStencilFuncMask !== stencilMask ) {\n\n            gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n            currentStencilFunc = stencilFunc;\n            currentStencilRef = stencilRef;\n            currentStencilFuncMask = stencilMask;\n\n          }\n\n        },\n\n        setOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n          if ( currentStencilFail  !== stencilFail  ||\n               currentStencilZFail !== stencilZFail ||\n               currentStencilZPass !== stencilZPass ) {\n\n            gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n            currentStencilFail = stencilFail;\n            currentStencilZFail = stencilZFail;\n            currentStencilZPass = stencilZPass;\n\n          }\n\n        },\n\n        setLocked: function ( lock ) {\n\n          locked = lock;\n\n        },\n\n        setClear: function ( stencil ) {\n\n          if ( currentStencilClear !== stencil ) {\n\n            gl.clearStencil( stencil );\n            currentStencilClear = stencil;\n\n          }\n\n        },\n\n        reset: function () {\n\n          locked = false;\n\n          currentStencilMask = null;\n          currentStencilFunc = null;\n          currentStencilRef = null;\n          currentStencilFuncMask = null;\n          currentStencilFail = null;\n          currentStencilZFail = null;\n          currentStencilZPass = null;\n          currentStencilClear = null;\n\n        }\n\n      };\n\n    }\n\n    //\n\n    var colorBuffer = new ColorBuffer();\n    var depthBuffer = new DepthBuffer();\n    var stencilBuffer = new StencilBuffer();\n\n    var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n    var newAttributes = new Uint8Array( maxVertexAttributes );\n    var enabledAttributes = new Uint8Array( maxVertexAttributes );\n    var attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n    var capabilities = {};\n\n    var compressedTextureFormats = null;\n\n    var currentBlending = null;\n    var currentBlendEquation = null;\n    var currentBlendSrc = null;\n    var currentBlendDst = null;\n    var currentBlendEquationAlpha = null;\n    var currentBlendSrcAlpha = null;\n    var currentBlendDstAlpha = null;\n    var currentPremultipledAlpha = false;\n\n    var currentFlipSided = null;\n    var currentCullFace = null;\n\n    var currentLineWidth = null;\n\n    var currentPolygonOffsetFactor = null;\n    var currentPolygonOffsetUnits = null;\n\n    var currentScissorTest = null;\n\n    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n    var version = parseFloat( /^WebGL\\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );\n    var lineWidthAvailable = parseFloat( version ) >= 1.0;\n\n    var currentTextureSlot = null;\n    var currentBoundTextures = {};\n\n    var currentScissor = new Vector4();\n    var currentViewport = new Vector4();\n\n    function createTexture( type, target, count ) {\n\n      var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n      var texture = gl.createTexture();\n\n      gl.bindTexture( type, texture );\n      gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n      gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n      for ( var i = 0; i < count; i ++ ) {\n\n        gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n      }\n\n      return texture;\n\n    }\n\n    var emptyTextures = {};\n    emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n    emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n    //\n\n    function init() {\n\n      colorBuffer.setClear( 0, 0, 0, 1 );\n      depthBuffer.setClear( 1 );\n      stencilBuffer.setClear( 0 );\n\n      enable( gl.DEPTH_TEST );\n      setDepthFunc( LessEqualDepth );\n\n      setFlipSided( false );\n      setCullFace( CullFaceBack );\n      enable( gl.CULL_FACE );\n\n      enable( gl.BLEND );\n      setBlending( NormalBlending );\n\n    }\n\n    function initAttributes() {\n\n      for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n        newAttributes[ i ] = 0;\n\n      }\n\n    }\n\n    function enableAttribute( attribute ) {\n\n      newAttributes[ attribute ] = 1;\n\n      if ( enabledAttributes[ attribute ] === 0 ) {\n\n        gl.enableVertexAttribArray( attribute );\n        enabledAttributes[ attribute ] = 1;\n\n      }\n\n      if ( attributeDivisors[ attribute ] !== 0 ) {\n\n        var extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n        extension.vertexAttribDivisorANGLE( attribute, 0 );\n        attributeDivisors[ attribute ] = 0;\n\n      }\n\n    }\n\n    function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {\n\n      newAttributes[ attribute ] = 1;\n\n      if ( enabledAttributes[ attribute ] === 0 ) {\n\n        gl.enableVertexAttribArray( attribute );\n        enabledAttributes[ attribute ] = 1;\n\n      }\n\n      if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n        extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n        attributeDivisors[ attribute ] = meshPerAttribute;\n\n      }\n\n    }\n\n    function disableUnusedAttributes() {\n\n      for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n        if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n          gl.disableVertexAttribArray( i );\n          enabledAttributes[ i ] = 0;\n\n        }\n\n      }\n\n    }\n\n    function enable( id ) {\n\n      if ( capabilities[ id ] !== true ) {\n\n        gl.enable( id );\n        capabilities[ id ] = true;\n\n      }\n\n    }\n\n    function disable( id ) {\n\n      if ( capabilities[ id ] !== false ) {\n\n        gl.disable( id );\n        capabilities[ id ] = false;\n\n      }\n\n    }\n\n    function getCompressedTextureFormats() {\n\n      if ( compressedTextureFormats === null ) {\n\n        compressedTextureFormats = [];\n\n        if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n             extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n             extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n          var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n          for ( var i = 0; i < formats.length; i ++ ) {\n\n            compressedTextureFormats.push( formats[ i ] );\n\n          }\n\n        }\n\n      }\n\n      return compressedTextureFormats;\n\n    }\n\n    function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n      if ( blending !== NoBlending ) {\n\n        enable( gl.BLEND );\n\n      } else {\n\n        disable( gl.BLEND );\n\n      }\n\n      if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n        if ( blending === AdditiveBlending ) {\n\n          if ( premultipliedAlpha ) {\n\n            gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n            gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n          } else {\n\n            gl.blendEquation( gl.FUNC_ADD );\n            gl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n          }\n\n        } else if ( blending === SubtractiveBlending ) {\n\n          if ( premultipliedAlpha ) {\n\n            gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n            gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n          } else {\n\n            gl.blendEquation( gl.FUNC_ADD );\n            gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n          }\n\n        } else if ( blending === MultiplyBlending ) {\n\n          if ( premultipliedAlpha ) {\n\n            gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n            gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n          } else {\n\n            gl.blendEquation( gl.FUNC_ADD );\n            gl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n          }\n\n        } else {\n\n          if ( premultipliedAlpha ) {\n\n            gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n            gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n          } else {\n\n            gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n            gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n          }\n\n        }\n\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n\n      }\n\n      if ( blending === CustomBlending ) {\n\n        blendEquationAlpha = blendEquationAlpha || blendEquation;\n        blendSrcAlpha = blendSrcAlpha || blendSrc;\n        blendDstAlpha = blendDstAlpha || blendDst;\n\n        if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n          gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n          currentBlendEquation = blendEquation;\n          currentBlendEquationAlpha = blendEquationAlpha;\n\n        }\n\n        if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n          gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n          currentBlendSrc = blendSrc;\n          currentBlendDst = blendDst;\n          currentBlendSrcAlpha = blendSrcAlpha;\n          currentBlendDstAlpha = blendDstAlpha;\n\n        }\n\n      } else {\n\n        currentBlendEquation = null;\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendEquationAlpha = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n\n      }\n\n    }\n\n    // TODO Deprecate\n\n    function setColorWrite( colorWrite ) {\n\n      colorBuffer.setMask( colorWrite );\n\n    }\n\n    function setDepthTest( depthTest ) {\n\n      depthBuffer.setTest( depthTest );\n\n    }\n\n    function setDepthWrite( depthWrite ) {\n\n      depthBuffer.setMask( depthWrite );\n\n    }\n\n    function setDepthFunc( depthFunc ) {\n\n      depthBuffer.setFunc( depthFunc );\n\n    }\n\n    function setStencilTest( stencilTest ) {\n\n      stencilBuffer.setTest( stencilTest );\n\n    }\n\n    function setStencilWrite( stencilWrite ) {\n\n      stencilBuffer.setMask( stencilWrite );\n\n    }\n\n    function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {\n\n      stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );\n\n    }\n\n    function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {\n\n      stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );\n\n    }\n\n    //\n\n    function setFlipSided( flipSided ) {\n\n      if ( currentFlipSided !== flipSided ) {\n\n        if ( flipSided ) {\n\n          gl.frontFace( gl.CW );\n\n        } else {\n\n          gl.frontFace( gl.CCW );\n\n        }\n\n        currentFlipSided = flipSided;\n\n      }\n\n    }\n\n    function setCullFace( cullFace ) {\n\n      if ( cullFace !== CullFaceNone ) {\n\n        enable( gl.CULL_FACE );\n\n        if ( cullFace !== currentCullFace ) {\n\n          if ( cullFace === CullFaceBack ) {\n\n            gl.cullFace( gl.BACK );\n\n          } else if ( cullFace === CullFaceFront ) {\n\n            gl.cullFace( gl.FRONT );\n\n          } else {\n\n            gl.cullFace( gl.FRONT_AND_BACK );\n\n          }\n\n        }\n\n      } else {\n\n        disable( gl.CULL_FACE );\n\n      }\n\n      currentCullFace = cullFace;\n\n    }\n\n    function setLineWidth( width ) {\n\n      if ( width !== currentLineWidth ) {\n\n        if ( lineWidthAvailable ) gl.lineWidth( width );\n\n        currentLineWidth = width;\n\n      }\n\n    }\n\n    function setPolygonOffset( polygonOffset, factor, units ) {\n\n      if ( polygonOffset ) {\n\n        enable( gl.POLYGON_OFFSET_FILL );\n\n        if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n          gl.polygonOffset( factor, units );\n\n          currentPolygonOffsetFactor = factor;\n          currentPolygonOffsetUnits = units;\n\n        }\n\n      } else {\n\n        disable( gl.POLYGON_OFFSET_FILL );\n\n      }\n\n    }\n\n    function getScissorTest() {\n\n      return currentScissorTest;\n\n    }\n\n    function setScissorTest( scissorTest ) {\n\n      currentScissorTest = scissorTest;\n\n      if ( scissorTest ) {\n\n        enable( gl.SCISSOR_TEST );\n\n      } else {\n\n        disable( gl.SCISSOR_TEST );\n\n      }\n\n    }\n\n    // texture\n\n    function activeTexture( webglSlot ) {\n\n      if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n      if ( currentTextureSlot !== webglSlot ) {\n\n        gl.activeTexture( webglSlot );\n        currentTextureSlot = webglSlot;\n\n      }\n\n    }\n\n    function bindTexture( webglType, webglTexture ) {\n\n      if ( currentTextureSlot === null ) {\n\n        activeTexture();\n\n      }\n\n      var boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n      if ( boundTexture === undefined ) {\n\n        boundTexture = { type: undefined, texture: undefined };\n        currentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n      }\n\n      if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n        gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n        boundTexture.type = webglType;\n        boundTexture.texture = webglTexture;\n\n      }\n\n    }\n\n    function compressedTexImage2D() {\n\n      try {\n\n        gl.compressedTexImage2D.apply( gl, arguments );\n\n      } catch ( error ) {\n\n        console.error( error );\n\n      }\n\n    }\n\n    function texImage2D() {\n\n      try {\n\n        gl.texImage2D.apply( gl, arguments );\n\n      } catch ( error ) {\n\n        console.error( error );\n\n      }\n\n    }\n\n    //\n\n    function scissor( scissor ) {\n\n      if ( currentScissor.equals( scissor ) === false ) {\n\n        gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n        currentScissor.copy( scissor );\n\n      }\n\n    }\n\n    function viewport( viewport ) {\n\n      if ( currentViewport.equals( viewport ) === false ) {\n\n        gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n        currentViewport.copy( viewport );\n\n      }\n\n    }\n\n    //\n\n    function reset() {\n\n      for ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n        if ( enabledAttributes[ i ] === 1 ) {\n\n          gl.disableVertexAttribArray( i );\n          enabledAttributes[ i ] = 0;\n\n        }\n\n      }\n\n      capabilities = {};\n\n      compressedTextureFormats = null;\n\n      currentTextureSlot = null;\n      currentBoundTextures = {};\n\n      currentBlending = null;\n\n      currentFlipSided = null;\n      currentCullFace = null;\n\n      colorBuffer.reset();\n      depthBuffer.reset();\n      stencilBuffer.reset();\n\n    }\n\n    return {\n\n      buffers: {\n        color: colorBuffer,\n        depth: depthBuffer,\n        stencil: stencilBuffer\n      },\n\n      init: init,\n      initAttributes: initAttributes,\n      enableAttribute: enableAttribute,\n      enableAttributeAndDivisor: enableAttributeAndDivisor,\n      disableUnusedAttributes: disableUnusedAttributes,\n      enable: enable,\n      disable: disable,\n      getCompressedTextureFormats: getCompressedTextureFormats,\n\n      setBlending: setBlending,\n\n      setColorWrite: setColorWrite,\n      setDepthTest: setDepthTest,\n      setDepthWrite: setDepthWrite,\n      setDepthFunc: setDepthFunc,\n      setStencilTest: setStencilTest,\n      setStencilWrite: setStencilWrite,\n      setStencilFunc: setStencilFunc,\n      setStencilOp: setStencilOp,\n\n      setFlipSided: setFlipSided,\n      setCullFace: setCullFace,\n\n      setLineWidth: setLineWidth,\n      setPolygonOffset: setPolygonOffset,\n\n      getScissorTest: getScissorTest,\n      setScissorTest: setScissorTest,\n\n      activeTexture: activeTexture,\n      bindTexture: bindTexture,\n      compressedTexImage2D: compressedTexImage2D,\n      texImage2D: texImage2D,\n\n      scissor: scissor,\n      viewport: viewport,\n\n      reset: reset\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLCapabilities( gl, extensions, parameters ) {\n\n    var maxAnisotropy;\n\n    function getMaxAnisotropy() {\n\n      if ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n      if ( extension !== null ) {\n\n        maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n      } else {\n\n        maxAnisotropy = 0;\n\n      }\n\n      return maxAnisotropy;\n\n    }\n\n    function getMaxPrecision( precision ) {\n\n      if ( precision === 'highp' ) {\n\n        if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n             gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n          return 'highp';\n\n        }\n\n        precision = 'mediump';\n\n      }\n\n      if ( precision === 'mediump' ) {\n\n        if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n             gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n          return 'mediump';\n\n        }\n\n      }\n\n      return 'lowp';\n\n    }\n\n    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n    var maxPrecision = getMaxPrecision( precision );\n\n    if ( maxPrecision !== precision ) {\n\n      console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n      precision = maxPrecision;\n\n    }\n\n    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );\n\n    var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n    var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n    var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n    var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n    var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n    var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n    var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n    var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n    var vertexTextures = maxVertexTextures > 0;\n    var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n    var floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n    return {\n\n      getMaxAnisotropy: getMaxAnisotropy,\n      getMaxPrecision: getMaxPrecision,\n\n      precision: precision,\n      logarithmicDepthBuffer: logarithmicDepthBuffer,\n\n      maxTextures: maxTextures,\n      maxVertexTextures: maxVertexTextures,\n      maxTextureSize: maxTextureSize,\n      maxCubemapSize: maxCubemapSize,\n\n      maxAttributes: maxAttributes,\n      maxVertexUniforms: maxVertexUniforms,\n      maxVaryings: maxVaryings,\n      maxFragmentUniforms: maxFragmentUniforms,\n\n      vertexTextures: vertexTextures,\n      floatFragmentTextures: floatFragmentTextures,\n      floatVertexTextures: floatVertexTextures\n\n    };\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function WebGLExtensions( gl ) {\n\n    var extensions = {};\n\n    return {\n\n      get: function ( name ) {\n\n        if ( extensions[ name ] !== undefined ) {\n\n          return extensions[ name ];\n\n        }\n\n        var extension;\n\n        switch ( name ) {\n\n          case 'WEBGL_depth_texture':\n            extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n            break;\n\n          case 'EXT_texture_filter_anisotropic':\n            extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n            break;\n\n          case 'WEBGL_compressed_texture_s3tc':\n            extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n            break;\n\n          case 'WEBGL_compressed_texture_pvrtc':\n            extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n            break;\n\n          case 'WEBGL_compressed_texture_etc1':\n            extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n            break;\n\n          default:\n            extension = gl.getExtension( name );\n\n        }\n\n        if ( extension === null ) {\n\n          console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n        }\n\n        extensions[ name ] = extension;\n\n        return extension;\n\n      }\n\n    };\n\n  }\n\n  /**\n   * @author tschw\n   */\n\n  function WebGLClipping() {\n\n    var scope = this,\n\n      globalState = null,\n      numGlobalPlanes = 0,\n      localClippingEnabled = false,\n      renderingShadows = false,\n\n      plane = new Plane(),\n      viewNormalMatrix = new Matrix3(),\n\n      uniform = { value: null, needsUpdate: false };\n\n    this.uniform = uniform;\n    this.numPlanes = 0;\n    this.numIntersection = 0;\n\n    this.init = function( planes, enableLocalClipping, camera ) {\n\n      var enabled =\n        planes.length !== 0 ||\n        enableLocalClipping ||\n        // enable state of previous frame - the clipping code has to\n        // run another frame in order to reset the state:\n        numGlobalPlanes !== 0 ||\n        localClippingEnabled;\n\n      localClippingEnabled = enableLocalClipping;\n\n      globalState = projectPlanes( planes, camera, 0 );\n      numGlobalPlanes = planes.length;\n\n      return enabled;\n\n    };\n\n    this.beginShadows = function() {\n\n      renderingShadows = true;\n      projectPlanes( null );\n\n    };\n\n    this.endShadows = function() {\n\n      renderingShadows = false;\n      resetGlobalState();\n\n    };\n\n    this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\n\n      if ( ! localClippingEnabled ||\n          planes === null || planes.length === 0 ||\n          renderingShadows && ! clipShadows ) {\n        // there's no local clipping\n\n        if ( renderingShadows ) {\n          // there's no global clipping\n\n          projectPlanes( null );\n\n        } else {\n\n          resetGlobalState();\n        }\n\n      } else {\n\n        var nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n          lGlobal = nGlobal * 4,\n\n          dstArray = cache.clippingState || null;\n\n        uniform.value = dstArray; // ensure unique state\n\n        dstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n        for ( var i = 0; i !== lGlobal; ++ i ) {\n\n          dstArray[ i ] = globalState[ i ];\n\n        }\n\n        cache.clippingState = dstArray;\n        this.numIntersection = clipIntersection ? this.numPlanes : 0;\n        this.numPlanes += nGlobal;\n\n      }\n\n\n    };\n\n    function resetGlobalState() {\n\n      if ( uniform.value !== globalState ) {\n\n        uniform.value = globalState;\n        uniform.needsUpdate = numGlobalPlanes > 0;\n\n      }\n\n      scope.numPlanes = numGlobalPlanes;\n      scope.numIntersection = 0;\n\n    }\n\n    function projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n      var nPlanes = planes !== null ? planes.length : 0,\n        dstArray = null;\n\n      if ( nPlanes !== 0 ) {\n\n        dstArray = uniform.value;\n\n        if ( skipTransform !== true || dstArray === null ) {\n\n          var flatSize = dstOffset + nPlanes * 4,\n            viewMatrix = camera.matrixWorldInverse;\n\n          viewNormalMatrix.getNormalMatrix( viewMatrix );\n\n          if ( dstArray === null || dstArray.length < flatSize ) {\n\n            dstArray = new Float32Array( flatSize );\n\n          }\n\n          for ( var i = 0, i4 = dstOffset;\n                    i !== nPlanes; ++ i, i4 += 4 ) {\n\n            plane.copy( planes[ i ] ).\n                applyMatrix4( viewMatrix, viewNormalMatrix );\n\n            plane.normal.toArray( dstArray, i4 );\n            dstArray[ i4 + 3 ] = plane.constant;\n\n          }\n\n        }\n\n        uniform.value = dstArray;\n        uniform.needsUpdate = true;\n\n      }\n\n      scope.numPlanes = nPlanes;\n\n      return dstArray;\n\n    }\n\n  }\n\n  /**\n   * @author supereggbert / http://www.paulbrunt.co.uk/\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   * @author szimek / https://github.com/szimek/\n   * @author tschw\n   */\n\n  function WebGLRenderer( parameters ) {\n\n    console.log( 'THREE.WebGLRenderer', REVISION );\n\n    parameters = parameters || {};\n\n    var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n      _context = parameters.context !== undefined ? parameters.context : null,\n\n      _alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n      _depth = parameters.depth !== undefined ? parameters.depth : true,\n      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n    var lights = [];\n\n    var opaqueObjects = [];\n    var opaqueObjectsLastIndex = - 1;\n    var transparentObjects = [];\n    var transparentObjectsLastIndex = - 1;\n\n    var morphInfluences = new Float32Array( 8 );\n\n    var sprites = [];\n    var lensFlares = [];\n\n    // public properties\n\n    this.domElement = _canvas;\n    this.context = null;\n\n    // clearing\n\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n\n    // scene graph\n\n    this.sortObjects = true;\n\n    // user-defined clipping\n\n    this.clippingPlanes = [];\n    this.localClippingEnabled = false;\n\n    // physically based shading\n\n    this.gammaFactor = 2.0; // for backwards compatibility\n    this.gammaInput = false;\n    this.gammaOutput = false;\n\n    // physical lights\n\n    this.physicallyCorrectLights = false;\n\n    // tone mapping\n\n    this.toneMapping = LinearToneMapping;\n    this.toneMappingExposure = 1.0;\n    this.toneMappingWhitePoint = 1.0;\n\n    // morphs\n\n    this.maxMorphTargets = 8;\n    this.maxMorphNormals = 4;\n\n    // internal properties\n\n    var _this = this,\n\n      // internal state cache\n\n      _currentProgram = null,\n      _currentRenderTarget = null,\n      _currentFramebuffer = null,\n      _currentMaterialId = - 1,\n      _currentGeometryProgram = '',\n      _currentCamera = null,\n\n      _currentScissor = new Vector4(),\n      _currentScissorTest = null,\n\n      _currentViewport = new Vector4(),\n\n      //\n\n      _usedTextureUnits = 0,\n\n      //\n\n      _clearColor = new Color( 0x000000 ),\n      _clearAlpha = 0,\n\n      _width = _canvas.width,\n      _height = _canvas.height,\n\n      _pixelRatio = 1,\n\n      _scissor = new Vector4( 0, 0, _width, _height ),\n      _scissorTest = false,\n\n      _viewport = new Vector4( 0, 0, _width, _height ),\n\n      // frustum\n\n      _frustum = new Frustum(),\n\n      // clipping\n\n      _clipping = new WebGLClipping(),\n      _clippingEnabled = false,\n      _localClippingEnabled = false,\n\n      _sphere = new Sphere(),\n\n      // camera matrices cache\n\n      _projScreenMatrix = new Matrix4(),\n\n      _vector3 = new Vector3(),\n      _matrix4 = new Matrix4(),\n      _matrix42 = new Matrix4(),\n\n      // light arrays cache\n\n      _lights = {\n\n        hash: '',\n\n      ambient: [ 0, 0, 0 ],\n      directional: [],\n      directionalShadowMap: [],\n      directionalShadowMatrix: [],\n      spot: [],\n      spotShadowMap: [],\n      spotShadowMatrix: [],\n      rectArea: [],\n      point: [],\n      pointShadowMap: [],\n      pointShadowMatrix: [],\n      hemi: [],\n\n        shadows: []\n\n      },\n\n      // info\n\n      _infoRender = {\n\n        calls: 0,\n        vertices: 0,\n        faces: 0,\n        points: 0\n\n      };\n\n    this.info = {\n\n      render: _infoRender,\n      memory: {\n\n        geometries: 0,\n        textures: 0\n\n      },\n      programs: null\n\n    };\n\n\n    // initialize\n\n    var _gl;\n\n    try {\n\n      var attributes = {\n        alpha: _alpha,\n        depth: _depth,\n        stencil: _stencil,\n        antialias: _antialias,\n        premultipliedAlpha: _premultipliedAlpha,\n        preserveDrawingBuffer: _preserveDrawingBuffer\n      };\n\n      _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n      if ( _gl === null ) {\n\n        if ( _canvas.getContext( 'webgl' ) !== null ) {\n\n          throw 'Error creating WebGL context with your selected attributes.';\n\n        } else {\n\n          throw 'Error creating WebGL context.';\n\n        }\n\n      }\n\n      // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n      if ( _gl.getShaderPrecisionFormat === undefined ) {\n\n        _gl.getShaderPrecisionFormat = function () {\n\n          return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n        };\n\n      }\n\n      _canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n    } catch ( error ) {\n\n      console.error( 'THREE.WebGLRenderer: ' + error );\n\n    }\n\n    var extensions = new WebGLExtensions( _gl );\n\n    extensions.get( 'WEBGL_depth_texture' );\n    extensions.get( 'OES_texture_float' );\n    extensions.get( 'OES_texture_float_linear' );\n    extensions.get( 'OES_texture_half_float' );\n    extensions.get( 'OES_texture_half_float_linear' );\n    extensions.get( 'OES_standard_derivatives' );\n    extensions.get( 'ANGLE_instanced_arrays' );\n\n    if ( extensions.get( 'OES_element_index_uint' ) ) {\n\n      BufferGeometry.MaxIndex = 4294967296;\n\n    }\n\n    var capabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n    var state = new WebGLState( _gl, extensions, paramThreeToGL );\n    var properties = new WebGLProperties();\n    var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n    var objects = new WebGLObjects( _gl, properties, this.info );\n    var programCache = new WebGLPrograms( this, capabilities );\n    var lightCache = new WebGLLights();\n\n    this.info.programs = programCache.programs;\n\n    var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\n    var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n    //\n\n    var backgroundPlaneCamera, backgroundPlaneMesh;\n    var backgroundBoxCamera, backgroundBoxMesh;\n\n    //\n\n    function getTargetPixelRatio() {\n\n      return _currentRenderTarget === null ? _pixelRatio : 1;\n\n    }\n\n    function setDefaultGLState() {\n\n      state.init();\n\n      state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n      state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n      state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );\n\n    }\n\n    function resetGLState() {\n\n      _currentProgram = null;\n      _currentCamera = null;\n\n      _currentGeometryProgram = '';\n      _currentMaterialId = - 1;\n\n      state.reset();\n\n    }\n\n    setDefaultGLState();\n\n    this.context = _gl;\n    this.capabilities = capabilities;\n    this.extensions = extensions;\n    this.properties = properties;\n    this.state = state;\n\n    // shadow map\n\n    var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );\n\n    this.shadowMap = shadowMap;\n\n\n    // Plugins\n\n    var spritePlugin = new SpritePlugin( this, sprites );\n    var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );\n\n    // API\n\n    this.getContext = function () {\n\n      return _gl;\n\n    };\n\n    this.getContextAttributes = function () {\n\n      return _gl.getContextAttributes();\n\n    };\n\n    this.forceContextLoss = function () {\n\n      extensions.get( 'WEBGL_lose_context' ).loseContext();\n\n    };\n\n    this.getMaxAnisotropy = function () {\n\n      return capabilities.getMaxAnisotropy();\n\n    };\n\n    this.getPrecision = function () {\n\n      return capabilities.precision;\n\n    };\n\n    this.getPixelRatio = function () {\n\n      return _pixelRatio;\n\n    };\n\n    this.setPixelRatio = function ( value ) {\n\n      if ( value === undefined ) return;\n\n      _pixelRatio = value;\n\n      this.setSize( _viewport.z, _viewport.w, false );\n\n    };\n\n    this.getSize = function () {\n\n      return {\n        width: _width,\n        height: _height\n      };\n\n    };\n\n    this.setSize = function ( width, height, updateStyle ) {\n\n      _width = width;\n      _height = height;\n\n      _canvas.width = width * _pixelRatio;\n      _canvas.height = height * _pixelRatio;\n\n      if ( updateStyle !== false ) {\n\n        _canvas.style.width = width + 'px';\n        _canvas.style.height = height + 'px';\n\n      }\n\n      this.setViewport( 0, 0, width, height );\n\n    };\n\n    this.setViewport = function ( x, y, width, height ) {\n\n      state.viewport( _viewport.set( x, y, width, height ) );\n\n    };\n\n    this.setScissor = function ( x, y, width, height ) {\n\n      state.scissor( _scissor.set( x, y, width, height ) );\n\n    };\n\n    this.setScissorTest = function ( boolean ) {\n\n      state.setScissorTest( _scissorTest = boolean );\n\n    };\n\n    // Clearing\n\n    this.getClearColor = function () {\n\n      return _clearColor;\n\n    };\n\n    this.setClearColor = function ( color, alpha ) {\n\n      _clearColor.set( color );\n\n      _clearAlpha = alpha !== undefined ? alpha : 1;\n\n      state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );\n\n    };\n\n    this.getClearAlpha = function () {\n\n      return _clearAlpha;\n\n    };\n\n    this.setClearAlpha = function ( alpha ) {\n\n      _clearAlpha = alpha;\n\n      state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );\n\n    };\n\n    this.clear = function ( color, depth, stencil ) {\n\n      var bits = 0;\n\n      if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n      if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n      if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n      _gl.clear( bits );\n\n    };\n\n    this.clearColor = function () {\n\n      this.clear( true, false, false );\n\n    };\n\n    this.clearDepth = function () {\n\n      this.clear( false, true, false );\n\n    };\n\n    this.clearStencil = function () {\n\n      this.clear( false, false, true );\n\n    };\n\n    this.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n      this.setRenderTarget( renderTarget );\n      this.clear( color, depth, stencil );\n\n    };\n\n    // Reset\n\n    this.resetGLState = resetGLState;\n\n    this.dispose = function() {\n\n      transparentObjects = [];\n      transparentObjectsLastIndex = -1;\n      opaqueObjects = [];\n      opaqueObjectsLastIndex = -1;\n\n      _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n    };\n\n    // Events\n\n    function onContextLost( event ) {\n\n      event.preventDefault();\n\n      resetGLState();\n      setDefaultGLState();\n\n      properties.clear();\n\n    }\n\n    function onMaterialDispose( event ) {\n\n      var material = event.target;\n\n      material.removeEventListener( 'dispose', onMaterialDispose );\n\n      deallocateMaterial( material );\n\n    }\n\n    // Buffer deallocation\n\n    function deallocateMaterial( material ) {\n\n      releaseMaterialProgramReference( material );\n\n      properties.delete( material );\n\n    }\n\n\n    function releaseMaterialProgramReference( material ) {\n\n      var programInfo = properties.get( material ).program;\n\n      material.program = undefined;\n\n      if ( programInfo !== undefined ) {\n\n        programCache.releaseProgram( programInfo );\n\n      }\n\n    }\n\n    // Buffer rendering\n\n    this.renderBufferImmediate = function ( object, program, material ) {\n\n      state.initAttributes();\n\n      var buffers = properties.get( object );\n\n      if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n      if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n      if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n      if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n      var attributes = program.getAttributes();\n\n      if ( object.hasPositions ) {\n\n        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n        _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n        state.enableAttribute( attributes.position );\n        _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n      }\n\n      if ( object.hasNormals ) {\n\n        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n        if ( ! material.isMeshPhongMaterial &&\n          ! material.isMeshStandardMaterial &&\n          ! material.isMeshNormalMaterial &&\n          material.shading === FlatShading ) {\n\n          for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n            var array = object.normalArray;\n\n            var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n            var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n            var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n            array[ i + 0 ] = nx;\n            array[ i + 1 ] = ny;\n            array[ i + 2 ] = nz;\n\n            array[ i + 3 ] = nx;\n            array[ i + 4 ] = ny;\n            array[ i + 5 ] = nz;\n\n            array[ i + 6 ] = nx;\n            array[ i + 7 ] = ny;\n            array[ i + 8 ] = nz;\n\n          }\n\n        }\n\n        _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n        state.enableAttribute( attributes.normal );\n\n        _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n      }\n\n      if ( object.hasUvs && material.map ) {\n\n        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n        _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n        state.enableAttribute( attributes.uv );\n\n        _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n      }\n\n      if ( object.hasColors && material.vertexColors !== NoColors ) {\n\n        _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n        _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n        state.enableAttribute( attributes.color );\n\n        _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n      }\n\n      state.disableUnusedAttributes();\n\n      _gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n      object.count = 0;\n\n    };\n\n    this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n      setMaterial( material );\n\n      var program = setProgram( camera, fog, material, object );\n\n      var updateBuffers = false;\n      var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n      if ( geometryProgram !== _currentGeometryProgram ) {\n\n        _currentGeometryProgram = geometryProgram;\n        updateBuffers = true;\n\n      }\n\n      // morph targets\n\n      var morphTargetInfluences = object.morphTargetInfluences;\n\n      if ( morphTargetInfluences !== undefined ) {\n\n        var activeInfluences = [];\n\n        for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n          var influence = morphTargetInfluences[ i ];\n          activeInfluences.push( [ influence, i ] );\n\n        }\n\n        activeInfluences.sort( absNumericalSort );\n\n        if ( activeInfluences.length > 8 ) {\n\n          activeInfluences.length = 8;\n\n        }\n\n        var morphAttributes = geometry.morphAttributes;\n\n        for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n          var influence = activeInfluences[ i ];\n          morphInfluences[ i ] = influence[ 0 ];\n\n          if ( influence[ 0 ] !== 0 ) {\n\n            var index = influence[ 1 ];\n\n            if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n            if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n          } else {\n\n            if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n            if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n          }\n\n        }\n\n        for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {\n\n          morphInfluences[ i ] = 0.0;\n\n        }\n\n        program.getUniforms().setValue(\n          _gl, 'morphTargetInfluences', morphInfluences );\n\n        updateBuffers = true;\n\n      }\n\n      //\n\n      var index = geometry.index;\n      var position = geometry.attributes.position;\n      var rangeFactor = 1;\n\n      if ( material.wireframe === true ) {\n\n        index = objects.getWireframeAttribute( geometry );\n        rangeFactor = 2;\n\n      }\n\n      var renderer;\n\n      if ( index !== null ) {\n\n        renderer = indexedBufferRenderer;\n        renderer.setIndex( index );\n\n      } else {\n\n        renderer = bufferRenderer;\n\n      }\n\n      if ( updateBuffers ) {\n\n        setupVertexAttributes( material, program, geometry );\n\n        if ( index !== null ) {\n\n          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n        }\n\n      }\n\n      //\n\n      var dataCount = 0;\n\n      if ( index !== null ) {\n\n        dataCount = index.count;\n\n      } else if ( position !== undefined ) {\n\n        dataCount = position.count;\n\n      }\n\n      var rangeStart = geometry.drawRange.start * rangeFactor;\n      var rangeCount = geometry.drawRange.count * rangeFactor;\n\n      var groupStart = group !== null ? group.start * rangeFactor : 0;\n      var groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\n      var drawStart = Math.max( rangeStart, groupStart );\n      var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n      var drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n      if ( drawCount === 0 ) return;\n\n      //\n\n      if ( object.isMesh ) {\n\n        if ( material.wireframe === true ) {\n\n          state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n          renderer.setMode( _gl.LINES );\n\n        } else {\n\n          switch ( object.drawMode ) {\n\n            case TrianglesDrawMode:\n              renderer.setMode( _gl.TRIANGLES );\n              break;\n\n            case TriangleStripDrawMode:\n              renderer.setMode( _gl.TRIANGLE_STRIP );\n              break;\n\n            case TriangleFanDrawMode:\n              renderer.setMode( _gl.TRIANGLE_FAN );\n              break;\n\n          }\n\n        }\n\n\n      } else if ( object.isLine ) {\n\n        var lineWidth = material.linewidth;\n\n        if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n        state.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n        if ( object.isLineSegments ) {\n\n          renderer.setMode( _gl.LINES );\n\n        } else if ( object.isLineLoop ) {\n\n          renderer.setMode( _gl.LINE_LOOP );\n\n        } else {\n\n          renderer.setMode( _gl.LINE_STRIP );\n\n        }\n\n      } else if ( object.isPoints ) {\n\n        renderer.setMode( _gl.POINTS );\n\n      }\n\n      if ( geometry && geometry.isInstancedBufferGeometry ) {\n\n        if ( geometry.maxInstancedCount > 0 ) {\n\n          renderer.renderInstances( geometry, drawStart, drawCount );\n\n        }\n\n      } else {\n\n        renderer.render( drawStart, drawCount );\n\n      }\n\n    };\n\n    function setupVertexAttributes( material, program, geometry, startIndex ) {\n\n      var extension;\n\n      if ( geometry && geometry.isInstancedBufferGeometry ) {\n\n        extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n        if ( extension === null ) {\n\n          console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n          return;\n\n        }\n\n      }\n\n      if ( startIndex === undefined ) startIndex = 0;\n\n      state.initAttributes();\n\n      var geometryAttributes = geometry.attributes;\n\n      var programAttributes = program.getAttributes();\n\n      var materialDefaultAttributeValues = material.defaultAttributeValues;\n\n      for ( var name in programAttributes ) {\n\n        var programAttribute = programAttributes[ name ];\n\n        if ( programAttribute >= 0 ) {\n\n          var geometryAttribute = geometryAttributes[ name ];\n\n          if ( geometryAttribute !== undefined ) {\n\n            var normalized = geometryAttribute.normalized;\n            var size = geometryAttribute.itemSize;\n\n            var attributeProperties = objects.getAttributeProperties( geometryAttribute );\n\n            var buffer = attributeProperties.__webglBuffer;\n            var type = attributeProperties.type;\n            var bytesPerElement = attributeProperties.bytesPerElement;\n\n            if ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n              var data = geometryAttribute.data;\n              var stride = data.stride;\n              var offset = geometryAttribute.offset;\n\n              if ( data && data.isInstancedInterleavedBuffer ) {\n\n                state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n                if ( geometry.maxInstancedCount === undefined ) {\n\n                  geometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n                }\n\n              } else {\n\n                state.enableAttribute( programAttribute );\n\n              }\n\n              _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n              _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\n\n            } else {\n\n              if ( geometryAttribute.isInstancedBufferAttribute ) {\n\n                state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n                if ( geometry.maxInstancedCount === undefined ) {\n\n                  geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n                }\n\n              } else {\n\n                state.enableAttribute( programAttribute );\n\n              }\n\n              _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n              _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\n\n            }\n\n          } else if ( materialDefaultAttributeValues !== undefined ) {\n\n            var value = materialDefaultAttributeValues[ name ];\n\n            if ( value !== undefined ) {\n\n              switch ( value.length ) {\n\n                case 2:\n                  _gl.vertexAttrib2fv( programAttribute, value );\n                  break;\n\n                case 3:\n                  _gl.vertexAttrib3fv( programAttribute, value );\n                  break;\n\n                case 4:\n                  _gl.vertexAttrib4fv( programAttribute, value );\n                  break;\n\n                default:\n                  _gl.vertexAttrib1fv( programAttribute, value );\n\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n\n      state.disableUnusedAttributes();\n\n    }\n\n    // Sorting\n\n    function absNumericalSort( a, b ) {\n\n      return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n    }\n\n    function painterSortStable( a, b ) {\n\n      if ( a.object.renderOrder !== b.object.renderOrder ) {\n\n        return a.object.renderOrder - b.object.renderOrder;\n\n      } else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n        return a.material.program.id - b.material.program.id;\n\n      } else if ( a.material.id !== b.material.id ) {\n\n        return a.material.id - b.material.id;\n\n      } else if ( a.z !== b.z ) {\n\n        return a.z - b.z;\n\n      } else {\n\n        return a.id - b.id;\n\n      }\n\n    }\n\n    function reversePainterSortStable( a, b ) {\n\n      if ( a.object.renderOrder !== b.object.renderOrder ) {\n\n        return a.object.renderOrder - b.object.renderOrder;\n\n      } if ( a.z !== b.z ) {\n\n        return b.z - a.z;\n\n      } else {\n\n        return a.id - b.id;\n\n      }\n\n    }\n\n    // Rendering\n\n    this.render = function ( scene, camera, renderTarget, forceClear ) {\n\n      if ( camera !== undefined && camera.isCamera !== true ) {\n\n        console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n        return;\n\n      }\n\n      // reset caching for this frame\n\n      _currentGeometryProgram = '';\n      _currentMaterialId = - 1;\n      _currentCamera = null;\n\n      // update scene graph\n\n      if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n      // update camera matrices and frustum\n\n      if ( camera.parent === null ) camera.updateMatrixWorld();\n\n      camera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n      _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n      _frustum.setFromMatrix( _projScreenMatrix );\n\n      lights.length = 0;\n\n      opaqueObjectsLastIndex = - 1;\n      transparentObjectsLastIndex = - 1;\n\n      sprites.length = 0;\n      lensFlares.length = 0;\n\n      _localClippingEnabled = this.localClippingEnabled;\n      _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n      projectObject( scene, camera );\n\n      opaqueObjects.length = opaqueObjectsLastIndex + 1;\n      transparentObjects.length = transparentObjectsLastIndex + 1;\n\n      if ( _this.sortObjects === true ) {\n\n        opaqueObjects.sort( painterSortStable );\n        transparentObjects.sort( reversePainterSortStable );\n\n      }\n\n      //\n\n      if ( _clippingEnabled ) _clipping.beginShadows();\n\n      setupShadows( lights );\n\n      shadowMap.render( scene, camera );\n\n      setupLights( lights, camera );\n\n      if ( _clippingEnabled ) _clipping.endShadows();\n\n      //\n\n      _infoRender.calls = 0;\n      _infoRender.vertices = 0;\n      _infoRender.faces = 0;\n      _infoRender.points = 0;\n\n      if ( renderTarget === undefined ) {\n\n        renderTarget = null;\n\n      }\n\n      this.setRenderTarget( renderTarget );\n\n      //\n\n      var background = scene.background;\n\n      if ( background === null ) {\n\n        state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );\n\n      } else if ( background && background.isColor ) {\n\n        state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );\n        forceClear = true;\n\n      }\n\n      if ( this.autoClear || forceClear ) {\n\n        this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n      }\n\n      if ( background && background.isCubeTexture ) {\n\n        if ( backgroundBoxCamera === undefined ) {\n\n          backgroundBoxCamera = new PerspectiveCamera();\n\n          backgroundBoxMesh = new Mesh(\n            new BoxBufferGeometry( 5, 5, 5 ),\n            new ShaderMaterial( {\n              uniforms: ShaderLib.cube.uniforms,\n              vertexShader: ShaderLib.cube.vertexShader,\n              fragmentShader: ShaderLib.cube.fragmentShader,\n              side: BackSide,\n              depthTest: false,\n              depthWrite: false,\n              fog: false\n            } )\n          );\n\n        }\n\n        backgroundBoxCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n        backgroundBoxCamera.matrixWorld.extractRotation( camera.matrixWorld );\n        backgroundBoxCamera.matrixWorldInverse.getInverse( backgroundBoxCamera.matrixWorld );\n\n\n        backgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n        backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n        objects.update( backgroundBoxMesh );\n\n        _this.renderBufferDirect( backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n      } else if ( background && background.isTexture ) {\n\n        if ( backgroundPlaneCamera === undefined ) {\n\n          backgroundPlaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n          backgroundPlaneMesh = new Mesh(\n            new PlaneBufferGeometry( 2, 2 ),\n            new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n          );\n\n        }\n\n        backgroundPlaneMesh.material.map = background;\n\n        objects.update( backgroundPlaneMesh );\n\n        _this.renderBufferDirect( backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n      }\n\n      //\n\n      if ( scene.overrideMaterial ) {\n\n        var overrideMaterial = scene.overrideMaterial;\n\n        renderObjects( opaqueObjects, scene, camera, overrideMaterial );\n        renderObjects( transparentObjects, scene, camera, overrideMaterial );\n\n      } else {\n\n        // opaque pass (front-to-back order)\n\n        state.setBlending( NoBlending );\n        renderObjects( opaqueObjects, scene, camera );\n\n        // transparent pass (back-to-front order)\n\n        renderObjects( transparentObjects, scene, camera );\n\n      }\n\n      // custom render plugins (post pass)\n\n      spritePlugin.render( scene, camera );\n      lensFlarePlugin.render( scene, camera, _currentViewport );\n\n      // Generate mipmap if we're using any kind of mipmap filtering\n\n      if ( renderTarget ) {\n\n        textures.updateRenderTargetMipmap( renderTarget );\n\n      }\n\n      // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n      state.setDepthTest( true );\n      state.setDepthWrite( true );\n      state.setColorWrite( true );\n\n      // _gl.finish();\n\n    };\n\n    function pushRenderItem( object, geometry, material, z, group ) {\n\n      var array, index;\n\n      // allocate the next position in the appropriate array\n\n      if ( material.transparent ) {\n\n        array = transparentObjects;\n        index = ++ transparentObjectsLastIndex;\n\n      } else {\n\n        array = opaqueObjects;\n        index = ++ opaqueObjectsLastIndex;\n\n      }\n\n      // recycle existing render item or grow the array\n\n      var renderItem = array[ index ];\n\n      if ( renderItem !== undefined ) {\n\n        renderItem.id = object.id;\n        renderItem.object = object;\n        renderItem.geometry = geometry;\n        renderItem.material = material;\n        renderItem.z = _vector3.z;\n        renderItem.group = group;\n\n      } else {\n\n        renderItem = {\n          id: object.id,\n          object: object,\n          geometry: geometry,\n          material: material,\n          z: _vector3.z,\n          group: group\n        };\n\n        // assert( index === array.length );\n        array.push( renderItem );\n\n      }\n\n    }\n\n    // TODO Duplicated code (Frustum)\n\n    function isObjectViewable( object ) {\n\n      var geometry = object.geometry;\n\n      if ( geometry.boundingSphere === null )\n        geometry.computeBoundingSphere();\n\n      _sphere.copy( geometry.boundingSphere ).\n      applyMatrix4( object.matrixWorld );\n\n      return isSphereViewable( _sphere );\n\n    }\n\n    function isSpriteViewable( sprite ) {\n\n      _sphere.center.set( 0, 0, 0 );\n      _sphere.radius = 0.7071067811865476;\n      _sphere.applyMatrix4( sprite.matrixWorld );\n\n      return isSphereViewable( _sphere );\n\n    }\n\n    function isSphereViewable( sphere ) {\n\n      if ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n      var numPlanes = _clipping.numPlanes;\n\n      if ( numPlanes === 0 ) return true;\n\n      var planes = _this.clippingPlanes,\n\n        center = sphere.center,\n        negRad = - sphere.radius,\n        i = 0;\n\n      do {\n\n        // out when deeper than radius in the negative halfspace\n        if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n      } while ( ++ i !== numPlanes );\n\n      return true;\n\n    }\n\n    function projectObject( object, camera ) {\n\n      if ( object.visible === false ) return;\n\n      var visible = ( object.layers.mask & camera.layers.mask ) !== 0;\n\n      if ( visible ) {\n\n        if ( object.isLight ) {\n\n          lights.push( object );\n\n        } else if ( object.isSprite ) {\n\n          if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n            sprites.push( object );\n\n          }\n\n        } else if ( object.isLensFlare ) {\n\n          lensFlares.push( object );\n\n        } else if ( object.isImmediateRenderObject ) {\n\n          if ( _this.sortObjects === true ) {\n\n            _vector3.setFromMatrixPosition( object.matrixWorld );\n            _vector3.applyMatrix4( _projScreenMatrix );\n\n          }\n\n          pushRenderItem( object, null, object.material, _vector3.z, null );\n\n        } else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n          if ( object.isSkinnedMesh ) {\n\n            object.skeleton.update();\n\n          }\n\n          if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n            var material = object.material;\n\n            if ( material.visible === true ) {\n\n              if ( _this.sortObjects === true ) {\n\n                _vector3.setFromMatrixPosition( object.matrixWorld );\n                _vector3.applyMatrix4( _projScreenMatrix );\n\n              }\n\n              var geometry = objects.update( object );\n\n              if ( material.isMultiMaterial ) {\n\n                var groups = geometry.groups;\n                var materials = material.materials;\n\n                if ( groups.length > 0 ) {\n\n                  // push a render item for each group of the geometry\n\n                  for ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n                    var group = groups[ i ];\n                    var groupMaterial = materials[ group.materialIndex ];\n\n                    if ( groupMaterial === undefined ) {\n\n                      console.warn( 'THREE.WebGLRenderer: MultiMaterial has insufficient amount of materials for geometry. %i material(s) expected but only %i provided.', groups.length, materials.length );\n\n                    } else if ( groupMaterial.visible === true ) {\n\n                      pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n                    }\n\n                  }\n\n                } else {\n\n                  console.warn( 'THREE.WebGLRenderer: MultiMaterial can not be used without groups.' );\n\n                }\n\n              } else {\n\n                pushRenderItem( object, geometry, material, _vector3.z, null );\n\n              }\n\n            }\n\n          }\n\n        }\n\n      }\n\n      var children = object.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        projectObject( children[ i ], camera );\n\n      }\n\n    }\n\n    function renderObjects( renderList, scene, camera, overrideMaterial ) {\n\n      for ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n        var renderItem = renderList[ i ];\n\n        var object = renderItem.object;\n        var geometry = renderItem.geometry;\n        var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n        var group = renderItem.group;\n\n        object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n        object.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n        object.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n        if ( object.isImmediateRenderObject ) {\n\n          setMaterial( material );\n\n          var program = setProgram( camera, scene.fog, material, object );\n\n          _currentGeometryProgram = '';\n\n          object.render( function ( object ) {\n\n            _this.renderBufferImmediate( object, program, material );\n\n          } );\n\n        } else {\n\n          _this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\n\n        }\n\n        object.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\n      }\n\n    }\n\n    function initMaterial( material, fog, object ) {\n\n      var materialProperties = properties.get( material );\n\n      var parameters = programCache.getParameters(\n        material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );\n\n      var code = programCache.getProgramCode( material, parameters );\n\n      var program = materialProperties.program;\n      var programChange = true;\n\n      if ( program === undefined ) {\n\n        // new material\n        material.addEventListener( 'dispose', onMaterialDispose );\n\n      } else if ( program.code !== code ) {\n\n        // changed glsl or parameters\n        releaseMaterialProgramReference( material );\n\n      } else if ( parameters.shaderID !== undefined ) {\n\n        // same glsl and uniform list\n        return;\n\n      } else {\n\n        // only rebuild uniform list\n        programChange = false;\n\n      }\n\n      if ( programChange ) {\n\n        if ( parameters.shaderID ) {\n\n          var shader = ShaderLib[ parameters.shaderID ];\n\n          materialProperties.__webglShader = {\n            name: material.type,\n            uniforms: UniformsUtils.clone( shader.uniforms ),\n            vertexShader: shader.vertexShader,\n            fragmentShader: shader.fragmentShader\n          };\n\n        } else {\n\n          materialProperties.__webglShader = {\n            name: material.type,\n            uniforms: material.uniforms,\n            vertexShader: material.vertexShader,\n            fragmentShader: material.fragmentShader\n          };\n\n        }\n\n        material.__webglShader = materialProperties.__webglShader;\n\n        program = programCache.acquireProgram( material, parameters, code );\n\n        materialProperties.program = program;\n        material.program = program;\n\n      }\n\n      var attributes = program.getAttributes();\n\n      if ( material.morphTargets ) {\n\n        material.numSupportedMorphTargets = 0;\n\n        for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n          if ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n            material.numSupportedMorphTargets ++;\n\n          }\n\n        }\n\n      }\n\n      if ( material.morphNormals ) {\n\n        material.numSupportedMorphNormals = 0;\n\n        for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n          if ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n            material.numSupportedMorphNormals ++;\n\n          }\n\n        }\n\n      }\n\n      var uniforms = materialProperties.__webglShader.uniforms;\n\n      if ( ! material.isShaderMaterial &&\n        ! material.isRawShaderMaterial ||\n        material.clipping === true ) {\n\n        materialProperties.numClippingPlanes = _clipping.numPlanes;\n        materialProperties.numIntersection = _clipping.numIntersection;\n        uniforms.clippingPlanes = _clipping.uniform;\n\n      }\n\n      materialProperties.fog = fog;\n\n      // store the light setup it was created for\n\n      materialProperties.lightsHash = _lights.hash;\n\n      if ( material.lights ) {\n\n        // wire up the material to this renderer's lighting state\n\n        uniforms.ambientLightColor.value = _lights.ambient;\n        uniforms.directionalLights.value = _lights.directional;\n        uniforms.spotLights.value = _lights.spot;\n        uniforms.rectAreaLights.value = _lights.rectArea;\n        uniforms.pointLights.value = _lights.point;\n        uniforms.hemisphereLights.value = _lights.hemi;\n\n        uniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n        uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n        uniforms.spotShadowMap.value = _lights.spotShadowMap;\n        uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n        uniforms.pointShadowMap.value = _lights.pointShadowMap;\n        uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n        // TODO (abelnation): add area lights shadow info to uniforms\n\n      }\n\n      var progUniforms = materialProperties.program.getUniforms(),\n        uniformsList =\n          WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n      materialProperties.uniformsList = uniformsList;\n\n    }\n\n    function setMaterial( material ) {\n\n      material.side === DoubleSide\n        ? state.disable( _gl.CULL_FACE )\n        : state.enable( _gl.CULL_FACE );\n\n      state.setFlipSided( material.side === BackSide );\n\n      material.transparent === true\n        ? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\n        : state.setBlending( NoBlending );\n\n      state.setDepthFunc( material.depthFunc );\n      state.setDepthTest( material.depthTest );\n      state.setDepthWrite( material.depthWrite );\n      state.setColorWrite( material.colorWrite );\n      state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n    }\n\n    function setProgram( camera, fog, material, object ) {\n\n      _usedTextureUnits = 0;\n\n      var materialProperties = properties.get( material );\n\n      if ( _clippingEnabled ) {\n\n        if ( _localClippingEnabled || camera !== _currentCamera ) {\n\n          var useCache =\n            camera === _currentCamera &&\n            material.id === _currentMaterialId;\n\n          // we might want to call this function with some ClippingGroup\n          // object instead of the material, once it becomes feasible\n          // (#8465, #8379)\n          _clipping.setState(\n            material.clippingPlanes, material.clipIntersection, material.clipShadows,\n            camera, materialProperties, useCache );\n\n        }\n\n      }\n\n      if ( material.needsUpdate === false ) {\n\n        if ( materialProperties.program === undefined ) {\n\n          material.needsUpdate = true;\n\n        } else if ( material.fog && materialProperties.fog !== fog ) {\n\n          material.needsUpdate = true;\n\n        } else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {\n\n          material.needsUpdate = true;\n\n        } else if ( materialProperties.numClippingPlanes !== undefined &&\n          ( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\n          materialProperties.numIntersection  !== _clipping.numIntersection ) ) {\n\n          material.needsUpdate = true;\n\n        }\n\n      }\n\n      if ( material.needsUpdate ) {\n\n        initMaterial( material, fog, object );\n        material.needsUpdate = false;\n\n      }\n\n      var refreshProgram = false;\n      var refreshMaterial = false;\n      var refreshLights = false;\n\n      var program = materialProperties.program,\n        p_uniforms = program.getUniforms(),\n        m_uniforms = materialProperties.__webglShader.uniforms;\n\n      if ( program.id !== _currentProgram ) {\n\n        _gl.useProgram( program.program );\n        _currentProgram = program.id;\n\n        refreshProgram = true;\n        refreshMaterial = true;\n        refreshLights = true;\n\n      }\n\n      if ( material.id !== _currentMaterialId ) {\n\n        _currentMaterialId = material.id;\n\n        refreshMaterial = true;\n\n      }\n\n      if ( refreshProgram || camera !== _currentCamera ) {\n\n        p_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n        if ( capabilities.logarithmicDepthBuffer ) {\n\n          p_uniforms.setValue( _gl, 'logDepthBufFC',\n            2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n        }\n\n\n        if ( camera !== _currentCamera ) {\n\n          _currentCamera = camera;\n\n          // lighting uniforms depend on the camera so enforce an update\n          // now, in case this material supports lights - or later, when\n          // the next material that does gets activated:\n\n          refreshMaterial = true;   // set to true on material change\n          refreshLights = true;   // remains set until update done\n\n        }\n\n        // load material specific uniforms\n        // (shader material also gets them for the sake of genericity)\n\n        if ( material.isShaderMaterial ||\n          material.isMeshPhongMaterial ||\n          material.isMeshStandardMaterial ||\n          material.envMap ) {\n\n          var uCamPos = p_uniforms.map.cameraPosition;\n\n          if ( uCamPos !== undefined ) {\n\n            uCamPos.setValue( _gl,\n              _vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n          }\n\n        }\n\n        if ( material.isMeshPhongMaterial ||\n          material.isMeshLambertMaterial ||\n          material.isMeshBasicMaterial ||\n          material.isMeshStandardMaterial ||\n          material.isShaderMaterial ||\n          material.skinning ) {\n\n          p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n        }\n\n        p_uniforms.set( _gl, _this, 'toneMappingExposure' );\n        p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n      }\n\n      // skinning uniforms must be set even if material didn't change\n      // auto-setting of texture unit for bone texture must go before other textures\n      // not sure why, but otherwise weird things happen\n\n      if ( material.skinning ) {\n\n        p_uniforms.setOptional( _gl, object, 'bindMatrix' );\n        p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n        var skeleton = object.skeleton;\n\n        if ( skeleton ) {\n\n          if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n            p_uniforms.set( _gl, skeleton, 'boneTexture' );\n            p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n            p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n          } else {\n\n            p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n          }\n\n        }\n\n      }\n\n      if ( refreshMaterial ) {\n\n        if ( material.lights ) {\n\n          // the current material requires lighting info\n\n          // note: all lighting uniforms are always set correctly\n          // they simply reference the renderer's state for their\n          // values\n          //\n          // use the current material's .needsUpdate flags to set\n          // the GL state when required\n\n          markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n        }\n\n        // refresh uniforms common to several materials\n\n        if ( fog && material.fog ) {\n\n          refreshUniformsFog( m_uniforms, fog );\n\n        }\n\n        if ( material.isMeshBasicMaterial ||\n          material.isMeshLambertMaterial ||\n          material.isMeshPhongMaterial ||\n          material.isMeshStandardMaterial ||\n          material.isMeshNormalMaterial ||\n          material.isMeshDepthMaterial ) {\n\n          refreshUniformsCommon( m_uniforms, material );\n\n        }\n\n        // refresh single material specific uniforms\n\n        if ( material.isLineBasicMaterial ) {\n\n          refreshUniformsLine( m_uniforms, material );\n\n        } else if ( material.isLineDashedMaterial ) {\n\n          refreshUniformsLine( m_uniforms, material );\n          refreshUniformsDash( m_uniforms, material );\n\n        } else if ( material.isPointsMaterial ) {\n\n          refreshUniformsPoints( m_uniforms, material );\n\n        } else if ( material.isMeshLambertMaterial ) {\n\n          refreshUniformsLambert( m_uniforms, material );\n\n        } else if ( material.isMeshToonMaterial ) {\n\n          refreshUniformsToon( m_uniforms, material );\n\n        } else if ( material.isMeshPhongMaterial ) {\n\n          refreshUniformsPhong( m_uniforms, material );\n\n        } else if ( material.isMeshPhysicalMaterial ) {\n\n          refreshUniformsPhysical( m_uniforms, material );\n\n        } else if ( material.isMeshStandardMaterial ) {\n\n          refreshUniformsStandard( m_uniforms, material );\n\n        } else if ( material.isMeshDepthMaterial ) {\n\n          if ( material.displacementMap ) {\n\n            m_uniforms.displacementMap.value = material.displacementMap;\n            m_uniforms.displacementScale.value = material.displacementScale;\n            m_uniforms.displacementBias.value = material.displacementBias;\n\n          }\n\n        } else if ( material.isMeshNormalMaterial ) {\n\n          refreshUniformsNormal( m_uniforms, material );\n\n        }\n\n        // RectAreaLight Texture\n        // TODO (mrdoob): Find a nicer implementation\n\n        if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;\n        if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;\n\n        WebGLUniforms.upload(\n          _gl, materialProperties.uniformsList, m_uniforms, _this );\n\n      }\n\n\n      // common matrices\n\n      p_uniforms.set( _gl, object, 'modelViewMatrix' );\n      p_uniforms.set( _gl, object, 'normalMatrix' );\n      p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n      return program;\n\n    }\n\n    // Uniforms (refresh uniforms objects)\n\n    function refreshUniformsCommon( uniforms, material ) {\n\n      uniforms.opacity.value = material.opacity;\n\n      uniforms.diffuse.value = material.color;\n\n      if ( material.emissive ) {\n\n        uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n      }\n\n      uniforms.map.value = material.map;\n      uniforms.specularMap.value = material.specularMap;\n      uniforms.alphaMap.value = material.alphaMap;\n\n      if ( material.lightMap ) {\n\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n      }\n\n      if ( material.aoMap ) {\n\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n      }\n\n      // uv repeat and offset setting priorities\n      // 1. color map\n      // 2. specular map\n      // 3. normal map\n      // 4. bump map\n      // 5. alpha map\n      // 6. emissive map\n\n      var uvScaleMap;\n\n      if ( material.map ) {\n\n        uvScaleMap = material.map;\n\n      } else if ( material.specularMap ) {\n\n        uvScaleMap = material.specularMap;\n\n      } else if ( material.displacementMap ) {\n\n        uvScaleMap = material.displacementMap;\n\n      } else if ( material.normalMap ) {\n\n        uvScaleMap = material.normalMap;\n\n      } else if ( material.bumpMap ) {\n\n        uvScaleMap = material.bumpMap;\n\n      } else if ( material.roughnessMap ) {\n\n        uvScaleMap = material.roughnessMap;\n\n      } else if ( material.metalnessMap ) {\n\n        uvScaleMap = material.metalnessMap;\n\n      } else if ( material.alphaMap ) {\n\n        uvScaleMap = material.alphaMap;\n\n      } else if ( material.emissiveMap ) {\n\n        uvScaleMap = material.emissiveMap;\n\n      }\n\n      if ( uvScaleMap !== undefined ) {\n\n        // backwards compatibility\n        if ( uvScaleMap.isWebGLRenderTarget ) {\n\n          uvScaleMap = uvScaleMap.texture;\n\n        }\n\n        var offset = uvScaleMap.offset;\n        var repeat = uvScaleMap.repeat;\n\n        uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n      }\n\n      uniforms.envMap.value = material.envMap;\n\n      // don't flip CubeTexture envMaps, flip everything else:\n      //  WebGLRenderTargetCube will be flipped for backwards compatibility\n      //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n      // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n      uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\n\n      uniforms.reflectivity.value = material.reflectivity;\n      uniforms.refractionRatio.value = material.refractionRatio;\n\n    }\n\n    function refreshUniformsLine( uniforms, material ) {\n\n      uniforms.diffuse.value = material.color;\n      uniforms.opacity.value = material.opacity;\n\n    }\n\n    function refreshUniformsDash( uniforms, material ) {\n\n      uniforms.dashSize.value = material.dashSize;\n      uniforms.totalSize.value = material.dashSize + material.gapSize;\n      uniforms.scale.value = material.scale;\n\n    }\n\n    function refreshUniformsPoints( uniforms, material ) {\n\n      uniforms.diffuse.value = material.color;\n      uniforms.opacity.value = material.opacity;\n      uniforms.size.value = material.size * _pixelRatio;\n      uniforms.scale.value = _height * 0.5;\n\n      uniforms.map.value = material.map;\n\n      if ( material.map !== null ) {\n\n        var offset = material.map.offset;\n        var repeat = material.map.repeat;\n\n        uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n      }\n\n    }\n\n    function refreshUniformsFog( uniforms, fog ) {\n\n      uniforms.fogColor.value = fog.color;\n\n      if ( fog.isFog ) {\n\n        uniforms.fogNear.value = fog.near;\n        uniforms.fogFar.value = fog.far;\n\n      } else if ( fog.isFogExp2 ) {\n\n        uniforms.fogDensity.value = fog.density;\n\n      }\n\n    }\n\n    function refreshUniformsLambert( uniforms, material ) {\n\n      if ( material.emissiveMap ) {\n\n        uniforms.emissiveMap.value = material.emissiveMap;\n\n      }\n\n    }\n\n    function refreshUniformsPhong( uniforms, material ) {\n\n      uniforms.specular.value = material.specular;\n      uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n      if ( material.emissiveMap ) {\n\n        uniforms.emissiveMap.value = material.emissiveMap;\n\n      }\n\n      if ( material.bumpMap ) {\n\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.bumpScale.value = material.bumpScale;\n\n      }\n\n      if ( material.normalMap ) {\n\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.normalScale.value.copy( material.normalScale );\n\n      }\n\n      if ( material.displacementMap ) {\n\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n      }\n\n    }\n\n    function refreshUniformsToon( uniforms, material ) {\n\n      refreshUniformsPhong( uniforms, material );\n\n      if ( material.gradientMap ) {\n\n        uniforms.gradientMap.value = material.gradientMap;\n\n      }\n\n    }\n\n    function refreshUniformsStandard( uniforms, material ) {\n\n      uniforms.roughness.value = material.roughness;\n      uniforms.metalness.value = material.metalness;\n\n      if ( material.roughnessMap ) {\n\n        uniforms.roughnessMap.value = material.roughnessMap;\n\n      }\n\n      if ( material.metalnessMap ) {\n\n        uniforms.metalnessMap.value = material.metalnessMap;\n\n      }\n\n      if ( material.emissiveMap ) {\n\n        uniforms.emissiveMap.value = material.emissiveMap;\n\n      }\n\n      if ( material.bumpMap ) {\n\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.bumpScale.value = material.bumpScale;\n\n      }\n\n      if ( material.normalMap ) {\n\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.normalScale.value.copy( material.normalScale );\n\n      }\n\n      if ( material.displacementMap ) {\n\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n      }\n\n      if ( material.envMap ) {\n\n        //uniforms.envMap.value = material.envMap; // part of uniforms common\n        uniforms.envMapIntensity.value = material.envMapIntensity;\n\n      }\n\n    }\n\n    function refreshUniformsPhysical( uniforms, material ) {\n\n      uniforms.clearCoat.value = material.clearCoat;\n      uniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n      refreshUniformsStandard( uniforms, material );\n\n    }\n\n    function refreshUniformsNormal( uniforms, material ) {\n\n      if ( material.bumpMap ) {\n\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.bumpScale.value = material.bumpScale;\n\n      }\n\n      if ( material.normalMap ) {\n\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.normalScale.value.copy( material.normalScale );\n\n      }\n\n      if ( material.displacementMap ) {\n\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n      }\n\n    }\n\n    // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n    function markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n      uniforms.ambientLightColor.needsUpdate = value;\n\n      uniforms.directionalLights.needsUpdate = value;\n      uniforms.pointLights.needsUpdate = value;\n      uniforms.spotLights.needsUpdate = value;\n      uniforms.rectAreaLights.needsUpdate = value;\n      uniforms.hemisphereLights.needsUpdate = value;\n\n    }\n\n    // Lighting\n\n    function setupShadows( lights ) {\n\n      var lightShadowsLength = 0;\n\n      for ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n        var light = lights[ i ];\n\n        if ( light.castShadow ) {\n\n          _lights.shadows[ lightShadowsLength ++ ] = light;\n\n        }\n\n      }\n\n      _lights.shadows.length = lightShadowsLength;\n\n    }\n\n    function setupLights( lights, camera ) {\n\n      var l, ll, light,\n        r = 0, g = 0, b = 0,\n        color,\n        intensity,\n        distance,\n        shadowMap,\n\n        viewMatrix = camera.matrixWorldInverse,\n\n      directionalLength = 0,\n      pointLength = 0,\n      spotLength = 0,\n      rectAreaLength = 0,\n      hemiLength = 0;\n\n      for ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n        light = lights[ l ];\n\n        color = light.color;\n        intensity = light.intensity;\n        distance = light.distance;\n\n        shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n        if ( light.isAmbientLight ) {\n\n          r += color.r * intensity;\n          g += color.g * intensity;\n          b += color.b * intensity;\n\n        } else if ( light.isDirectionalLight ) {\n\n          var uniforms = lightCache.get( light );\n\n          uniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n          uniforms.direction.setFromMatrixPosition( light.matrixWorld );\n          _vector3.setFromMatrixPosition( light.target.matrixWorld );\n          uniforms.direction.sub( _vector3 );\n          uniforms.direction.transformDirection( viewMatrix );\n\n          uniforms.shadow = light.castShadow;\n\n          if ( light.castShadow ) {\n\n            uniforms.shadowBias = light.shadow.bias;\n            uniforms.shadowRadius = light.shadow.radius;\n            uniforms.shadowMapSize = light.shadow.mapSize;\n\n          }\n\n          _lights.directionalShadowMap[ directionalLength ] = shadowMap;\n          _lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n          _lights.directional[ directionalLength ++ ] = uniforms;\n\n        } else if ( light.isSpotLight ) {\n\n          var uniforms = lightCache.get( light );\n\n          uniforms.position.setFromMatrixPosition( light.matrixWorld );\n          uniforms.position.applyMatrix4( viewMatrix );\n\n          uniforms.color.copy( color ).multiplyScalar( intensity );\n          uniforms.distance = distance;\n\n          uniforms.direction.setFromMatrixPosition( light.matrixWorld );\n          _vector3.setFromMatrixPosition( light.target.matrixWorld );\n          uniforms.direction.sub( _vector3 );\n          uniforms.direction.transformDirection( viewMatrix );\n\n          uniforms.coneCos = Math.cos( light.angle );\n          uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n          uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n          uniforms.shadow = light.castShadow;\n\n          if ( light.castShadow ) {\n\n            uniforms.shadowBias = light.shadow.bias;\n            uniforms.shadowRadius = light.shadow.radius;\n            uniforms.shadowMapSize = light.shadow.mapSize;\n\n          }\n\n          _lights.spotShadowMap[ spotLength ] = shadowMap;\n          _lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n          _lights.spot[ spotLength ++ ] = uniforms;\n\n        } else if ( light.isRectAreaLight ) {\n\n          var uniforms = lightCache.get( light );\n\n          // (a) intensity controls irradiance of entire light\n          uniforms.color\n            .copy( color )\n            .multiplyScalar( intensity / ( light.width * light.height ) );\n\n          // (b) intensity controls the radiance per light area\n          // uniforms.color.copy( color ).multiplyScalar( intensity );\n\n          uniforms.position.setFromMatrixPosition( light.matrixWorld );\n          uniforms.position.applyMatrix4( viewMatrix );\n\n          // extract local rotation of light to derive width/height half vectors\n          _matrix42.identity();\n          _matrix4.copy( light.matrixWorld );\n          _matrix4.premultiply( viewMatrix );\n          _matrix42.extractRotation( _matrix4 );\n\n          uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );\n          uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );\n\n          uniforms.halfWidth.applyMatrix4( _matrix42 );\n          uniforms.halfHeight.applyMatrix4( _matrix42 );\n\n          // TODO (abelnation): RectAreaLight distance?\n          // uniforms.distance = distance;\n\n          _lights.rectArea[ rectAreaLength ++ ] = uniforms;\n\n        } else if ( light.isPointLight ) {\n\n          var uniforms = lightCache.get( light );\n\n          uniforms.position.setFromMatrixPosition( light.matrixWorld );\n          uniforms.position.applyMatrix4( viewMatrix );\n\n          uniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n          uniforms.distance = light.distance;\n          uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n          uniforms.shadow = light.castShadow;\n\n          if ( light.castShadow ) {\n\n            uniforms.shadowBias = light.shadow.bias;\n            uniforms.shadowRadius = light.shadow.radius;\n            uniforms.shadowMapSize = light.shadow.mapSize;\n\n          }\n\n          _lights.pointShadowMap[ pointLength ] = shadowMap;\n\n          if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n            _lights.pointShadowMatrix[ pointLength ] = new Matrix4();\n\n          }\n\n          // for point lights we set the shadow matrix to be a translation-only matrix\n          // equal to inverse of the light's position\n          _vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n          _lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n          _lights.point[ pointLength ++ ] = uniforms;\n\n        } else if ( light.isHemisphereLight ) {\n\n          var uniforms = lightCache.get( light );\n\n          uniforms.direction.setFromMatrixPosition( light.matrixWorld );\n          uniforms.direction.transformDirection( viewMatrix );\n          uniforms.direction.normalize();\n\n          uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n          uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n          _lights.hemi[ hemiLength ++ ] = uniforms;\n\n        }\n\n      }\n\n      _lights.ambient[ 0 ] = r;\n      _lights.ambient[ 1 ] = g;\n      _lights.ambient[ 2 ] = b;\n\n      _lights.directional.length = directionalLength;\n      _lights.spot.length = spotLength;\n      _lights.rectArea.length = rectAreaLength;\n      _lights.point.length = pointLength;\n      _lights.hemi.length = hemiLength;\n\n      // TODO (sam-g-steel) why aren't we using join\n      _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n    }\n\n    // GL state setting\n\n    this.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n      state.setCullFace( cullFace );\n      state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\n\n    };\n\n    // Textures\n\n    function allocTextureUnit() {\n\n      var textureUnit = _usedTextureUnits;\n\n      if ( textureUnit >= capabilities.maxTextures ) {\n\n        console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n      }\n\n      _usedTextureUnits += 1;\n\n      return textureUnit;\n\n    }\n\n    this.allocTextureUnit = allocTextureUnit;\n\n    // this.setTexture2D = setTexture2D;\n    this.setTexture2D = ( function() {\n\n      var warned = false;\n\n      // backwards compatibility: peel texture.texture\n      return function setTexture2D( texture, slot ) {\n\n        if ( texture && texture.isWebGLRenderTarget ) {\n\n          if ( ! warned ) {\n\n            console.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n            warned = true;\n\n          }\n\n          texture = texture.texture;\n\n        }\n\n        textures.setTexture2D( texture, slot );\n\n      };\n\n    }() );\n\n    this.setTexture = ( function() {\n\n      var warned = false;\n\n      return function setTexture( texture, slot ) {\n\n        if ( ! warned ) {\n\n          console.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n          warned = true;\n\n        }\n\n        textures.setTexture2D( texture, slot );\n\n      };\n\n    }() );\n\n    this.setTextureCube = ( function() {\n\n      var warned = false;\n\n      return function setTextureCube( texture, slot ) {\n\n        // backwards compatibility: peel texture.texture\n        if ( texture && texture.isWebGLRenderTargetCube ) {\n\n          if ( ! warned ) {\n\n            console.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n            warned = true;\n\n          }\n\n          texture = texture.texture;\n\n        }\n\n        // currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n        // TODO: unify these code paths\n        if ( ( texture && texture.isCubeTexture ) ||\n          ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n          // CompressedTexture can have Array in image :/\n\n          // this function alone should take care of cube textures\n          textures.setTextureCube( texture, slot );\n\n        } else {\n\n          // assumed: texture property of THREE.WebGLRenderTargetCube\n\n          textures.setTextureCubeDynamic( texture, slot );\n\n        }\n\n      };\n\n    }() );\n\n    this.getCurrentRenderTarget = function() {\n\n      return _currentRenderTarget;\n\n    };\n\n    this.setRenderTarget = function ( renderTarget ) {\n\n      _currentRenderTarget = renderTarget;\n\n      if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n        textures.setupRenderTarget( renderTarget );\n\n      }\n\n      var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\n      var framebuffer;\n\n      if ( renderTarget ) {\n\n        var renderTargetProperties = properties.get( renderTarget );\n\n        if ( isCube ) {\n\n          framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n        } else {\n\n          framebuffer = renderTargetProperties.__webglFramebuffer;\n\n        }\n\n        _currentScissor.copy( renderTarget.scissor );\n        _currentScissorTest = renderTarget.scissorTest;\n\n        _currentViewport.copy( renderTarget.viewport );\n\n      } else {\n\n        framebuffer = null;\n\n        _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n        _currentScissorTest = _scissorTest;\n\n        _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n      }\n\n      if ( _currentFramebuffer !== framebuffer ) {\n\n        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n        _currentFramebuffer = framebuffer;\n\n      }\n\n      state.scissor( _currentScissor );\n      state.setScissorTest( _currentScissorTest );\n\n      state.viewport( _currentViewport );\n\n      if ( isCube ) {\n\n        var textureProperties = properties.get( renderTarget.texture );\n        _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n      }\n\n    };\n\n    this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n      if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {\n\n        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n        return;\n\n      }\n\n      var framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n      if ( framebuffer ) {\n\n        var restore = false;\n\n        if ( framebuffer !== _currentFramebuffer ) {\n\n          _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n          restore = true;\n\n        }\n\n        try {\n\n          var texture = renderTarget.texture;\n          var textureFormat = texture.format;\n          var textureType = texture.type;\n\n          if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n            return;\n\n          }\n\n          if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\n            ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n            ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n            return;\n\n          }\n\n          if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n            // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n            if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n              _gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );\n\n            }\n\n          } else {\n\n            console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n          }\n\n        } finally {\n\n          if ( restore ) {\n\n            _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n          }\n\n        }\n\n      }\n\n    };\n\n    // Map three.js constants to WebGL constants\n\n    function paramThreeToGL( p ) {\n\n      var extension;\n\n      if ( p === RepeatWrapping ) return _gl.REPEAT;\n      if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n      if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n      if ( p === NearestFilter ) return _gl.NEAREST;\n      if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n      if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n      if ( p === LinearFilter ) return _gl.LINEAR;\n      if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n      if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n      if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n      if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n      if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n      if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n      if ( p === ByteType ) return _gl.BYTE;\n      if ( p === ShortType ) return _gl.SHORT;\n      if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n      if ( p === IntType ) return _gl.INT;\n      if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;\n      if ( p === FloatType ) return _gl.FLOAT;\n\n      if ( p === HalfFloatType ) {\n\n        extension = extensions.get( 'OES_texture_half_float' );\n\n        if ( extension !== null ) return extension.HALF_FLOAT_OES;\n\n      }\n\n      if ( p === AlphaFormat ) return _gl.ALPHA;\n      if ( p === RGBFormat ) return _gl.RGB;\n      if ( p === RGBAFormat ) return _gl.RGBA;\n      if ( p === LuminanceFormat ) return _gl.LUMINANCE;\n      if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n      if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;\n      if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;\n\n      if ( p === AddEquation ) return _gl.FUNC_ADD;\n      if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;\n      if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n      if ( p === ZeroFactor ) return _gl.ZERO;\n      if ( p === OneFactor ) return _gl.ONE;\n      if ( p === SrcColorFactor ) return _gl.SRC_COLOR;\n      if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n      if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;\n      if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n      if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;\n      if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n      if ( p === DstColorFactor ) return _gl.DST_COLOR;\n      if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n      if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n      if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\n        p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n        extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n        if ( extension !== null ) {\n\n          if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n        }\n\n      }\n\n      if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\n        p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n        extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n        if ( extension !== null ) {\n\n          if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n          if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n          if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n          if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n        }\n\n      }\n\n      if ( p === RGB_ETC1_Format ) {\n\n        extension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n        if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n      }\n\n      if ( p === MinEquation || p === MaxEquation ) {\n\n        extension = extensions.get( 'EXT_blend_minmax' );\n\n        if ( extension !== null ) {\n\n          if ( p === MinEquation ) return extension.MIN_EXT;\n          if ( p === MaxEquation ) return extension.MAX_EXT;\n\n        }\n\n      }\n\n      if ( p === UnsignedInt248Type ) {\n\n        extension = extensions.get( 'WEBGL_depth_texture' );\n\n        if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\n\n      }\n\n      return 0;\n\n    }\n\n  }\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function FogExp2 ( color, density ) {\n\n    this.name = '';\n\n    this.color = new Color( color );\n    this.density = ( density !== undefined ) ? density : 0.00025;\n\n  }\n\n  FogExp2.prototype.isFogExp2 = true;\n\n  FogExp2.prototype.clone = function () {\n\n    return new FogExp2( this.color.getHex(), this.density );\n\n  };\n\n  FogExp2.prototype.toJSON = function ( meta ) {\n\n    return {\n      type: 'FogExp2',\n      color: this.color.getHex(),\n      density: this.density\n    };\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Fog ( color, near, far ) {\n\n    this.name = '';\n\n    this.color = new Color( color );\n\n    this.near = ( near !== undefined ) ? near : 1;\n    this.far = ( far !== undefined ) ? far : 1000;\n\n  }\n\n  Fog.prototype.isFog = true;\n\n  Fog.prototype.clone = function () {\n\n    return new Fog( this.color.getHex(), this.near, this.far );\n\n  };\n\n  Fog.prototype.toJSON = function ( meta ) {\n\n    return {\n      type: 'Fog',\n      color: this.color.getHex(),\n      near: this.near,\n      far: this.far\n    };\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Scene () {\n\n    Object3D.call( this );\n\n    this.type = 'Scene';\n\n    this.background = null;\n    this.fog = null;\n    this.overrideMaterial = null;\n\n    this.autoUpdate = true; // checked by the renderer\n\n  }\n\n  Scene.prototype = Object.create( Object3D.prototype );\n\n  Scene.prototype.constructor = Scene;\n\n  Scene.prototype.copy = function ( source, recursive ) {\n\n    Object3D.prototype.copy.call( this, source, recursive );\n\n    if ( source.background !== null ) this.background = source.background.clone();\n    if ( source.fog !== null ) this.fog = source.fog.clone();\n    if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n    this.autoUpdate = source.autoUpdate;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n\n    return this;\n\n  };\n\n  Scene.prototype.toJSON = function ( meta ) {\n\n    var data = Object3D.prototype.toJSON.call( this, meta );\n\n    if ( this.background !== null ) data.object.background = this.background.toJSON( meta );\n    if ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\n    return data;\n\n  };\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function LensFlare( texture, size, distance, blending, color ) {\n\n    Object3D.call( this );\n\n    this.lensFlares = [];\n\n    this.positionScreen = new Vector3();\n    this.customUpdateCallback = undefined;\n\n    if ( texture !== undefined ) {\n\n      this.add( texture, size, distance, blending, color );\n\n    }\n\n  }\n\n  LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: LensFlare,\n\n    isLensFlare: true,\n\n    copy: function ( source ) {\n\n      Object3D.prototype.copy.call( this, source );\n\n      this.positionScreen.copy( source.positionScreen );\n      this.customUpdateCallback = source.customUpdateCallback;\n\n      for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n        this.lensFlares.push( source.lensFlares[ i ] );\n\n      }\n\n      return this;\n\n    },\n\n    add: function ( texture, size, distance, blending, color, opacity ) {\n\n      if ( size === undefined ) size = - 1;\n      if ( distance === undefined ) distance = 0;\n      if ( opacity === undefined ) opacity = 1;\n      if ( color === undefined ) color = new Color( 0xffffff );\n      if ( blending === undefined ) blending = NormalBlending;\n\n      distance = Math.min( distance, Math.max( 0, distance ) );\n\n      this.lensFlares.push( {\n        texture: texture, // THREE.Texture\n        size: size,     // size in pixels (-1 = use texture.width)\n        distance: distance,   // distance (0-1) from light source (0=at light source)\n        x: 0, y: 0, z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back\n        scale: 1,     // scale\n        rotation: 0,    // rotation\n        opacity: opacity, // opacity\n        color: color,   // color\n        blending: blending  // blending\n      } );\n\n    },\n\n    /*\n     * Update lens flares update positions on all flares based on the screen position\n     * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n     */\n\n    updateLensFlares: function () {\n\n      var f, fl = this.lensFlares.length;\n      var flare;\n      var vecX = - this.positionScreen.x * 2;\n      var vecY = - this.positionScreen.y * 2;\n\n      for ( f = 0; f < fl; f ++ ) {\n\n        flare = this.lensFlares[ f ];\n\n        flare.x = this.positionScreen.x + vecX * flare.distance;\n        flare.y = this.positionScreen.y + vecY * flare.distance;\n\n        flare.wantedRotation = flare.x * Math.PI * 0.25;\n        flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n      }\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  uvOffset: new THREE.Vector2(),\n   *  uvScale: new THREE.Vector2()\n   * }\n   */\n\n  function SpriteMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'SpriteMaterial';\n\n    this.color = new Color( 0xffffff );\n    this.map = null;\n\n    this.rotation = 0;\n\n    this.fog = false;\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  SpriteMaterial.prototype = Object.create( Material.prototype );\n  SpriteMaterial.prototype.constructor = SpriteMaterial;\n\n  SpriteMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n    this.map = source.map;\n\n    this.rotation = source.rotation;\n\n    return this;\n\n  };\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Sprite( material ) {\n\n    Object3D.call( this );\n\n    this.type = 'Sprite';\n\n    this.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n  }\n\n  Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Sprite,\n\n    isSprite: true,\n\n    raycast: ( function () {\n\n      var matrixPosition = new Vector3();\n\n      return function raycast( raycaster, intersects ) {\n\n        matrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n        var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n        var guessSizeSq = this.scale.x * this.scale.y / 4;\n\n        if ( distanceSq > guessSizeSq ) {\n\n          return;\n\n        }\n\n        intersects.push( {\n\n          distance: Math.sqrt( distanceSq ),\n          point: this.position,\n          face: null,\n          object: this\n\n        } );\n\n      };\n\n    }() ),\n\n    clone: function () {\n\n      return new this.constructor( this.material ).copy( this );\n\n    }\n\n  } );\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function LOD() {\n\n    Object3D.call( this );\n\n    this.type = 'LOD';\n\n    Object.defineProperties( this, {\n      levels: {\n        enumerable: true,\n        value: []\n      }\n    } );\n\n  }\n\n  LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: LOD,\n\n    copy: function ( source ) {\n\n      Object3D.prototype.copy.call( this, source, false );\n\n      var levels = source.levels;\n\n      for ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n        var level = levels[ i ];\n\n        this.addLevel( level.object.clone(), level.distance );\n\n      }\n\n      return this;\n\n    },\n\n    addLevel: function ( object, distance ) {\n\n      if ( distance === undefined ) distance = 0;\n\n      distance = Math.abs( distance );\n\n      var levels = this.levels;\n\n      for ( var l = 0; l < levels.length; l ++ ) {\n\n        if ( distance < levels[ l ].distance ) {\n\n          break;\n\n        }\n\n      }\n\n      levels.splice( l, 0, { distance: distance, object: object } );\n\n      this.add( object );\n\n    },\n\n    getObjectForDistance: function ( distance ) {\n\n      var levels = this.levels;\n\n      for ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n        if ( distance < levels[ i ].distance ) {\n\n          break;\n\n        }\n\n      }\n\n      return levels[ i - 1 ].object;\n\n    },\n\n    raycast: ( function () {\n\n      var matrixPosition = new Vector3();\n\n      return function raycast( raycaster, intersects ) {\n\n        matrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n        var distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n        this.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n      };\n\n    }() ),\n\n    update: function () {\n\n      var v1 = new Vector3();\n      var v2 = new Vector3();\n\n      return function update( camera ) {\n\n        var levels = this.levels;\n\n        if ( levels.length > 1 ) {\n\n          v1.setFromMatrixPosition( camera.matrixWorld );\n          v2.setFromMatrixPosition( this.matrixWorld );\n\n          var distance = v1.distanceTo( v2 );\n\n          levels[ 0 ].object.visible = true;\n\n          for ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n            if ( distance >= levels[ i ].distance ) {\n\n              levels[ i - 1 ].object.visible = false;\n              levels[ i ].object.visible = true;\n\n            } else {\n\n              break;\n\n            }\n\n          }\n\n          for ( ; i < l; i ++ ) {\n\n            levels[ i ].object.visible = false;\n\n          }\n\n        }\n\n      };\n\n    }(),\n\n    toJSON: function ( meta ) {\n\n      var data = Object3D.prototype.toJSON.call( this, meta );\n\n      data.object.levels = [];\n\n      var levels = this.levels;\n\n      for ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n        var level = levels[ i ];\n\n        data.object.levels.push( {\n          object: level.object.uuid,\n          distance: level.distance\n        } );\n\n      }\n\n      return data;\n\n    }\n\n  } );\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author michael guerrero / http://realitymeltdown.com\n   * @author ikerr / http://verold.com\n   */\n\n  function Skeleton( bones, boneInverses, useVertexTexture ) {\n\n    this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n    this.identityMatrix = new Matrix4();\n\n    // copy the bone array\n\n    bones = bones || [];\n\n    this.bones = bones.slice( 0 );\n\n    // create a bone texture or an array of floats\n\n    if ( this.useVertexTexture ) {\n\n      // layout (1 matrix = 4 pixels)\n      //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n      //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n      //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n      //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n      //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n      var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n      size = _Math.nextPowerOfTwo( Math.ceil( size ) );\n      size = Math.max( size, 4 );\n\n      this.boneTextureWidth = size;\n      this.boneTextureHeight = size;\n\n      this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n      this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );\n\n    } else {\n\n      this.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n    }\n\n    // use the supplied bone inverses or calculate the inverses\n\n    if ( boneInverses === undefined ) {\n\n      this.calculateInverses();\n\n    } else {\n\n      if ( this.bones.length === boneInverses.length ) {\n\n        this.boneInverses = boneInverses.slice( 0 );\n\n      } else {\n\n        console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n        this.boneInverses = [];\n\n        for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n          this.boneInverses.push( new Matrix4() );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  Object.assign( Skeleton.prototype, {\n\n    calculateInverses: function () {\n\n      this.boneInverses = [];\n\n      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n        var inverse = new Matrix4();\n\n        if ( this.bones[ b ] ) {\n\n          inverse.getInverse( this.bones[ b ].matrixWorld );\n\n        }\n\n        this.boneInverses.push( inverse );\n\n      }\n\n    },\n\n    pose: function () {\n\n      var bone;\n\n      // recover the bind-time world matrices\n\n      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n        bone = this.bones[ b ];\n\n        if ( bone ) {\n\n          bone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n        }\n\n      }\n\n      // compute the local matrices, positions, rotations and scales\n\n      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n        bone = this.bones[ b ];\n\n        if ( bone ) {\n\n          if ( bone.parent && bone.parent.isBone ) {\n\n            bone.matrix.getInverse( bone.parent.matrixWorld );\n            bone.matrix.multiply( bone.matrixWorld );\n\n          } else {\n\n            bone.matrix.copy( bone.matrixWorld );\n\n          }\n\n          bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n        }\n\n      }\n\n    },\n\n    update: ( function () {\n\n      var offsetMatrix = new Matrix4();\n\n      return function update() {\n\n        // flatten bone matrices to array\n\n        for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n          // compute the offset between the current and the original transform\n\n          var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n          offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n          offsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n        }\n\n        if ( this.useVertexTexture ) {\n\n          this.boneTexture.needsUpdate = true;\n\n        }\n\n      };\n\n    } )(),\n\n    clone: function () {\n\n      return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n    }\n\n  } );\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author ikerr / http://verold.com\n   */\n\n  function Bone() {\n\n    Object3D.call( this );\n\n    this.type = 'Bone';\n\n  }\n\n  Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Bone,\n\n    isBone: true\n\n  } );\n\n  /**\n   * @author mikael emtinger / http://gomo.se/\n   * @author alteredq / http://alteredqualia.com/\n   * @author ikerr / http://verold.com\n   */\n\n  function SkinnedMesh( geometry, material, useVertexTexture ) {\n\n    Mesh.call( this, geometry, material );\n\n    this.type = 'SkinnedMesh';\n\n    this.bindMode = \"attached\";\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n\n    // init bones\n\n    // TODO: remove bone creation as there is no reason (other than\n    // convenience) for THREE.SkinnedMesh to do this.\n\n    var bones = [];\n\n    if ( this.geometry && this.geometry.bones !== undefined ) {\n\n      var bone, gbone;\n\n      for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n        gbone = this.geometry.bones[ b ];\n\n        bone = new Bone();\n        bones.push( bone );\n\n        bone.name = gbone.name;\n        bone.position.fromArray( gbone.pos );\n        bone.quaternion.fromArray( gbone.rotq );\n        if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n      }\n\n      for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n        gbone = this.geometry.bones[ b ];\n\n        if ( gbone.parent !== - 1 && gbone.parent !== null &&\n            bones[ gbone.parent ] !== undefined ) {\n\n          bones[ gbone.parent ].add( bones[ b ] );\n\n        } else {\n\n          this.add( bones[ b ] );\n\n        }\n\n      }\n\n    }\n\n    this.normalizeSkinWeights();\n\n    this.updateMatrixWorld( true );\n    this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n  }\n\n  SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\n\n    constructor: SkinnedMesh,\n\n    isSkinnedMesh: true,\n\n    bind: function( skeleton, bindMatrix ) {\n\n      this.skeleton = skeleton;\n\n      if ( bindMatrix === undefined ) {\n\n        this.updateMatrixWorld( true );\n\n        this.skeleton.calculateInverses();\n\n        bindMatrix = this.matrixWorld;\n\n      }\n\n      this.bindMatrix.copy( bindMatrix );\n      this.bindMatrixInverse.getInverse( bindMatrix );\n\n    },\n\n    pose: function () {\n\n      this.skeleton.pose();\n\n    },\n\n    normalizeSkinWeights: function () {\n\n      if ( this.geometry && this.geometry.isGeometry ) {\n\n        for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n          var sw = this.geometry.skinWeights[ i ];\n\n          var scale = 1.0 / sw.lengthManhattan();\n\n          if ( scale !== Infinity ) {\n\n            sw.multiplyScalar( scale );\n\n          } else {\n\n            sw.set( 1, 0, 0, 0 ); // do something reasonable\n\n          }\n\n        }\n\n      } else if ( this.geometry && this.geometry.isBufferGeometry ) {\n\n        var vec = new Vector4();\n\n        var skinWeight = this.geometry.attributes.skinWeight;\n\n        for ( var i = 0; i < skinWeight.count; i ++ ) {\n\n          vec.x = skinWeight.getX( i );\n          vec.y = skinWeight.getY( i );\n          vec.z = skinWeight.getZ( i );\n          vec.w = skinWeight.getW( i );\n\n          var scale = 1.0 / vec.lengthManhattan();\n\n          if ( scale !== Infinity ) {\n\n            vec.multiplyScalar( scale );\n\n          } else {\n\n            vec.set( 1, 0, 0, 0 ); // do something reasonable\n\n          }\n\n          skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n        }\n\n      }\n\n    },\n\n    updateMatrixWorld: function( force ) {\n\n      Mesh.prototype.updateMatrixWorld.call( this, true );\n\n      if ( this.bindMode === \"attached\" ) {\n\n        this.bindMatrixInverse.getInverse( this.matrixWorld );\n\n      } else if ( this.bindMode === \"detached\" ) {\n\n        this.bindMatrixInverse.getInverse( this.bindMatrix );\n\n      } else {\n\n        console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n      }\n\n    },\n\n    clone: function() {\n\n      return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *\n   *  linewidth: <float>,\n   *  linecap: \"round\",\n   *  linejoin: \"round\"\n   * }\n   */\n\n  function LineBasicMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'LineBasicMaterial';\n\n    this.color = new Color( 0xffffff );\n\n    this.linewidth = 1;\n    this.linecap = 'round';\n    this.linejoin = 'round';\n\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  LineBasicMaterial.prototype = Object.create( Material.prototype );\n  LineBasicMaterial.prototype.constructor = LineBasicMaterial;\n\n  LineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n  LineBasicMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Line( geometry, material, mode ) {\n\n    if ( mode === 1 ) {\n\n      console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n      return new LineSegments( geometry, material );\n\n    }\n\n    Object3D.call( this );\n\n    this.type = 'Line';\n\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n    this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n  }\n\n  Line.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Line,\n\n    isLine: true,\n\n    raycast: ( function () {\n\n      var inverseMatrix = new Matrix4();\n      var ray = new Ray();\n      var sphere = new Sphere();\n\n      return function raycast( raycaster, intersects ) {\n\n        var precision = raycaster.linePrecision;\n        var precisionSq = precision * precision;\n\n        var geometry = this.geometry;\n        var matrixWorld = this.matrixWorld;\n\n        // Checking boundingSphere distance to ray\n\n        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n        sphere.copy( geometry.boundingSphere );\n        sphere.applyMatrix4( matrixWorld );\n\n        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n        //\n\n        inverseMatrix.getInverse( matrixWorld );\n        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n        var vStart = new Vector3();\n        var vEnd = new Vector3();\n        var interSegment = new Vector3();\n        var interRay = new Vector3();\n        var step = (this && this.isLineSegments) ? 2 : 1;\n\n        if ( geometry.isBufferGeometry ) {\n\n          var index = geometry.index;\n          var attributes = geometry.attributes;\n          var positions = attributes.position.array;\n\n          if ( index !== null ) {\n\n            var indices = index.array;\n\n            for ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n              var a = indices[ i ];\n              var b = indices[ i + 1 ];\n\n              vStart.fromArray( positions, a * 3 );\n              vEnd.fromArray( positions, b * 3 );\n\n              var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n              if ( distSq > precisionSq ) continue;\n\n              interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n              var distance = raycaster.ray.origin.distanceTo( interRay );\n\n              if ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n              intersects.push( {\n\n                distance: distance,\n                // What do we want? intersection point on the ray or on the segment??\n                // point: raycaster.ray.at( distance ),\n                point: interSegment.clone().applyMatrix4( this.matrixWorld ),\n                index: i,\n                face: null,\n                faceIndex: null,\n                object: this\n\n              } );\n\n            }\n\n          } else {\n\n            for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n              vStart.fromArray( positions, 3 * i );\n              vEnd.fromArray( positions, 3 * i + 3 );\n\n              var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n              if ( distSq > precisionSq ) continue;\n\n              interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n              var distance = raycaster.ray.origin.distanceTo( interRay );\n\n              if ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n              intersects.push( {\n\n                distance: distance,\n                // What do we want? intersection point on the ray or on the segment??\n                // point: raycaster.ray.at( distance ),\n                point: interSegment.clone().applyMatrix4( this.matrixWorld ),\n                index: i,\n                face: null,\n                faceIndex: null,\n                object: this\n\n              } );\n\n            }\n\n          }\n\n        } else if ( geometry.isGeometry ) {\n\n          var vertices = geometry.vertices;\n          var nbVertices = vertices.length;\n\n          for ( var i = 0; i < nbVertices - 1; i += step ) {\n\n            var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n            if ( distSq > precisionSq ) continue;\n\n            interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n            var distance = raycaster.ray.origin.distanceTo( interRay );\n\n            if ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n            intersects.push( {\n\n              distance: distance,\n              // What do we want? intersection point on the ray or on the segment??\n              // point: raycaster.ray.at( distance ),\n              point: interSegment.clone().applyMatrix4( this.matrixWorld ),\n              index: i,\n              face: null,\n              faceIndex: null,\n              object: this\n\n            } );\n\n          }\n\n        }\n\n      };\n\n    }() ),\n\n    clone: function () {\n\n      return new this.constructor( this.geometry, this.material ).copy( this );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function LineSegments( geometry, material ) {\n\n    Line.call( this, geometry, material );\n\n    this.type = 'LineSegments';\n\n  }\n\n  LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\n\n    constructor: LineSegments,\n\n    isLineSegments: true\n\n  } );\n\n  /**\n   * @author mgreter / http://github.com/mgreter\n   */\n\n  function LineLoop( geometry, material ) {\n\n    Line.call( this, geometry, material );\n\n    this.type = 'LineLoop';\n\n  }\n\n  LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\n\n    constructor: LineLoop,\n\n    isLineLoop: true,\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  size: <float>,\n   *  sizeAttenuation: <bool>\n   * }\n   */\n\n  function PointsMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'PointsMaterial';\n\n    this.color = new Color( 0xffffff );\n\n    this.map = null;\n\n    this.size = 1;\n    this.sizeAttenuation = true;\n\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  PointsMaterial.prototype = Object.create( Material.prototype );\n  PointsMaterial.prototype.constructor = PointsMaterial;\n\n  PointsMaterial.prototype.isPointsMaterial = true;\n\n  PointsMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n\n    this.map = source.map;\n\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n\n    return this;\n\n  };\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Points( geometry, material ) {\n\n    Object3D.call( this );\n\n    this.type = 'Points';\n\n    this.geometry = geometry !== undefined ? geometry : new BufferGeometry();\n    this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\n\n  }\n\n  Points.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Points,\n\n    isPoints: true,\n\n    raycast: ( function () {\n\n      var inverseMatrix = new Matrix4();\n      var ray = new Ray();\n      var sphere = new Sphere();\n\n      return function raycast( raycaster, intersects ) {\n\n        var object = this;\n        var geometry = this.geometry;\n        var matrixWorld = this.matrixWorld;\n        var threshold = raycaster.params.Points.threshold;\n\n        // Checking boundingSphere distance to ray\n\n        if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n        sphere.copy( geometry.boundingSphere );\n        sphere.applyMatrix4( matrixWorld );\n\n        if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n        //\n\n        inverseMatrix.getInverse( matrixWorld );\n        ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n        var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n        var localThresholdSq = localThreshold * localThreshold;\n        var position = new Vector3();\n\n        function testPoint( point, index ) {\n\n          var rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n          if ( rayPointDistanceSq < localThresholdSq ) {\n\n            var intersectPoint = ray.closestPointToPoint( point );\n            intersectPoint.applyMatrix4( matrixWorld );\n\n            var distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n            if ( distance < raycaster.near || distance > raycaster.far ) return;\n\n            intersects.push( {\n\n              distance: distance,\n              distanceToRay: Math.sqrt( rayPointDistanceSq ),\n              point: intersectPoint.clone(),\n              index: index,\n              face: null,\n              object: object\n\n            } );\n\n          }\n\n        }\n\n        if ( geometry.isBufferGeometry ) {\n\n          var index = geometry.index;\n          var attributes = geometry.attributes;\n          var positions = attributes.position.array;\n\n          if ( index !== null ) {\n\n            var indices = index.array;\n\n            for ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n              var a = indices[ i ];\n\n              position.fromArray( positions, a * 3 );\n\n              testPoint( position, a );\n\n            }\n\n          } else {\n\n            for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n              position.fromArray( positions, i * 3 );\n\n              testPoint( position, i );\n\n            }\n\n          }\n\n        } else {\n\n          var vertices = geometry.vertices;\n\n          for ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n            testPoint( vertices[ i ], i );\n\n          }\n\n        }\n\n      };\n\n    }() ),\n\n    clone: function () {\n\n      return new this.constructor( this.geometry, this.material ).copy( this );\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Group() {\n\n    Object3D.call( this );\n\n    this.type = 'Group';\n\n  }\n\n  Group.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Group\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n    Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n    this.generateMipmaps = false;\n\n    var scope = this;\n\n    function update() {\n\n      requestAnimationFrame( update );\n\n      if ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n        scope.needsUpdate = true;\n\n      }\n\n    }\n\n    update();\n\n  }\n\n  VideoTexture.prototype = Object.create( Texture.prototype );\n  VideoTexture.prototype.constructor = VideoTexture;\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n    this.image = { width: width, height: height };\n    this.mipmaps = mipmaps;\n\n    // no flipping for cube textures\n    // (also flipping doesn't work for compressed textures )\n\n    this.flipY = false;\n\n    // can't generate mipmaps for compressed textures\n    // mips must be embedded in DDS files\n\n    this.generateMipmaps = false;\n\n  }\n\n  CompressedTexture.prototype = Object.create( Texture.prototype );\n  CompressedTexture.prototype.constructor = CompressedTexture;\n\n  CompressedTexture.prototype.isCompressedTexture = true;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n    Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n    this.needsUpdate = true;\n\n  }\n\n  CanvasTexture.prototype = Object.create( Texture.prototype );\n  CanvasTexture.prototype.constructor = CanvasTexture;\n\n  /**\n   * @author Matt DesLauriers / @mattdesl\n   * @author atix / arthursilber.de\n   */\n\n  function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n    format = format !== undefined ? format : DepthFormat;\n\n    if ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n      throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )\n\n    }\n\n    if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\n    if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n    Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n    this.image = { width: width, height: height };\n\n    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n    this.flipY = false;\n    this.generateMipmaps  = false;\n\n  }\n\n  DepthTexture.prototype = Object.create( Texture.prototype );\n  DepthTexture.prototype.constructor = DepthTexture;\n  DepthTexture.prototype.isDepthTexture = true;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function WireframeGeometry( geometry ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'WireframeGeometry';\n\n    // buffer\n\n    var vertices = [];\n\n    // helper variables\n\n    var i, j, l, o, ol;\n    var edge = [ 0, 0 ], edges = {}, e;\n    var key, keys = [ 'a', 'b', 'c' ];\n    var vertex;\n\n    // different logic for Geometry and BufferGeometry\n\n    if ( geometry && geometry.isGeometry ) {\n\n      // create a data structure that contains all edges without duplicates\n\n      var faces = geometry.faces;\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        var face = faces[ i ];\n\n        for ( j = 0; j < 3; j ++ ) {\n\n          edge[ 0 ] = face[ keys[ j ] ];\n          edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n          edge.sort( sortFunction ); // sorting prevents duplicates\n\n          key = edge.toString();\n\n          if ( edges[ key ] === undefined ) {\n\n            edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n          }\n\n        }\n\n      }\n\n      // generate vertices\n\n      for ( key in edges ) {\n\n        e = edges[ key ];\n\n        vertex = geometry.vertices[ e.index1 ];\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        vertex = geometry.vertices[ e.index2 ];\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n      }\n\n    } else if ( geometry && geometry.isBufferGeometry ) {\n\n      var position, indices, groups;\n      var group, start, count;\n      var index1, index2;\n\n      vertex = new Vector3();\n\n      if ( geometry.index !== null ) {\n\n        // indexed BufferGeometry\n\n        position = geometry.attributes.position;\n        indices = geometry.index;\n        groups = geometry.groups;\n\n        if ( groups.length === 0 ) {\n\n          groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n        }\n\n        // create a data structure that contains all eges without duplicates\n\n        for ( o = 0, ol = groups.length; o < ol; ++ o ) {\n\n          group = groups[ o ];\n\n          start = group.start;\n          count = group.count;\n\n          for ( i = start, l = ( start + count ); i < l; i += 3 ) {\n\n            for ( j = 0; j < 3; j ++ ) {\n\n              edge[ 0 ] = indices.getX( i + j );\n              edge[ 1 ] = indices.getX( i + ( j + 1 ) % 3 );\n              edge.sort( sortFunction ); // sorting prevents duplicates\n\n              key = edge.toString();\n\n              if ( edges[ key ] === undefined ) {\n\n                edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\n\n              }\n\n            }\n\n          }\n\n        }\n\n        // generate vertices\n\n        for ( key in edges ) {\n\n          e = edges[ key ];\n\n          vertex.fromBufferAttribute( position, e.index1 );\n          vertices.push( vertex.x, vertex.y, vertex.z );\n\n          vertex.fromBufferAttribute( position, e.index2 );\n          vertices.push( vertex.x, vertex.y, vertex.z );\n\n        }\n\n      } else {\n\n        // non-indexed BufferGeometry\n\n        position = geometry.attributes.position;\n\n        for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n          for ( j = 0; j < 3; j ++ ) {\n\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n            index1 = 3 * i + j;\n            vertex.fromBufferAttribute( position, index1 );\n            vertices.push( vertex.x, vertex.y, vertex.z );\n\n            index2 = 3 * i + ( ( j + 1 ) % 3 );\n            vertex.fromBufferAttribute( position, index2 );\n            vertices.push( vertex.x, vertex.y, vertex.z );\n\n          }\n\n        }\n\n      }\n\n    }\n\n    // build geometry\n\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n    // custom array sort function\n\n    function sortFunction( a, b ) {\n\n      return a - b;\n\n    }\n\n  }\n\n  WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\n  WireframeGeometry.prototype.constructor = WireframeGeometry;\n\n  /**\n   * @author zz85 / https://github.com/zz85\n   *\n   * Parametric Surfaces Geometry\n   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n   */\n\n  function ParametricGeometry( func, slices, stacks ) {\n\n    Geometry.call( this );\n\n    this.type = 'ParametricGeometry';\n\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    };\n\n    this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\n    this.mergeVertices();\n\n  }\n\n  ParametricGeometry.prototype = Object.create( Geometry.prototype );\n  ParametricGeometry.prototype.constructor = ParametricGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   *\n   * Parametric Surfaces Geometry\n   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n   */\n\n  function ParametricBufferGeometry( func, slices, stacks ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'ParametricBufferGeometry';\n\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    };\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var uvs = [];\n\n    var i, j;\n\n    // generate vertices and uvs\n\n    var sliceCount = slices + 1;\n\n    for ( i = 0; i <= stacks; i ++ ) {\n\n      var v = i / stacks;\n\n      for ( j = 0; j <= slices; j ++ ) {\n\n        var u = j / slices;\n\n        var p = func( u, v );\n        vertices.push( p.x, p.y, p.z );\n\n        uvs.push( u, v );\n\n      }\n\n    }\n\n    // generate indices\n\n    for ( i = 0; i < stacks; i ++ ) {\n\n      for ( j = 0; j < slices; j ++ ) {\n\n        var a = i * sliceCount + j;\n        var b = i * sliceCount + j + 1;\n        var c = ( i + 1 ) * sliceCount + j + 1;\n        var d = ( i + 1 ) * sliceCount + j;\n\n        // faces one and two\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    // generate normals\n\n    this.computeVertexNormals();\n\n  }\n\n  ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\n\n  /**\n   * @author clockworkgeek / https://github.com/clockworkgeek\n   * @author timothypratley / https://github.com/timothypratley\n   * @author WestLangley / http://github.com/WestLangley\n  */\n\n  function PolyhedronGeometry( vertices, indices, radius, detail ) {\n\n    Geometry.call( this );\n\n    this.type = 'PolyhedronGeometry';\n\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    };\n\n    this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\n    this.mergeVertices();\n\n  }\n\n  PolyhedronGeometry.prototype = Object.create( Geometry.prototype );\n  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'PolyhedronBufferGeometry';\n\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    };\n\n    radius = radius || 1;\n    detail = detail || 0;\n\n    // default buffer data\n\n    var vertexBuffer = [];\n    var uvBuffer = [];\n\n    // the subdivision creates the vertex buffer data\n\n    subdivide( detail );\n\n    // all vertices should lie on a conceptual sphere with a given radius\n\n    appplyRadius( radius );\n\n    // finally, create the uv data\n\n    generateUVs();\n\n    // build non-indexed geometry\n\n    this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n    this.normalizeNormals();\n\n    // helper functions\n\n    function subdivide( detail ) {\n\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3();\n\n      // iterate over all faces and apply a subdivison with the given detail value\n\n      for ( var i = 0; i < indices.length; i += 3 ) {\n\n        // get the vertices of the face\n\n        getVertexByIndex( indices[ i + 0 ], a );\n        getVertexByIndex( indices[ i + 1 ], b );\n        getVertexByIndex( indices[ i + 2 ], c );\n\n        // perform subdivision\n\n        subdivideFace( a, b, c, detail );\n\n      }\n\n    }\n\n    function subdivideFace( a, b, c, detail ) {\n\n      var cols = Math.pow( 2, detail );\n\n      // we use this multidimensional array as a data structure for creating the subdivision\n\n      var v = [];\n\n      var i, j;\n\n      // construct all of the vertices for this subdivision\n\n      for ( i = 0; i <= cols; i ++ ) {\n\n        v[ i ] = [];\n\n        var aj = a.clone().lerp( c, i / cols );\n        var bj = b.clone().lerp( c, i / cols );\n\n        var rows = cols - i;\n\n        for ( j = 0; j <= rows; j ++ ) {\n\n          if ( j === 0 && i === cols ) {\n\n            v[ i ][ j ] = aj;\n\n          } else {\n\n            v[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n          }\n\n        }\n\n      }\n\n      // construct all of the faces\n\n      for ( i = 0; i < cols; i ++ ) {\n\n        for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n          var k = Math.floor( j / 2 );\n\n          if ( j % 2 === 0 ) {\n\n            pushVertex( v[ i ][ k + 1 ] );\n            pushVertex( v[ i + 1 ][ k ] );\n            pushVertex( v[ i ][ k ] );\n\n          } else {\n\n            pushVertex( v[ i ][ k + 1 ] );\n            pushVertex( v[ i + 1 ][ k + 1 ] );\n            pushVertex( v[ i + 1 ][ k ] );\n\n          }\n\n        }\n\n      }\n\n    }\n\n    function appplyRadius( radius ) {\n\n      var vertex = new Vector3();\n\n      // iterate over the entire buffer and apply the radius to each vertex\n\n      for ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n        vertex.x = vertexBuffer[ i + 0 ];\n        vertex.y = vertexBuffer[ i + 1 ];\n        vertex.z = vertexBuffer[ i + 2 ];\n\n        vertex.normalize().multiplyScalar( radius );\n\n        vertexBuffer[ i + 0 ] = vertex.x;\n        vertexBuffer[ i + 1 ] = vertex.y;\n        vertexBuffer[ i + 2 ] = vertex.z;\n\n      }\n\n    }\n\n    function generateUVs() {\n\n      var vertex = new Vector3();\n\n      for ( var i = 0; i < vertexBuffer.length; i += 3 ) {\n\n        vertex.x = vertexBuffer[ i + 0 ];\n        vertex.y = vertexBuffer[ i + 1 ];\n        vertex.z = vertexBuffer[ i + 2 ];\n\n        var u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n        var v = inclination( vertex ) / Math.PI + 0.5;\n        uvBuffer.push( u, 1 - v );\n\n      }\n\n      correctUVs();\n\n      correctSeam();\n\n    }\n\n    function correctSeam() {\n\n      // handle case when face straddles the seam, see #3269\n\n      for ( var i = 0; i < uvBuffer.length; i += 6 ) {\n\n        // uv data of a single face\n\n        var x0 = uvBuffer[ i + 0 ];\n        var x1 = uvBuffer[ i + 2 ];\n        var x2 = uvBuffer[ i + 4 ];\n\n        var max = Math.max( x0, x1, x2 );\n        var min = Math.min( x0, x1, x2 );\n\n        // 0.9 is somewhat arbitrary\n\n        if ( max > 0.9 && min < 0.1 ) {\n\n          if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n          if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n          if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n        }\n\n      }\n\n    }\n\n    function pushVertex( vertex ) {\n\n      vertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n    }\n\n    function getVertexByIndex( index, vertex ) {\n\n      var stride = index * 3;\n\n      vertex.x = vertices[ stride + 0 ];\n      vertex.y = vertices[ stride + 1 ];\n      vertex.z = vertices[ stride + 2 ];\n\n    }\n\n    function correctUVs() {\n\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3();\n\n      var centroid = new Vector3();\n\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n        a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n        b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n        c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n        uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n        uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n        uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n        centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n        var azi = azimuth( centroid );\n\n        correctUV( uvA, j + 0, a, azi );\n        correctUV( uvB, j + 2, b, azi );\n        correctUV( uvC, j + 4, c, azi );\n\n      }\n\n    }\n\n    function correctUV( uv, stride, vector, azimuth ) {\n\n      if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n        uvBuffer[ stride ] = uv.x - 1;\n\n      }\n\n      if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n        uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n      }\n\n    }\n\n    // Angle around the Y axis, counter-clockwise when looking from above.\n\n    function azimuth( vector ) {\n\n      return Math.atan2( vector.z, - vector.x );\n\n    }\n\n\n    // Angle above the XZ plane.\n\n    function inclination( vector ) {\n\n      return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n    }\n\n  }\n\n  PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\n\n  /**\n   * @author timothypratley / https://github.com/timothypratley\n   */\n\n  function TetrahedronGeometry( radius, detail ) {\n\n    Geometry.call( this );\n\n    this.type = 'TetrahedronGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n    this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\n    this.mergeVertices();\n\n  }\n\n  TetrahedronGeometry.prototype = Object.create( Geometry.prototype );\n  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function TetrahedronBufferGeometry( radius, detail ) {\n\n    var vertices = [\n      1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n    ];\n\n    var indices = [\n      2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n    ];\n\n    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n    this.type = 'TetrahedronBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n  }\n\n  TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\n\n  /**\n   * @author timothypratley / https://github.com/timothypratley\n   */\n\n  function OctahedronGeometry( radius, detail ) {\n\n    Geometry.call( this );\n\n    this.type = 'OctahedronGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n    this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\n    this.mergeVertices();\n\n  }\n\n  OctahedronGeometry.prototype = Object.create( Geometry.prototype );\n  OctahedronGeometry.prototype.constructor = OctahedronGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function OctahedronBufferGeometry( radius, detail ) {\n\n    var vertices = [\n      1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n    ];\n\n    var indices = [\n      0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n    ];\n\n    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n    this.type = 'OctahedronBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n  }\n\n  OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\n\n  /**\n   * @author timothypratley / https://github.com/timothypratley\n   */\n\n  function IcosahedronGeometry( radius, detail ) {\n\n    Geometry.call( this );\n\n    this.type = 'IcosahedronGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n    this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\n    this.mergeVertices();\n\n  }\n\n  IcosahedronGeometry.prototype = Object.create( Geometry.prototype );\n  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function IcosahedronBufferGeometry( radius, detail ) {\n\n    var t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n    var vertices = [\n      - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n       0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n       t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n    ];\n\n    var indices = [\n       0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n       1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n       3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n       4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n    ];\n\n    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n    this.type = 'IcosahedronBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n  }\n\n  IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\n\n  /**\n   * @author Abe Pazos / https://hamoid.com\n   */\n\n  function DodecahedronGeometry( radius, detail ) {\n\n    Geometry.call( this );\n\n    this.type = 'DodecahedronGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n    this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\n    this.mergeVertices();\n\n  }\n\n  DodecahedronGeometry.prototype = Object.create( Geometry.prototype );\n  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function DodecahedronBufferGeometry( radius, detail ) {\n\n    var t = ( 1 + Math.sqrt( 5 ) ) / 2;\n    var r = 1 / t;\n\n    var vertices = [\n\n      // (1, 1, 1)\n      - 1, - 1, - 1,    - 1, - 1,  1,\n      - 1,  1, - 1,    - 1,  1,  1,\n        1, - 1, - 1,     1, - 1,  1,\n        1,  1, - 1,     1,  1,  1,\n\n      // (0, 1/ ,  )\n       0, - r, - t,     0, - r,  t,\n       0,  r, - t,     0,  r,  t,\n\n      // (1/ ,  , 0)\n      - r, - t,  0,    - r,  t,  0,\n       r, - t,  0,     r,  t,  0,\n\n      // ( , 0, 1/ )\n      - t,  0, - r,     t,  0, - r,\n      - t,  0,  r,     t,  0,  r\n    ];\n\n    var indices = [\n       3, 11,  7,      3,  7, 15,      3, 15, 13,\n       7, 19, 17,      7, 17,  6,      7,  6, 15,\n      17,  4,  8,     17,  8, 10,     17, 10,  6,\n       8,  0, 16,      8, 16,  2,      8,  2, 10,\n       0, 12,  1,      0,  1, 18,      0, 18, 16,\n       6, 10,  2,      6,  2, 13,      6, 13, 15,\n       2, 16, 18,      2, 18,  3,      2,  3, 13,\n      18,  1,  9,     18,  9, 11,     18, 11,  3,\n       4, 14, 12,      4, 12,  0,      4,  0,  8,\n      11,  9,  5,     11,  5, 19,     11, 19,  7,\n      19,  5, 14,     19, 14,  4,     19,  4, 17,\n       1, 12, 14,      1, 14,  5,      1,  5,  9\n    ];\n\n    PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\n\n    this.type = 'DodecahedronBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      detail: detail\n    };\n\n  }\n\n  DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\n  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\n\n  /**\n   * @author oosmoxiecode / https://github.com/oosmoxiecode\n   * @author WestLangley / https://github.com/WestLangley\n   * @author zz85 / https://github.com/zz85\n   * @author miningold / https://github.com/miningold\n   * @author jonobr1 / https://github.com/jonobr1\n   *\n   * Creates a tube which extrudes along a 3d spline.\n   */\n\n  function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\n\n    Geometry.call( this );\n\n    this.type = 'TubeGeometry';\n\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n\n    if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\n\n    var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\n\n    // expose internals\n\n    this.tangents = bufferGeometry.tangents;\n    this.normals = bufferGeometry.normals;\n    this.binormals = bufferGeometry.binormals;\n\n    // create geometry\n\n    this.fromBufferGeometry( bufferGeometry );\n    this.mergeVertices();\n\n  }\n\n  TubeGeometry.prototype = Object.create( Geometry.prototype );\n  TubeGeometry.prototype.constructor = TubeGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'TubeBufferGeometry';\n\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n\n    tubularSegments = tubularSegments || 64;\n    radius = radius || 1;\n    radialSegments = radialSegments || 8;\n    closed = closed || false;\n\n    var frames = path.computeFrenetFrames( tubularSegments, closed );\n\n    // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n\n    // helper variables\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var uv = new Vector2();\n\n    var i, j;\n\n    // buffer\n\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var indices = [];\n\n    // create buffer data\n\n    generateBufferData();\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    // functions\n\n    function generateBufferData() {\n\n      for ( i = 0; i < tubularSegments; i ++ ) {\n\n        generateSegment( i );\n\n      }\n\n      // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n      generateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n      // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs();\n\n      // finally create faces\n\n      generateIndices();\n\n    }\n\n    function generateSegment( i ) {\n\n      // we use getPointAt to sample evenly distributed points from the given path\n\n      var P = path.getPointAt( i / tubularSegments );\n\n      // retrieve corresponding normal and binormal\n\n      var N = frames.normals[ i ];\n      var B = frames.binormals[ i ];\n\n      // generate normals and vertices for the current segment\n\n      for ( j = 0; j <= radialSegments; j ++ ) {\n\n        var v = j / radialSegments * Math.PI * 2;\n\n        var sin =   Math.sin( v );\n        var cos = - Math.cos( v );\n\n        // normal\n\n        normal.x = ( cos * N.x + sin * B.x );\n        normal.y = ( cos * N.y + sin * B.y );\n        normal.z = ( cos * N.z + sin * B.z );\n        normal.normalize();\n\n        normals.push( normal.x, normal.y, normal.z );\n\n        // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n      }\n\n    }\n\n    function generateIndices() {\n\n      for ( j = 1; j <= tubularSegments; j ++ ) {\n\n        for ( i = 1; i <= radialSegments; i ++ ) {\n\n          var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n          var b = ( radialSegments + 1 ) * j + ( i - 1 );\n          var c = ( radialSegments + 1 ) * j + i;\n          var d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n          // faces\n\n          indices.push( a, b, d );\n          indices.push( b, c, d );\n\n        }\n\n      }\n\n    }\n\n    function generateUVs() {\n\n      for ( i = 0; i <= tubularSegments; i ++ ) {\n\n        for ( j = 0; j <= radialSegments; j ++ ) {\n\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n\n          uvs.push( uv.x, uv.y );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\n\n  /**\n   * @author oosmoxiecode\n   */\n\n  function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n    Geometry.call( this );\n\n    this.type = 'TorusKnotGeometry';\n\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n\n    if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n    this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n    this.mergeVertices();\n\n  }\n\n  TorusKnotGeometry.prototype = Object.create( Geometry.prototype );\n  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   * see: http://www.blackpawn.com/texts/pqtorus/\n   */\n\n  function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'TorusKnotBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n\n    radius = radius || 100;\n    tube = tube || 40;\n    tubularSegments = Math.floor( tubularSegments ) || 64;\n    radialSegments = Math.floor( radialSegments ) || 8;\n    p = p || 2;\n    q = q || 3;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var i, j;\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var uv = new Vector2();\n\n    var P1 = new Vector3();\n    var P2 = new Vector3();\n\n    var B = new Vector3();\n    var T = new Vector3();\n    var N = new Vector3();\n\n    // generate vertices, normals and uvs\n\n    for ( i = 0; i <= tubularSegments; ++ i ) {\n\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n      var u = i / tubularSegments * p * Math.PI * 2;\n\n      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve( u, p, q, radius, P1 );\n      calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n      // calculate orthonormal basis\n\n      T.subVectors( P2, P1 );\n      N.addVectors( P2, P1 );\n      B.crossVectors( T, N );\n      N.crossVectors( B, T );\n\n      // normalize B, N. T can be ignored, we don't use it\n\n      B.normalize();\n      N.normalize();\n\n      for ( j = 0; j <= radialSegments; ++ j ) {\n\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n        var v = j / radialSegments * Math.PI * 2;\n        var cx = - tube * Math.cos( v );\n        var cy = tube * Math.sin( v );\n\n        // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n        vertex.x = P1.x + ( cx * N.x + cy * B.x );\n        vertex.y = P1.y + ( cx * N.y + cy * B.y );\n        vertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors( vertex, P1 ).normalize();\n\n        normals.push( normal.x, normal.y, normal.z );\n\n        // uv\n\n        uvs.push( i / tubularSegments );\n        uvs.push( j / radialSegments );\n\n      }\n\n    }\n\n    // generate indices\n\n    for ( j = 1; j <= tubularSegments; j ++ ) {\n\n      for ( i = 1; i <= radialSegments; i ++ ) {\n\n        // indices\n\n        var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n        var b = ( radialSegments + 1 ) * j + ( i - 1 );\n        var c = ( radialSegments + 1 ) * j + i;\n        var d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n        // faces\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    // this function calculates the current position on the torus curve\n\n    function calculatePositionOnCurve( u, p, q, radius, position ) {\n\n      var cu = Math.cos( u );\n      var su = Math.sin( u );\n      var quOverP = q / p * u;\n      var cs = Math.cos( quOverP );\n\n      position.x = radius * ( 2 + cs ) * 0.5 * cu;\n      position.y = radius * ( 2 + cs ) * su * 0.5;\n      position.z = radius * Math.sin( quOverP ) * 0.5;\n\n    }\n\n  }\n\n  TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\n\n  /**\n   * @author oosmoxiecode\n   * @author mrdoob / http://mrdoob.com/\n   * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n   */\n\n  function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n    Geometry.call( this );\n\n    this.type = 'TorusGeometry';\n\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      radialSegments: radialSegments,\n      tubularSegments: tubularSegments,\n      arc: arc\n    };\n\n    this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n  }\n\n  TorusGeometry.prototype = Object.create( Geometry.prototype );\n  TorusGeometry.prototype.constructor = TorusGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'TorusBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      radialSegments: radialSegments,\n      tubularSegments: tubularSegments,\n      arc: arc\n    };\n\n    radius = radius || 100;\n    tube = tube || 40;\n    radialSegments = Math.floor( radialSegments ) || 8;\n    tubularSegments = Math.floor( tubularSegments ) || 6;\n    arc = arc || Math.PI * 2;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var center = new Vector3();\n    var vertex = new Vector3();\n    var normal = new Vector3();\n\n    var j, i;\n\n    // generate vertices, normals and uvs\n\n    for ( j = 0; j <= radialSegments; j ++ ) {\n\n      for ( i = 0; i <= tubularSegments; i ++ ) {\n\n        var u = i / tubularSegments * arc;\n        var v = j / radialSegments * Math.PI * 2;\n\n        // vertex\n\n        vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n        vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n        vertex.z = tube * Math.sin( v );\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // normal\n\n        center.x = radius * Math.cos( u );\n        center.y = radius * Math.sin( u );\n        normal.subVectors( vertex, center ).normalize();\n\n        normals.push( normal.x, normal.y, normal.z );\n\n        // uv\n\n        uvs.push( i / tubularSegments );\n        uvs.push( j / radialSegments );\n\n      }\n\n    }\n\n    // generate indices\n\n    for ( j = 1; j <= radialSegments; j ++ ) {\n\n      for ( i = 1; i <= tubularSegments; i ++ ) {\n\n        // indices\n\n        var a = ( tubularSegments + 1 ) * j + i - 1;\n        var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n        var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n        var d = ( tubularSegments + 1 ) * j + i;\n\n        // faces\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   */\n\n  var ShapeUtils = {\n\n    // calculate area of the contour polygon\n\n    area: function ( contour ) {\n\n      var n = contour.length;\n      var a = 0.0;\n\n      for ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n        a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n      }\n\n      return a * 0.5;\n\n    },\n\n    triangulate: ( function () {\n\n      /**\n       * This code is a quick port of code written in C++ which was submitted to\n       * flipcode.com by John W. Ratcliff  // July 22, 2000\n       * See original code and more information here:\n       * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n       *\n       * ported to actionscript by Zevan Rosser\n       * www.actionsnippet.com\n       *\n       * ported to javascript by Joshua Koo\n       * http://www.lab4games.net/zz85/blog\n       *\n       */\n\n      function snip( contour, u, v, w, n, verts ) {\n\n        var p;\n        var ax, ay, bx, by;\n        var cx, cy, px, py;\n\n        ax = contour[ verts[ u ] ].x;\n        ay = contour[ verts[ u ] ].y;\n\n        bx = contour[ verts[ v ] ].x;\n        by = contour[ verts[ v ] ].y;\n\n        cx = contour[ verts[ w ] ].x;\n        cy = contour[ verts[ w ] ].y;\n\n        if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;\n\n        var aX, aY, bX, bY, cX, cY;\n        var apx, apy, bpx, bpy, cpx, cpy;\n        var cCROSSap, bCROSScp, aCROSSbp;\n\n        aX = cx - bx;  aY = cy - by;\n        bX = ax - cx;  bY = ay - cy;\n        cX = bx - ax;  cY = by - ay;\n\n        for ( p = 0; p < n; p ++ ) {\n\n          px = contour[ verts[ p ] ].x;\n          py = contour[ verts[ p ] ].y;\n\n          if ( ( ( px === ax ) && ( py === ay ) ) ||\n             ( ( px === bx ) && ( py === by ) ) ||\n             ( ( px === cx ) && ( py === cy ) ) ) continue;\n\n          apx = px - ax;  apy = py - ay;\n          bpx = px - bx;  bpy = py - by;\n          cpx = px - cx;  cpy = py - cy;\n\n          // see if p is inside triangle abc\n\n          aCROSSbp = aX * bpy - aY * bpx;\n          cCROSSap = cX * apy - cY * apx;\n          bCROSScp = bX * cpy - bY * cpx;\n\n          if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n        }\n\n        return true;\n\n      }\n\n      // takes in an contour array and returns\n\n      return function triangulate( contour, indices ) {\n\n        var n = contour.length;\n\n        if ( n < 3 ) return null;\n\n        var result = [],\n          verts = [],\n          vertIndices = [];\n\n        /* we want a counter-clockwise polygon in verts */\n\n        var u, v, w;\n\n        if ( ShapeUtils.area( contour ) > 0.0 ) {\n\n          for ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n        } else {\n\n          for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n        }\n\n        var nv = n;\n\n        /*  remove nv - 2 vertices, creating 1 triangle every time */\n\n        var count = 2 * nv;   /* error detection */\n\n        for ( v = nv - 1; nv > 2; ) {\n\n          /* if we loop, it is probably a non-simple polygon */\n\n          if ( ( count -- ) <= 0 ) {\n\n            //** Triangulate: ERROR - probable bad polygon!\n\n            //throw ( \"Warning, unable to triangulate polygon!\" );\n            //return null;\n            // Sometimes warning is fine, especially polygons are triangulated in reverse.\n            console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n            if ( indices ) return vertIndices;\n            return result;\n\n          }\n\n          /* three consecutive vertices in current polygon, <u,v,w> */\n\n          u = v;    if ( nv <= u ) u = 0;     /* previous */\n          v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n          w = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n          if ( snip( contour, u, v, w, nv, verts ) ) {\n\n            var a, b, c, s, t;\n\n            /* true names of the vertices */\n\n            a = verts[ u ];\n            b = verts[ v ];\n            c = verts[ w ];\n\n            /* output Triangle */\n\n            result.push( [ contour[ a ],\n              contour[ b ],\n              contour[ c ] ] );\n\n\n            vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n            /* remove v from the remaining polygon */\n\n            for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n              verts[ s ] = verts[ t ];\n\n            }\n\n            nv --;\n\n            /* reset error detection counter */\n\n            count = 2 * nv;\n\n          }\n\n        }\n\n        if ( indices ) return vertIndices;\n        return result;\n\n      }\n\n    } )(),\n\n    triangulateShape: function ( contour, holes ) {\n\n      function removeDupEndPts(points) {\n\n        var l = points.length;\n\n        if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n          points.pop();\n\n        }\n\n      }\n\n      removeDupEndPts( contour );\n      holes.forEach( removeDupEndPts );\n\n      function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n        // inOtherPt needs to be collinear to the inSegment\n        if ( inSegPt1.x !== inSegPt2.x ) {\n\n          if ( inSegPt1.x < inSegPt2.x ) {\n\n            return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n          } else {\n\n            return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n          }\n\n        } else {\n\n          if ( inSegPt1.y < inSegPt2.y ) {\n\n            return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n          } else {\n\n            return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n          }\n\n        }\n\n      }\n\n      function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n        var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n        var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n        var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n        var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n        var limit   = seg1dy * seg2dx - seg1dx * seg2dy;\n        var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n        if ( Math.abs( limit ) > Number.EPSILON ) {\n\n          // not parallel\n\n          var perpSeg2;\n          if ( limit > 0 ) {\n\n            if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];\n            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n            if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];\n\n          } else {\n\n            if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];\n            perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n            if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];\n\n          }\n\n          // i.e. to reduce rounding errors\n          // intersection at endpoint of segment#1?\n          if ( perpSeg2 === 0 ) {\n\n            if ( ( inExcludeAdjacentSegs ) &&\n               ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];\n            return [ inSeg1Pt1 ];\n\n          }\n          if ( perpSeg2 === limit ) {\n\n            if ( ( inExcludeAdjacentSegs ) &&\n               ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];\n            return [ inSeg1Pt2 ];\n\n          }\n          // intersection at endpoint of segment#2?\n          if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];\n          if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];\n\n          // return real intersection point\n          var factorSeg1 = perpSeg2 / limit;\n          return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n                y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n        } else {\n\n          // parallel or collinear\n          if ( ( perpSeg1 !== 0 ) ||\n             ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];\n\n          // they are collinear or degenerate\n          var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );  // segment1 is just a point?\n          var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );  // segment2 is just a point?\n          // both segments are points\n          if ( seg1Pt && seg2Pt ) {\n\n            if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n               ( inSeg1Pt1.y !== inSeg2Pt1.y ) )    return [];  // they are distinct  points\n            return [ inSeg1Pt1 ];                             // they are the same point\n\n          }\n          // segment#1  is a single point\n          if ( seg1Pt ) {\n\n            if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )   return [];    // but not in segment#2\n            return [ inSeg1Pt1 ];\n\n          }\n          // segment#2  is a single point\n          if ( seg2Pt ) {\n\n            if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )   return [];    // but not in segment#1\n            return [ inSeg2Pt1 ];\n\n          }\n\n          // they are collinear segments, which might overlap\n          var seg1min, seg1max, seg1minVal, seg1maxVal;\n          var seg2min, seg2max, seg2minVal, seg2maxVal;\n          if ( seg1dx !== 0 ) {\n\n            // the segments are NOT on a vertical line\n            if ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n              seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n              seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n            } else {\n\n              seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n              seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n            }\n            if ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n              seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n              seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n            } else {\n\n              seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n              seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n            }\n\n          } else {\n\n            // the segments are on a vertical line\n            if ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n              seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n              seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n            } else {\n\n              seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n              seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n            }\n            if ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n              seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n              seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n            } else {\n\n              seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n              seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n            }\n\n          }\n          if ( seg1minVal <= seg2minVal ) {\n\n            if ( seg1maxVal <  seg2minVal ) return [];\n            if ( seg1maxVal === seg2minVal )  {\n\n              if ( inExcludeAdjacentSegs )    return [];\n              return [ seg2min ];\n\n            }\n            if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];\n            return  [ seg2min, seg2max ];\n\n          } else {\n\n            if ( seg1minVal >  seg2maxVal ) return [];\n            if ( seg1minVal === seg2maxVal )  {\n\n              if ( inExcludeAdjacentSegs )    return [];\n              return [ seg1min ];\n\n            }\n            if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];\n            return  [ seg1min, seg2max ];\n\n          }\n\n        }\n\n      }\n\n      function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n        // The order of legs is important\n\n        // translation of all points, so that Vertex is at (0,0)\n        var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;\n        var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;\n        var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;\n\n        // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n        var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;\n        var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n        if ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n          // angle != 180 deg.\n\n          var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;\n          // console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n          if ( from2toAngle > 0 ) {\n\n            // main angle < 180 deg.\n            return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n          } else {\n\n            // main angle > 180 deg.\n            return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n          }\n\n        } else {\n\n          // angle == 180 deg.\n          // console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n          return  ( from2otherAngle > 0 );\n\n        }\n\n      }\n\n\n      function removeHoles( contour, holes ) {\n\n        var shape = contour.concat(); // work on this shape\n        var hole;\n\n        function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n          // Check if hole point lies within angle around shape point\n          var lastShapeIdx = shape.length - 1;\n\n          var prevShapeIdx = inShapeIdx - 1;\n          if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;\n\n          var nextShapeIdx = inShapeIdx + 1;\n          if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;\n\n          var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n          if ( ! insideAngle ) {\n\n            // console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n            return  false;\n\n          }\n\n          // Check if shape point lies within angle around hole point\n          var lastHoleIdx = hole.length - 1;\n\n          var prevHoleIdx = inHoleIdx - 1;\n          if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;\n\n          var nextHoleIdx = inHoleIdx + 1;\n          if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;\n\n          insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n          if ( ! insideAngle ) {\n\n            // console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n            return  false;\n\n          }\n\n          return  true;\n\n        }\n\n        function intersectsShapeEdge( inShapePt, inHolePt ) {\n\n          // checks for intersections with shape edges\n          var sIdx, nextIdx, intersection;\n          for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n            nextIdx = sIdx + 1; nextIdx %= shape.length;\n            intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n            if ( intersection.length > 0 )    return  true;\n\n          }\n\n          return  false;\n\n        }\n\n        var indepHoles = [];\n\n        function intersectsHoleEdge( inShapePt, inHolePt ) {\n\n          // checks for intersections with hole edges\n          var ihIdx, chkHole,\n            hIdx, nextIdx, intersection;\n          for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n            chkHole = holes[ indepHoles[ ihIdx ]];\n            for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n              nextIdx = hIdx + 1; nextIdx %= chkHole.length;\n              intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n              if ( intersection.length > 0 )    return  true;\n\n            }\n\n          }\n          return  false;\n\n        }\n\n        var holeIndex, shapeIndex,\n          shapePt, holePt,\n          holeIdx, cutKey, failedCuts = [],\n          tmpShape1, tmpShape2,\n          tmpHole1, tmpHole2;\n\n        for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n          indepHoles.push( h );\n\n        }\n\n        var minShapeIndex = 0;\n        var counter = indepHoles.length * 2;\n        while ( indepHoles.length > 0 ) {\n\n          counter --;\n          if ( counter < 0 ) {\n\n            console.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n            break;\n\n          }\n\n          // search for shape-vertex and hole-vertex,\n          // which can be connected without intersections\n          for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n            shapePt = shape[ shapeIndex ];\n            holeIndex = - 1;\n\n            // search for hole which can be reached without intersections\n            for ( var h = 0; h < indepHoles.length; h ++ ) {\n\n              holeIdx = indepHoles[ h ];\n\n              // prevent multiple checks\n              cutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n              if ( failedCuts[ cutKey ] !== undefined )     continue;\n\n              hole = holes[ holeIdx ];\n              for ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n                holePt = hole[ h2 ];\n                if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )    continue;\n                if ( intersectsShapeEdge( shapePt, holePt ) )   continue;\n                if ( intersectsHoleEdge( shapePt, holePt ) )    continue;\n\n                holeIndex = h2;\n                indepHoles.splice( h, 1 );\n\n                tmpShape1 = shape.slice( 0, shapeIndex + 1 );\n                tmpShape2 = shape.slice( shapeIndex );\n                tmpHole1 = hole.slice( holeIndex );\n                tmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n                shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n                minShapeIndex = shapeIndex;\n\n                // Debug only, to show the selected cuts\n                // glob_CutLines.push( [ shapePt, holePt ] );\n\n                break;\n\n              }\n              if ( holeIndex >= 0 ) break;    // hole-vertex found\n\n              failedCuts[ cutKey ] = true;      // remember failure\n\n            }\n            if ( holeIndex >= 0 ) break;    // hole-vertex found\n\n          }\n\n        }\n\n        return shape;       /* shape with no holes */\n\n      }\n\n\n      var i, il, f, face,\n        key, index,\n        allPointsMap = {};\n\n      // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n      var allpoints = contour.concat();\n\n      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n        Array.prototype.push.apply( allpoints, holes[ h ] );\n\n      }\n\n      //console.log( \"allpoints\",allpoints, allpoints.length );\n\n      // prepare all points map\n\n      for ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n        key = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n        if ( allPointsMap[ key ] !== undefined ) {\n\n          console.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n        }\n\n        allPointsMap[ key ] = i;\n\n      }\n\n      // remove holes by cutting paths to holes and adding them to the shape\n      var shapeWithoutHoles = removeHoles( contour, holes );\n\n      var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n      //console.log( \"triangles\",triangles, triangles.length );\n\n      // check all face vertices against all points map\n\n      for ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n        face = triangles[ i ];\n\n        for ( f = 0; f < 3; f ++ ) {\n\n          key = face[ f ].x + \":\" + face[ f ].y;\n\n          index = allPointsMap[ key ];\n\n          if ( index !== undefined ) {\n\n            face[ f ] = index;\n\n          }\n\n        }\n\n      }\n\n      return triangles.concat();\n\n    },\n\n    isClockWise: function ( pts ) {\n\n      return ShapeUtils.area( pts ) < 0;\n\n    }\n\n  };\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   *\n   * Creates extruded geometry from a path shape.\n   *\n   * parameters = {\n   *\n   *  curveSegments: <int>, // number of points on the curves\n   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n   *  amount: <int>, // Depth to extrude the shape\n   *\n   *  bevelEnabled: <bool>, // turn on bevel\n   *  bevelThickness: <float>, // how deep into the original shape bevel goes\n   *  bevelSize: <float>, // how far from shape outline is bevel\n   *  bevelSegments: <int>, // number of bevel layers\n   *\n   *  extrudePath: <THREE.Curve> // curve to extrude shape along\n   *  frames: <Object> // containing arrays of tangents, normals, binormals\n   *\n   *  UVGenerator: <Object> // object that provides UV generator functions\n   *\n   * }\n   **/\n\n  function ExtrudeGeometry( shapes, options ) {\n\n    if ( typeof( shapes ) === \"undefined\" ) {\n\n      shapes = [];\n      return;\n\n    }\n\n    Geometry.call( this );\n\n    this.type = 'ExtrudeGeometry';\n\n    shapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n    this.addShapeList( shapes, options );\n\n    this.computeFaceNormals();\n\n    // can't really use automatic vertex normals\n    // as then front and back sides get smoothed too\n    // should do separate smoothing just for sides\n\n    //this.computeVertexNormals();\n\n    //console.log( \"took\", ( Date.now() - startTime ) );\n\n  }\n\n  ExtrudeGeometry.prototype = Object.create( Geometry.prototype );\n  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\n\n  ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n    var sl = shapes.length;\n\n    for ( var s = 0; s < sl; s ++ ) {\n\n      var shape = shapes[ s ];\n      this.addShape( shape, options );\n\n    }\n\n  };\n\n  ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n    var amount = options.amount !== undefined ? options.amount : 100;\n\n    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n    var steps = options.steps !== undefined ? options.steps : 1;\n\n    var extrudePath = options.extrudePath;\n    var extrudePts, extrudeByPath = false;\n\n    // Use default WorldUVGenerator if no UV generators are specified.\n    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\n\n    var splineTube, binormal, normal, position2;\n    if ( extrudePath ) {\n\n      extrudePts = extrudePath.getSpacedPoints( steps );\n\n      extrudeByPath = true;\n      bevelEnabled = false; // bevels not supported for path extrusion\n\n      // SETUP TNB variables\n\n      // TODO1 - have a .isClosed in spline?\n\n      splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\n\n      // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n      binormal = new Vector3();\n      normal = new Vector3();\n      position2 = new Vector3();\n\n    }\n\n    // Safeguards if bevels are not enabled\n\n    if ( ! bevelEnabled ) {\n\n      bevelSegments = 0;\n      bevelThickness = 0;\n      bevelSize = 0;\n\n    }\n\n    // Variables initialization\n\n    var ahole, h, hl; // looping of holes\n    var scope = this;\n\n    var shapesOffset = this.vertices.length;\n\n    var shapePoints = shape.extractPoints( curveSegments );\n\n    var vertices = shapePoints.shape;\n    var holes = shapePoints.holes;\n\n    var reverse = ! ShapeUtils.isClockWise( vertices );\n\n    if ( reverse ) {\n\n      vertices = vertices.reverse();\n\n      // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n      for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n        ahole = holes[ h ];\n\n        if ( ShapeUtils.isClockWise( ahole ) ) {\n\n          holes[ h ] = ahole.reverse();\n\n        }\n\n      }\n\n      reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n    }\n\n\n    var faces = ShapeUtils.triangulateShape( vertices, holes );\n\n    /* Vertices */\n\n    var contour = vertices; // vertices has all points but contour has only points of circumference\n\n    for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n      ahole = holes[ h ];\n\n      vertices = vertices.concat( ahole );\n\n    }\n\n\n    function scalePt2( pt, vec, size ) {\n\n      if ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n      return vec.clone().multiplyScalar( size ).add( pt );\n\n    }\n\n    var b, bs, t, z,\n      vert, vlen = vertices.length,\n      face, flen = faces.length;\n\n\n    // Find directions for point movement\n\n\n    function getBevelVec( inPt, inPrev, inNext ) {\n\n      // computes for inPt the corresponding point inPt' on a new contour\n      //   shifted by 1 unit (length of normalized vector) to the left\n      // if we walk along contour clockwise, this new contour is outside the old one\n      //\n      // inPt' is the intersection of the two lines parallel to the two\n      //  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n      var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt\n\n      // good reading for geometry algorithms (here: line-line intersection)\n      // http://geomalgorithms.com/a05-_intersect-1.html\n\n      var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n      var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n      var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n      // check for collinear edges\n      var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n      if ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n        // not collinear\n\n        // length of vectors for normalizing\n\n        var v_prev_len = Math.sqrt( v_prev_lensq );\n        var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n        // shift adjacent points by unit vectors to the left\n\n        var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n        var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n        var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n        var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n        // scaling factor for v_prev to intersection point\n\n        var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n              ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n              ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n        // vector from inPt to intersection point\n\n        v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n        v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n        // Don't normalize!, otherwise sharp corners become ugly\n        //  but prevent crazy spikes\n        var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n        if ( v_trans_lensq <= 2 ) {\n\n          return  new Vector2( v_trans_x, v_trans_y );\n\n        } else {\n\n          shrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n        }\n\n      } else {\n\n        // handle special case of collinear edges\n\n        var direction_eq = false;   // assumes: opposite\n        if ( v_prev_x > Number.EPSILON ) {\n\n          if ( v_next_x > Number.EPSILON ) {\n\n            direction_eq = true;\n\n          }\n\n        } else {\n\n          if ( v_prev_x < - Number.EPSILON ) {\n\n            if ( v_next_x < - Number.EPSILON ) {\n\n              direction_eq = true;\n\n            }\n\n          } else {\n\n            if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n              direction_eq = true;\n\n            }\n\n          }\n\n        }\n\n        if ( direction_eq ) {\n\n          // console.log(\"Warning: lines are a straight sequence\");\n          v_trans_x = - v_prev_y;\n          v_trans_y =  v_prev_x;\n          shrink_by = Math.sqrt( v_prev_lensq );\n\n        } else {\n\n          // console.log(\"Warning: lines are a straight spike\");\n          v_trans_x = v_prev_x;\n          v_trans_y = v_prev_y;\n          shrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n        }\n\n      }\n\n      return  new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n    }\n\n\n    var contourMovements = [];\n\n    for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n      if ( j === il ) j = 0;\n      if ( k === il ) k = 0;\n\n      //  (j)---(i)---(k)\n      // console.log('i,j,k', i, j , k)\n\n      contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n    }\n\n    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n    for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n      ahole = holes[ h ];\n\n      oneHoleMovements = [];\n\n      for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n        if ( j === il ) j = 0;\n        if ( k === il ) k = 0;\n\n        //  (j)---(i)---(k)\n        oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n      }\n\n      holesMovements.push( oneHoleMovements );\n      verticesMovements = verticesMovements.concat( oneHoleMovements );\n\n    }\n\n\n    // Loop bevelSegments, 1 for the front, 1 for the back\n\n    for ( b = 0; b < bevelSegments; b ++ ) {\n\n      //for ( b = bevelSegments; b > 0; b -- ) {\n\n      t = b / bevelSegments;\n      z = bevelThickness * Math.cos( t * Math.PI / 2 );\n      bs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n      // contract shape\n\n      for ( i = 0, il = contour.length; i < il; i ++ ) {\n\n        vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n        v( vert.x, vert.y,  - z );\n\n      }\n\n      // expand holes\n\n      for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n        ahole = holes[ h ];\n        oneHoleMovements = holesMovements[ h ];\n\n        for ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n          vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n          v( vert.x, vert.y,  - z );\n\n        }\n\n      }\n\n    }\n\n    bs = bevelSize;\n\n    // Back facing vertices\n\n    for ( i = 0; i < vlen; i ++ ) {\n\n      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n      if ( ! extrudeByPath ) {\n\n        v( vert.x, vert.y, 0 );\n\n      } else {\n\n        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n        normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n        binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n        position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n        v( position2.x, position2.y, position2.z );\n\n      }\n\n    }\n\n    // Add stepped vertices...\n    // Including front facing vertices\n\n    var s;\n\n    for ( s = 1; s <= steps; s ++ ) {\n\n      for ( i = 0; i < vlen; i ++ ) {\n\n        vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n        if ( ! extrudeByPath ) {\n\n          v( vert.x, vert.y, amount / steps * s );\n\n        } else {\n\n          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n          normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n          binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n          position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n          v( position2.x, position2.y, position2.z );\n\n        }\n\n      }\n\n    }\n\n\n    // Add bevel segments planes\n\n    //for ( b = 1; b <= bevelSegments; b ++ ) {\n    for ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n      t = b / bevelSegments;\n      z = bevelThickness * Math.cos ( t * Math.PI / 2 );\n      bs = bevelSize * Math.sin( t * Math.PI / 2 );\n\n      // contract shape\n\n      for ( i = 0, il = contour.length; i < il; i ++ ) {\n\n        vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n        v( vert.x, vert.y,  amount + z );\n\n      }\n\n      // expand holes\n\n      for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n        ahole = holes[ h ];\n        oneHoleMovements = holesMovements[ h ];\n\n        for ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n          vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n          if ( ! extrudeByPath ) {\n\n            v( vert.x, vert.y,  amount + z );\n\n          } else {\n\n            v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n          }\n\n        }\n\n      }\n\n    }\n\n    /* Faces */\n\n    // Top and bottom faces\n\n    buildLidFaces();\n\n    // Sides faces\n\n    buildSideFaces();\n\n\n    /////  Internal functions\n\n    function buildLidFaces() {\n\n      if ( bevelEnabled ) {\n\n        var layer = 0; // steps + 1\n        var offset = vlen * layer;\n\n        // Bottom faces\n\n        for ( i = 0; i < flen; i ++ ) {\n\n          face = faces[ i ];\n          f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n        }\n\n        layer = steps + bevelSegments * 2;\n        offset = vlen * layer;\n\n        // Top faces\n\n        for ( i = 0; i < flen; i ++ ) {\n\n          face = faces[ i ];\n          f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n        }\n\n      } else {\n\n        // Bottom faces\n\n        for ( i = 0; i < flen; i ++ ) {\n\n          face = faces[ i ];\n          f3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n        }\n\n        // Top faces\n\n        for ( i = 0; i < flen; i ++ ) {\n\n          face = faces[ i ];\n          f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n        }\n\n      }\n\n    }\n\n    // Create faces for the z-sides of the shape\n\n    function buildSideFaces() {\n\n      var layeroffset = 0;\n      sidewalls( contour, layeroffset );\n      layeroffset += contour.length;\n\n      for ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n        ahole = holes[ h ];\n        sidewalls( ahole, layeroffset );\n\n        //, true\n        layeroffset += ahole.length;\n\n      }\n\n    }\n\n    function sidewalls( contour, layeroffset ) {\n\n      var j, k;\n      i = contour.length;\n\n      while ( -- i >= 0 ) {\n\n        j = i;\n        k = i - 1;\n        if ( k < 0 ) k = contour.length - 1;\n\n        //console.log('b', i,j, i-1, k,vertices.length);\n\n        var s = 0, sl = steps  + bevelSegments * 2;\n\n        for ( s = 0; s < sl; s ++ ) {\n\n          var slen1 = vlen * s;\n          var slen2 = vlen * ( s + 1 );\n\n          var a = layeroffset + j + slen1,\n            b = layeroffset + k + slen1,\n            c = layeroffset + k + slen2,\n            d = layeroffset + j + slen2;\n\n          f4( a, b, c, d, contour, s, sl, j, k );\n\n        }\n\n      }\n\n    }\n\n\n    function v( x, y, z ) {\n\n      scope.vertices.push( new Vector3( x, y, z ) );\n\n    }\n\n    function f3( a, b, c ) {\n\n      a += shapesOffset;\n      b += shapesOffset;\n      c += shapesOffset;\n\n      scope.faces.push( new Face3( a, b, c, null, null, 0 ) );\n\n      var uvs = uvgen.generateTopUV( scope, a, b, c );\n\n      scope.faceVertexUvs[ 0 ].push( uvs );\n\n    }\n\n    function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n      a += shapesOffset;\n      b += shapesOffset;\n      c += shapesOffset;\n      d += shapesOffset;\n\n      scope.faces.push( new Face3( a, b, d, null, null, 1 ) );\n      scope.faces.push( new Face3( b, c, d, null, null, 1 ) );\n\n      var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n      scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n      scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n    }\n\n  };\n\n  ExtrudeGeometry.WorldUVGenerator = {\n\n    generateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n      var vertices = geometry.vertices;\n\n      var a = vertices[ indexA ];\n      var b = vertices[ indexB ];\n      var c = vertices[ indexC ];\n\n      return [\n        new Vector2( a.x, a.y ),\n        new Vector2( b.x, b.y ),\n        new Vector2( c.x, c.y )\n      ];\n\n    },\n\n    generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n      var vertices = geometry.vertices;\n\n      var a = vertices[ indexA ];\n      var b = vertices[ indexB ];\n      var c = vertices[ indexC ];\n      var d = vertices[ indexD ];\n\n      if ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n        return [\n          new Vector2( a.x, 1 - a.z ),\n          new Vector2( b.x, 1 - b.z ),\n          new Vector2( c.x, 1 - c.z ),\n          new Vector2( d.x, 1 - d.z )\n        ];\n\n      } else {\n\n        return [\n          new Vector2( a.y, 1 - a.z ),\n          new Vector2( b.y, 1 - b.z ),\n          new Vector2( c.y, 1 - c.z ),\n          new Vector2( d.y, 1 - d.z )\n        ];\n\n      }\n\n    }\n  };\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * Text = 3D Text\n   *\n   * parameters = {\n   *  font: <THREE.Font>, // font\n   *\n   *  size: <float>, // size of the text\n   *  height: <float>, // thickness to extrude text\n   *  curveSegments: <int>, // number of points on the curves\n   *\n   *  bevelEnabled: <bool>, // turn on bevel\n   *  bevelThickness: <float>, // how deep into text bevel goes\n   *  bevelSize: <float> // how far from text outline is bevel\n   * }\n   */\n\n  function TextGeometry( text, parameters ) {\n\n    parameters = parameters || {};\n\n    var font = parameters.font;\n\n    if ( ( font && font.isFont ) === false ) {\n\n      console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n      return new Geometry();\n\n    }\n\n    var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n    // translate parameters to ExtrudeGeometry API\n\n    parameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n    // defaults\n\n    if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n    if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n    if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n    ExtrudeGeometry.call( this, shapes, parameters );\n\n    this.type = 'TextGeometry';\n\n  }\n\n  TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );\n  TextGeometry.prototype.constructor = TextGeometry;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n    Geometry.call( this );\n\n    this.type = 'SphereGeometry';\n\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n  }\n\n  SphereGeometry.prototype = Object.create( Geometry.prototype );\n  SphereGeometry.prototype.constructor = SphereGeometry;\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'SphereBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    radius = radius || 50;\n\n    widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n    heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n    phiStart = phiStart !== undefined ? phiStart : 0;\n    phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n    var thetaEnd = thetaStart + thetaLength;\n\n    var ix, iy;\n\n    var index = 0;\n    var grid = [];\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // generate vertices, normals and uvs\n\n    for ( iy = 0; iy <= heightSegments; iy ++ ) {\n\n      var verticesRow = [];\n\n      var v = iy / heightSegments;\n\n      for ( ix = 0; ix <= widthSegments; ix ++ ) {\n\n        var u = ix / widthSegments;\n\n        // vertex\n\n        vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n        vertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n        vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // normal\n\n        normal.set( vertex.x, vertex.y, vertex.z ).normalize();\n        normals.push( normal.x, normal.y, normal.z );\n\n        // uv\n\n        uvs.push( u, 1 - v );\n\n        verticesRow.push( index ++ );\n\n      }\n\n      grid.push( verticesRow );\n\n    }\n\n    // indices\n\n    for ( iy = 0; iy < heightSegments; iy ++ ) {\n\n      for ( ix = 0; ix < widthSegments; ix ++ ) {\n\n        var a = grid[ iy ][ ix + 1 ];\n        var b = grid[ iy ][ ix ];\n        var c = grid[ iy + 1 ][ ix ];\n        var d = grid[ iy + 1 ][ ix + 1 ];\n\n        if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n        if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\n\n  /**\n   * @author Kaleb Murphy\n   */\n\n  function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n    Geometry.call( this );\n\n    this.type = 'RingGeometry';\n\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n  }\n\n  RingGeometry.prototype = Object.create( Geometry.prototype );\n  RingGeometry.prototype.constructor = RingGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'RingBufferGeometry';\n\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    innerRadius = innerRadius || 20;\n    outerRadius = outerRadius || 50;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n    thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n    phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // some helper variables\n\n    var segment;\n    var radius = innerRadius;\n    var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n    var vertex = new Vector3();\n    var uv = new Vector2();\n    var j, i;\n\n    // generate vertices, normals and uvs\n\n    for ( j = 0; j <= phiSegments; j ++ ) {\n\n      for ( i = 0; i <= thetaSegments; i ++ ) {\n\n        // values are generate from the inside of the ring to the outside\n\n        segment = thetaStart + i / thetaSegments * thetaLength;\n\n        // vertex\n\n        vertex.x = radius * Math.cos( segment );\n        vertex.y = radius * Math.sin( segment );\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // normal\n\n        normals.push( 0, 0, 1 );\n\n        // uv\n\n        uv.x = ( vertex.x / outerRadius + 1 ) / 2;\n        uv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n        uvs.push( uv.x, uv.y );\n\n      }\n\n      // increase the radius for next row of vertices\n\n      radius += radiusStep;\n\n    }\n\n    // indices\n\n    for ( j = 0; j < phiSegments; j ++ ) {\n\n      var thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n      for ( i = 0; i < thetaSegments; i ++ ) {\n\n        segment = i + thetaSegmentLevel;\n\n        var a = segment;\n        var b = segment + thetaSegments + 1;\n        var c = segment + thetaSegments + 2;\n        var d = segment + 1;\n\n        // faces\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  RingBufferGeometry.prototype.constructor = RingBufferGeometry;\n\n  /**\n   * @author astrodud / http://astrodud.isgreat.org/\n   * @author zz85 / https://github.com/zz85\n   * @author bhouston / http://clara.io\n   */\n\n  // points - to create a closed torus, one must use a set of points\n  //    like so: [ a, b, c, d, a ], see first is the same as last.\n  // segments - the number of circumference segments to create\n  // phiStart - the starting radian\n  // phiLength - the radian (0 to 2PI) range of the lathed section\n  //    2PI is a closed lathe, less than 2PI is a portion.\n\n  function LatheGeometry( points, segments, phiStart, phiLength ) {\n\n    Geometry.call( this );\n\n    this.type = 'LatheGeometry';\n\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n\n    this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n    this.mergeVertices();\n\n  }\n\n  LatheGeometry.prototype = Object.create( Geometry.prototype );\n  LatheGeometry.prototype.constructor = LatheGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function LatheBufferGeometry( points, segments, phiStart, phiLength ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'LatheBufferGeometry';\n\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n\n    segments = Math.floor( segments ) || 12;\n    phiStart = phiStart || 0;\n    phiLength = phiLength || Math.PI * 2;\n\n    // clamp phiLength so it's in range of [ 0, 2PI ]\n\n    phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var uvs = [];\n\n    // helper variables\n\n    var base;\n    var inverseSegments = 1.0 / segments;\n    var vertex = new Vector3();\n    var uv = new Vector2();\n    var i, j;\n\n    // generate vertices and uvs\n\n    for ( i = 0; i <= segments; i ++ ) {\n\n      var phi = phiStart + i * inverseSegments * phiLength;\n\n      var sin = Math.sin( phi );\n      var cos = Math.cos( phi );\n\n      for ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n        // vertex\n\n        vertex.x = points[ j ].x * sin;\n        vertex.y = points[ j ].y;\n        vertex.z = points[ j ].x * cos;\n\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // uv\n\n        uv.x = i / segments;\n        uv.y = j / ( points.length - 1 );\n\n        uvs.push( uv.x, uv.y );\n\n\n      }\n\n    }\n\n    // indices\n\n    for ( i = 0; i < segments; i ++ ) {\n\n      for ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n        base = j + i * points.length;\n\n        var a = base;\n        var b = base + points.length;\n        var c = base + points.length + 1;\n        var d = base + 1;\n\n        // faces\n\n        indices.push( a, b, d );\n        indices.push( b, c, d );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    // generate normals\n\n    this.computeVertexNormals();\n\n    // if the geometry is closed, we need to average the normals along the seam.\n    // because the corresponding vertices are identical (but still have different UVs).\n\n    if ( phiLength === Math.PI * 2 ) {\n\n      var normals = this.attributes.normal.array;\n      var n1 = new Vector3();\n      var n2 = new Vector3();\n      var n = new Vector3();\n\n      // this is the buffer offset for the last line of vertices\n\n      base = segments * points.length * 3;\n\n      for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n        // select the normal of the vertex in the first line\n\n        n1.x = normals[ j + 0 ];\n        n1.y = normals[ j + 1 ];\n        n1.z = normals[ j + 2 ];\n\n        // select the normal of the vertex in the last line\n\n        n2.x = normals[ base + j + 0 ];\n        n2.y = normals[ base + j + 1 ];\n        n2.z = normals[ base + j + 2 ];\n\n        // average normals\n\n        n.addVectors( n1, n2 ).normalize();\n\n        // assign the new values to both normals\n\n        normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n        normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n        normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n      }\n\n    }\n\n  }\n\n  LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\n\n  /**\n   * @author jonobr1 / http://jonobr1.com\n   */\n\n  function ShapeGeometry( shapes, curveSegments ) {\n\n    Geometry.call( this );\n\n    this.type = 'ShapeGeometry';\n\n    if ( typeof curveSegments === 'object' ) {\n\n      console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\n\n      curveSegments = curveSegments.curveSegments;\n\n    }\n\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    };\n\n    this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\n    this.mergeVertices();\n\n  }\n\n  ShapeGeometry.prototype = Object.create( Geometry.prototype );\n  ShapeGeometry.prototype.constructor = ShapeGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function ShapeBufferGeometry( shapes, curveSegments ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'ShapeBufferGeometry';\n\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    };\n\n    curveSegments = curveSegments || 12;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var groupStart = 0;\n    var groupCount = 0;\n\n    // allow single and array values for \"shapes\" parameter\n\n    if ( Array.isArray( shapes ) === false ) {\n\n      addShape( shapes );\n\n    } else {\n\n      for ( var i = 0; i < shapes.length; i ++ ) {\n\n        addShape( shapes[ i ] );\n\n        this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n\n      }\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n    // helper functions\n\n    function addShape( shape ) {\n\n      var i, l, shapeHole;\n\n      var indexOffset = vertices.length / 3;\n      var points = shape.extractPoints( curveSegments );\n\n      var shapeVertices = points.shape;\n      var shapeHoles = points.holes;\n\n      // check direction of vertices\n\n      if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n        shapeVertices = shapeVertices.reverse();\n\n        // also check if holes are in the opposite direction\n\n        for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n          shapeHole = shapeHoles[ i ];\n\n          if ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n            shapeHoles[ i ] = shapeHole.reverse();\n\n          }\n\n        }\n\n      }\n\n      var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n      // join vertices of inner and outer paths to a single array\n\n      for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n        shapeHole = shapeHoles[ i ];\n        shapeVertices = shapeVertices.concat( shapeHole );\n\n      }\n\n      // vertices, normals, uvs\n\n      for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n        var vertex = shapeVertices[ i ];\n\n        vertices.push( vertex.x, vertex.y, 0 );\n        normals.push( 0, 0, 1 );\n        uvs.push( vertex.x, vertex.y ); // world uvs\n\n      }\n\n      // incides\n\n      for ( i = 0, l = faces.length; i < l; i ++ ) {\n\n        var face = faces[ i ];\n\n        var a = face[ 0 ] + indexOffset;\n        var b = face[ 1 ] + indexOffset;\n        var c = face[ 2 ] + indexOffset;\n\n        indices.push( a, b, c );\n        groupCount += 3;\n\n      }\n\n    }\n\n  }\n\n  ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\n\n  /**\n   * @author WestLangley / http://github.com/WestLangley\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function EdgesGeometry( geometry, thresholdAngle ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'EdgesGeometry';\n\n    this.parameters = {\n      thresholdAngle: thresholdAngle\n    };\n\n    thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n    // buffer\n\n    var vertices = [];\n\n    // helper variables\n\n    var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\n    var edge = [ 0, 0 ], edges = {};\n    var key, keys = [ 'a', 'b', 'c' ];\n\n    // prepare source geometry\n\n    var geometry2;\n\n    if ( geometry.isBufferGeometry ) {\n\n      geometry2 = new Geometry();\n      geometry2.fromBufferGeometry( geometry );\n\n    } else {\n\n      geometry2 = geometry.clone();\n\n    }\n\n    geometry2.mergeVertices();\n    geometry2.computeFaceNormals();\n\n    var sourceVertices = geometry2.vertices;\n    var faces = geometry2.faces;\n\n    // now create a data structure where each entry represents an edge with its adjoining faces\n\n    for ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n      var face = faces[ i ];\n\n      for ( var j = 0; j < 3; j ++ ) {\n\n        edge[ 0 ] = face[ keys[ j ] ];\n        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n        edge.sort( sortFunction );\n\n        key = edge.toString();\n\n        if ( edges[ key ] === undefined ) {\n\n          edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\n\n        } else {\n\n          edges[ key ].face2 = i;\n\n        }\n\n      }\n\n    }\n\n    // generate vertices\n\n    for ( key in edges ) {\n\n      var e = edges[ key ];\n\n      // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\n      if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\n\n        var vertex = sourceVertices[ e.index1 ];\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        vertex = sourceVertices[ e.index2 ];\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n      }\n\n    }\n\n    // build geometry\n\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n    // custom array sort function\n\n    function sortFunction( a, b ) {\n\n      return a - b;\n\n    }\n\n  }\n\n  EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\n  EdgesGeometry.prototype.constructor = EdgesGeometry;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n    Geometry.call( this );\n\n    this.type = 'CylinderGeometry';\n\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n    this.mergeVertices();\n\n  }\n\n  CylinderGeometry.prototype = Object.create( Geometry.prototype );\n  CylinderGeometry.prototype.constructor = CylinderGeometry;\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'CylinderBufferGeometry';\n\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    var scope = this;\n\n    radiusTop = radiusTop !== undefined ? radiusTop : 20;\n    radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n    height = height !== undefined ? height : 100;\n\n    radialSegments = Math.floor( radialSegments ) || 8;\n    heightSegments = Math.floor( heightSegments ) || 1;\n\n    openEnded = openEnded !== undefined ? openEnded : false;\n    thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n    thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var index = 0;\n    var indexOffset = 0;\n    var indexArray = [];\n    var halfHeight = height / 2;\n    var groupStart = 0;\n\n    // generate geometry\n\n    generateTorso();\n\n    if ( openEnded === false ) {\n\n      if ( radiusTop > 0 ) generateCap( true );\n      if ( radiusBottom > 0 ) generateCap( false );\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n    function generateTorso() {\n\n      var x, y;\n      var normal = new Vector3();\n      var vertex = new Vector3();\n\n      var groupCount = 0;\n\n      // this will be used to calculate the normal\n      var slope = ( radiusBottom - radiusTop ) / height;\n\n      // generate vertices, normals and uvs\n\n      for ( y = 0; y <= heightSegments; y ++ ) {\n\n        var indexRow = [];\n\n        var v = y / heightSegments;\n\n        // calculate the radius of the current row\n\n        var radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n        for ( x = 0; x <= radialSegments; x ++ ) {\n\n          var u = x / radialSegments;\n\n          var theta = u * thetaLength + thetaStart;\n\n          var sinTheta = Math.sin( theta );\n          var cosTheta = Math.cos( theta );\n\n          // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = - v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push( vertex.x, vertex.y, vertex.z );\n\n          // normal\n\n          normal.set( sinTheta, slope, cosTheta ).normalize();\n          normals.push( normal.x, normal.y, normal.z );\n\n          // uv\n\n          uvs.push( u, 1 - v );\n\n          // save index of vertex in respective row\n\n          indexRow.push( index ++ );\n\n        }\n\n        // now save vertices of the row in our index array\n\n        indexArray.push( indexRow );\n\n      }\n\n      // generate indices\n\n      for ( x = 0; x < radialSegments; x ++ ) {\n\n        for ( y = 0; y < heightSegments; y ++ ) {\n\n          // we use the index array to access the correct indices\n\n          var a = indexArray[ y ][ x ];\n          var b = indexArray[ y + 1 ][ x ];\n          var c = indexArray[ y + 1 ][ x + 1 ];\n          var d = indexArray[ y ][ x + 1 ];\n\n          // faces\n\n          indices.push( a, b, d );\n          indices.push( b, c, d );\n\n          // update group counter\n\n          groupCount += 6;\n\n        }\n\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup( groupStart, groupCount, 0 );\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n    }\n\n    function generateCap( top ) {\n\n      var x, centerIndexStart, centerIndexEnd;\n\n      var uv = new Vector2();\n      var vertex = new Vector3();\n\n      var groupCount = 0;\n\n      var radius = ( top === true ) ? radiusTop : radiusBottom;\n      var sign = ( top === true ) ? 1 : - 1;\n\n      // save the index of the first center vertex\n      centerIndexStart = index;\n\n      // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for ( x = 1; x <= radialSegments; x ++ ) {\n\n        // vertex\n\n        vertices.push( 0, halfHeight * sign, 0 );\n\n        // normal\n\n        normals.push( 0, sign, 0 );\n\n        // uv\n\n        uvs.push( 0.5, 0.5 );\n\n        // increase index\n\n        index ++;\n\n      }\n\n      // save the index of the last center vertex\n\n      centerIndexEnd = index;\n\n      // now we generate the surrounding vertices, normals and uvs\n\n      for ( x = 0; x <= radialSegments; x ++ ) {\n\n        var u = x / radialSegments;\n        var theta = u * thetaLength + thetaStart;\n\n        var cosTheta = Math.cos( theta );\n        var sinTheta = Math.sin( theta );\n\n        // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push( vertex.x, vertex.y, vertex.z );\n\n        // normal\n\n        normals.push( 0, sign, 0 );\n\n        // uv\n\n        uv.x = ( cosTheta * 0.5 ) + 0.5;\n        uv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n        uvs.push( uv.x, uv.y );\n\n        // increase index\n\n        index ++;\n\n      }\n\n      // generate indices\n\n      for ( x = 0; x < radialSegments; x ++ ) {\n\n        var c = centerIndexStart + x;\n        var i = centerIndexEnd + x;\n\n        if ( top === true ) {\n\n          // face top\n\n          indices.push( i, i + 1, c );\n\n        } else {\n\n          // face bottom\n\n          indices.push( i + 1, i, c );\n\n        }\n\n        groupCount += 3;\n\n      }\n\n      // add a group to the geometry. this will ensure multi material support\n\n      scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n      // calculate new start value for groups\n\n      groupStart += groupCount;\n\n    }\n\n  }\n\n  CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\n\n  /**\n   * @author abelnation / http://github.com/abelnation\n   */\n\n  function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n    CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n    this.type = 'ConeGeometry';\n\n    this.parameters = {\n      radius: radius,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n  }\n\n  ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\n  ConeGeometry.prototype.constructor = ConeGeometry;\n\n  /**\n   * @author: abelnation / http://github.com/abelnation\n   */\n\n  function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n    CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n    this.type = 'ConeBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n  }\n\n  ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\n  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\n\n  /**\n   * @author hughes\n   */\n\n  function CircleGeometry( radius, segments, thetaStart, thetaLength ) {\n\n    Geometry.call( this );\n\n    this.type = 'CircleGeometry';\n\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n  }\n\n  CircleGeometry.prototype = Object.create( Geometry.prototype );\n  CircleGeometry.prototype.constructor = CircleGeometry;\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\n\n    BufferGeometry.call( this );\n\n    this.type = 'CircleBufferGeometry';\n\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    radius = radius || 50;\n    segments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n    thetaStart = thetaStart !== undefined ? thetaStart : 0;\n    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n    // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    // helper variables\n\n    var i, s;\n    var vertex = new Vector3();\n    var uv = new Vector2();\n\n    // center point\n\n    vertices.push( 0, 0, 0 );\n    normals.push( 0, 0, 1 );\n    uvs.push( 0.5, 0.5 );\n\n    for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n      var segment = thetaStart + s / segments * thetaLength;\n\n      // vertex\n\n      vertex.x = radius * Math.cos( segment );\n      vertex.y = radius * Math.sin( segment );\n\n      vertices.push( vertex.x, vertex.y, vertex.z );\n\n      // normal\n\n      normals.push( 0, 0, 1 );\n\n      // uvs\n\n      uv.x = ( vertices[ i ] / radius + 1 ) / 2;\n      uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n      uvs.push( uv.x, uv.y );\n\n    }\n\n    // indices\n\n    for ( i = 1; i <= segments; i ++ ) {\n\n      indices.push( i, i + 1, 0 );\n\n    }\n\n    // build geometry\n\n    this.setIndex( indices );\n    this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n    this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n  }\n\n  CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\n\n\n\n  var Geometries = Object.freeze({\n    WireframeGeometry: WireframeGeometry,\n    ParametricGeometry: ParametricGeometry,\n    ParametricBufferGeometry: ParametricBufferGeometry,\n    TetrahedronGeometry: TetrahedronGeometry,\n    TetrahedronBufferGeometry: TetrahedronBufferGeometry,\n    OctahedronGeometry: OctahedronGeometry,\n    OctahedronBufferGeometry: OctahedronBufferGeometry,\n    IcosahedronGeometry: IcosahedronGeometry,\n    IcosahedronBufferGeometry: IcosahedronBufferGeometry,\n    DodecahedronGeometry: DodecahedronGeometry,\n    DodecahedronBufferGeometry: DodecahedronBufferGeometry,\n    PolyhedronGeometry: PolyhedronGeometry,\n    PolyhedronBufferGeometry: PolyhedronBufferGeometry,\n    TubeGeometry: TubeGeometry,\n    TubeBufferGeometry: TubeBufferGeometry,\n    TorusKnotGeometry: TorusKnotGeometry,\n    TorusKnotBufferGeometry: TorusKnotBufferGeometry,\n    TorusGeometry: TorusGeometry,\n    TorusBufferGeometry: TorusBufferGeometry,\n    TextGeometry: TextGeometry,\n    SphereGeometry: SphereGeometry,\n    SphereBufferGeometry: SphereBufferGeometry,\n    RingGeometry: RingGeometry,\n    RingBufferGeometry: RingBufferGeometry,\n    PlaneGeometry: PlaneGeometry,\n    PlaneBufferGeometry: PlaneBufferGeometry,\n    LatheGeometry: LatheGeometry,\n    LatheBufferGeometry: LatheBufferGeometry,\n    ShapeGeometry: ShapeGeometry,\n    ShapeBufferGeometry: ShapeBufferGeometry,\n    ExtrudeGeometry: ExtrudeGeometry,\n    EdgesGeometry: EdgesGeometry,\n    ConeGeometry: ConeGeometry,\n    ConeBufferGeometry: ConeBufferGeometry,\n    CylinderGeometry: CylinderGeometry,\n    CylinderBufferGeometry: CylinderBufferGeometry,\n    CircleGeometry: CircleGeometry,\n    CircleBufferGeometry: CircleBufferGeometry,\n    BoxGeometry: BoxGeometry,\n    BoxBufferGeometry: BoxBufferGeometry\n  });\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function ShadowMaterial() {\n\n    ShaderMaterial.call( this, {\n      uniforms: UniformsUtils.merge( [\n        UniformsLib.lights,\n        {\n          opacity: { value: 1.0 }\n        }\n      ] ),\n      vertexShader: ShaderChunk[ 'shadow_vert' ],\n      fragmentShader: ShaderChunk[ 'shadow_frag' ]\n    } );\n\n    this.lights = true;\n    this.transparent = true;\n\n    Object.defineProperties( this, {\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function ( value ) {\n          this.uniforms.opacity.value = value;\n        }\n      }\n    } );\n\n  }\n\n  ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );\n  ShadowMaterial.prototype.constructor = ShadowMaterial;\n\n  ShadowMaterial.prototype.isShadowMaterial = true;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function RawShaderMaterial( parameters ) {\n\n    ShaderMaterial.call( this, parameters );\n\n    this.type = 'RawShaderMaterial';\n\n  }\n\n  RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\n  RawShaderMaterial.prototype.constructor = RawShaderMaterial;\n\n  RawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function MultiMaterial( materials ) {\n\n    this.uuid = _Math.generateUUID();\n\n    this.type = 'MultiMaterial';\n\n    this.materials = Array.isArray( materials ) ? materials : [];\n\n    this.visible = true;\n\n  }\n\n  Object.assign( MultiMaterial.prototype, {\n\n    isMultiMaterial: true,\n\n    toJSON: function ( meta ) {\n\n      var output = {\n        metadata: {\n          version: 4.2,\n          type: 'material',\n          generator: 'MaterialExporter'\n        },\n        uuid: this.uuid,\n        type: this.type,\n        materials: []\n      };\n\n      var materials = this.materials;\n\n      for ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n        var material = materials[ i ].toJSON( meta );\n        delete material.metadata;\n\n        output.materials.push( material );\n\n      }\n\n      output.visible = this.visible;\n\n      return output;\n\n    },\n\n    clone: function () {\n\n      var material = new this.constructor();\n\n      for ( var i = 0; i < this.materials.length; i ++ ) {\n\n        material.materials.push( this.materials[ i ].clone() );\n\n      }\n\n      material.visible = this.visible;\n\n      return material;\n\n    }\n\n  } );\n\n  /**\n   * @author WestLangley / http://github.com/WestLangley\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  roughness: <float>,\n   *  metalness: <float>,\n   *  opacity: <float>,\n   *\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  lightMap: new THREE.Texture( <Image> ),\n   *  lightMapIntensity: <float>\n   *\n   *  aoMap: new THREE.Texture( <Image> ),\n   *  aoMapIntensity: <float>\n   *\n   *  emissive: <hex>,\n   *  emissiveIntensity: <float>\n   *  emissiveMap: new THREE.Texture( <Image> ),\n   *\n   *  bumpMap: new THREE.Texture( <Image> ),\n   *  bumpScale: <float>,\n   *\n   *  normalMap: new THREE.Texture( <Image> ),\n   *  normalScale: <Vector2>,\n   *\n   *  displacementMap: new THREE.Texture( <Image> ),\n   *  displacementScale: <float>,\n   *  displacementBias: <float>,\n   *\n   *  roughnessMap: new THREE.Texture( <Image> ),\n   *\n   *  metalnessMap: new THREE.Texture( <Image> ),\n   *\n   *  alphaMap: new THREE.Texture( <Image> ),\n   *\n   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n   *  envMapIntensity: <float>\n   *\n   *  refractionRatio: <float>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>,\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>,\n   *  morphNormals: <bool>\n   * }\n   */\n\n  function MeshStandardMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.defines = { 'STANDARD': '' };\n\n    this.type = 'MeshStandardMaterial';\n\n    this.color = new Color( 0xffffff ); // diffuse\n    this.roughness = 0.5;\n    this.metalness = 0.5;\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color( 0x000000 );\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalScale = new Vector2( 1, 1 );\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.roughnessMap = null;\n\n    this.metalnessMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.envMapIntensity = 1.0;\n\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshStandardMaterial.prototype = Object.create( Material.prototype );\n  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\n  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n  MeshStandardMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.defines = { 'STANDARD': '' };\n\n    this.color.copy( source.color );\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy( source.emissive );\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalScale.copy( source.normalScale );\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.roughnessMap = source.roughnessMap;\n\n    this.metalnessMap = source.metalnessMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.envMapIntensity = source.envMapIntensity;\n\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n\n    return this;\n\n  };\n\n  /**\n   * @author WestLangley / http://github.com/WestLangley\n   *\n   * parameters = {\n   *  reflectivity: <float>\n   * }\n   */\n\n  function MeshPhysicalMaterial( parameters ) {\n\n    MeshStandardMaterial.call( this );\n\n    this.defines = { 'PHYSICAL': '' };\n\n    this.type = 'MeshPhysicalMaterial';\n\n    this.reflectivity = 0.5; // maps to F0 = 0.04\n\n    this.clearCoat = 0.0;\n    this.clearCoatRoughness = 0.0;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\n  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\n\n  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n  MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n    MeshStandardMaterial.prototype.copy.call( this, source );\n\n    this.defines = { 'PHYSICAL': '' };\n\n    this.reflectivity = source.reflectivity;\n\n    this.clearCoat = source.clearCoat;\n    this.clearCoatRoughness = source.clearCoatRoughness;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  specular: <hex>,\n   *  shininess: <float>,\n   *  opacity: <float>,\n   *\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  lightMap: new THREE.Texture( <Image> ),\n   *  lightMapIntensity: <float>\n   *\n   *  aoMap: new THREE.Texture( <Image> ),\n   *  aoMapIntensity: <float>\n   *\n   *  emissive: <hex>,\n   *  emissiveIntensity: <float>\n   *  emissiveMap: new THREE.Texture( <Image> ),\n   *\n   *  bumpMap: new THREE.Texture( <Image> ),\n   *  bumpScale: <float>,\n   *\n   *  normalMap: new THREE.Texture( <Image> ),\n   *  normalScale: <Vector2>,\n   *\n   *  displacementMap: new THREE.Texture( <Image> ),\n   *  displacementScale: <float>,\n   *  displacementBias: <float>,\n   *\n   *  specularMap: new THREE.Texture( <Image> ),\n   *\n   *  alphaMap: new THREE.Texture( <Image> ),\n   *\n   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n   *  combine: THREE.Multiply,\n   *  reflectivity: <float>,\n   *  refractionRatio: <float>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>,\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>,\n   *  morphNormals: <bool>\n   * }\n   */\n\n  function MeshPhongMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'MeshPhongMaterial';\n\n    this.color = new Color( 0xffffff ); // diffuse\n    this.specular = new Color( 0x111111 );\n    this.shininess = 30;\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color( 0x000000 );\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalScale = new Vector2( 1, 1 );\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshPhongMaterial.prototype = Object.create( Material.prototype );\n  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\n\n  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n  MeshPhongMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n    this.specular.copy( source.specular );\n    this.shininess = source.shininess;\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy( source.emissive );\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalScale.copy( source.normalScale );\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n\n    return this;\n\n  };\n\n  /**\n   * @author takahirox / http://github.com/takahirox\n   *\n   * parameters = {\n   *  gradientMap: new THREE.Texture( <Image> )\n   * }\n   */\n\n  function MeshToonMaterial( parameters ) {\n\n    MeshPhongMaterial.call( this );\n\n    this.defines = { 'TOON': '' };\n\n    this.type = 'MeshToonMaterial';\n\n    this.gradientMap = null;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\n  MeshToonMaterial.prototype.constructor = MeshToonMaterial;\n\n  MeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n  MeshToonMaterial.prototype.copy = function ( source ) {\n\n    MeshPhongMaterial.prototype.copy.call( this, source );\n\n    this.gradientMap = source.gradientMap;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n   *\n   * parameters = {\n   *  opacity: <float>,\n   *\n   *  bumpMap: new THREE.Texture( <Image> ),\n   *  bumpScale: <float>,\n   *\n   *  normalMap: new THREE.Texture( <Image> ),\n   *  normalScale: <Vector2>,\n   *\n   *  displacementMap: new THREE.Texture( <Image> ),\n   *  displacementScale: <float>,\n   *  displacementBias: <float>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>,\n   *  morphNormals: <bool>\n   * }\n   */\n\n  function MeshNormalMaterial( parameters ) {\n\n    Material.call( this, parameters );\n\n    this.type = 'MeshNormalMaterial';\n\n    this.bumpMap = null;\n    this.bumpScale = 1;\n\n    this.normalMap = null;\n    this.normalScale = new Vector2( 1, 1 );\n\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n\n    this.fog = false;\n    this.lights = false;\n\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshNormalMaterial.prototype = Object.create( Material.prototype );\n  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\n\n  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n  MeshNormalMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n\n    this.normalMap = source.normalMap;\n    this.normalScale.copy( source.normalScale );\n\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *\n   *  map: new THREE.Texture( <Image> ),\n   *\n   *  lightMap: new THREE.Texture( <Image> ),\n   *  lightMapIntensity: <float>\n   *\n   *  aoMap: new THREE.Texture( <Image> ),\n   *  aoMapIntensity: <float>\n   *\n   *  emissive: <hex>,\n   *  emissiveIntensity: <float>\n   *  emissiveMap: new THREE.Texture( <Image> ),\n   *\n   *  specularMap: new THREE.Texture( <Image> ),\n   *\n   *  alphaMap: new THREE.Texture( <Image> ),\n   *\n   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n   *  combine: THREE.Multiply,\n   *  reflectivity: <float>,\n   *  refractionRatio: <float>,\n   *\n   *  wireframe: <boolean>,\n   *  wireframeLinewidth: <float>,\n   *\n   *  skinning: <bool>,\n   *  morphTargets: <bool>,\n   *  morphNormals: <bool>\n   * }\n   */\n\n  function MeshLambertMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'MeshLambertMaterial';\n\n    this.color = new Color( 0xffffff ); // diffuse\n\n    this.map = null;\n\n    this.lightMap = null;\n    this.lightMapIntensity = 1.0;\n\n    this.aoMap = null;\n    this.aoMapIntensity = 1.0;\n\n    this.emissive = new Color( 0x000000 );\n    this.emissiveIntensity = 1.0;\n    this.emissiveMap = null;\n\n    this.specularMap = null;\n\n    this.alphaMap = null;\n\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = 'round';\n    this.wireframeLinejoin = 'round';\n\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n\n    this.setValues( parameters );\n\n  }\n\n  MeshLambertMaterial.prototype = Object.create( Material.prototype );\n  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\n  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n  MeshLambertMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n\n    this.map = source.map;\n\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n\n    this.emissive.copy( source.emissive );\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n\n    this.specularMap = source.specularMap;\n\n    this.alphaMap = source.alphaMap;\n\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n\n    return this;\n\n  };\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   *\n   * parameters = {\n   *  color: <hex>,\n   *  opacity: <float>,\n   *\n   *  linewidth: <float>,\n   *\n   *  scale: <float>,\n   *  dashSize: <float>,\n   *  gapSize: <float>\n   * }\n   */\n\n  function LineDashedMaterial( parameters ) {\n\n    Material.call( this );\n\n    this.type = 'LineDashedMaterial';\n\n    this.color = new Color( 0xffffff );\n\n    this.linewidth = 1;\n\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n\n    this.lights = false;\n\n    this.setValues( parameters );\n\n  }\n\n  LineDashedMaterial.prototype = Object.create( Material.prototype );\n  LineDashedMaterial.prototype.constructor = LineDashedMaterial;\n\n  LineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n  LineDashedMaterial.prototype.copy = function ( source ) {\n\n    Material.prototype.copy.call( this, source );\n\n    this.color.copy( source.color );\n\n    this.linewidth = source.linewidth;\n\n    this.scale = source.scale;\n    this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n\n    return this;\n\n  };\n\n\n\n  var Materials = Object.freeze({\n    ShadowMaterial: ShadowMaterial,\n    SpriteMaterial: SpriteMaterial,\n    RawShaderMaterial: RawShaderMaterial,\n    ShaderMaterial: ShaderMaterial,\n    PointsMaterial: PointsMaterial,\n    MultiMaterial: MultiMaterial,\n    MeshPhysicalMaterial: MeshPhysicalMaterial,\n    MeshStandardMaterial: MeshStandardMaterial,\n    MeshPhongMaterial: MeshPhongMaterial,\n    MeshToonMaterial: MeshToonMaterial,\n    MeshNormalMaterial: MeshNormalMaterial,\n    MeshLambertMaterial: MeshLambertMaterial,\n    MeshDepthMaterial: MeshDepthMaterial,\n    MeshBasicMaterial: MeshBasicMaterial,\n    LineDashedMaterial: LineDashedMaterial,\n    LineBasicMaterial: LineBasicMaterial,\n    Material: Material\n  });\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  var Cache = {\n\n    enabled: false,\n\n    files: {},\n\n    add: function ( key, file ) {\n\n      if ( this.enabled === false ) return;\n\n      // console.log( 'THREE.Cache', 'Adding key:', key );\n\n      this.files[ key ] = file;\n\n    },\n\n    get: function ( key ) {\n\n      if ( this.enabled === false ) return;\n\n      // console.log( 'THREE.Cache', 'Checking key:', key );\n\n      return this.files[ key ];\n\n    },\n\n    remove: function ( key ) {\n\n      delete this.files[ key ];\n\n    },\n\n    clear: function () {\n\n      this.files = {};\n\n    }\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function LoadingManager( onLoad, onProgress, onError ) {\n\n    var scope = this;\n\n    var isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n    this.onStart = undefined;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n\n    this.itemStart = function ( url ) {\n\n      itemsTotal ++;\n\n      if ( isLoading === false ) {\n\n        if ( scope.onStart !== undefined ) {\n\n          scope.onStart( url, itemsLoaded, itemsTotal );\n\n        }\n\n      }\n\n      isLoading = true;\n\n    };\n\n    this.itemEnd = function ( url ) {\n\n      itemsLoaded ++;\n\n      if ( scope.onProgress !== undefined ) {\n\n        scope.onProgress( url, itemsLoaded, itemsTotal );\n\n      }\n\n      if ( itemsLoaded === itemsTotal ) {\n\n        isLoading = false;\n\n        if ( scope.onLoad !== undefined ) {\n\n          scope.onLoad();\n\n        }\n\n      }\n\n    };\n\n    this.itemError = function ( url ) {\n\n      if ( scope.onError !== undefined ) {\n\n        scope.onError( url );\n\n      }\n\n    };\n\n  }\n\n  var DefaultLoadingManager = new LoadingManager();\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function FileLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( FileLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      if ( url === undefined ) url = '';\n\n      if ( this.path !== undefined ) url = this.path + url;\n\n      var scope = this;\n\n      var cached = Cache.get( url );\n\n      if ( cached !== undefined ) {\n\n        scope.manager.itemStart( url );\n\n        setTimeout( function () {\n\n          if ( onLoad ) onLoad( cached );\n\n          scope.manager.itemEnd( url );\n\n        }, 0 );\n\n        return cached;\n\n      }\n\n      // Check for data: URI\n      var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n      var dataUriRegexResult = url.match( dataUriRegex );\n\n      // Safari can not handle Data URIs through XMLHttpRequest so process manually\n      if ( dataUriRegexResult ) {\n\n        var mimeType = dataUriRegexResult[ 1 ];\n        var isBase64 = !! dataUriRegexResult[ 2 ];\n        var data = dataUriRegexResult[ 3 ];\n\n        data = window.decodeURIComponent( data );\n\n        if ( isBase64 ) data = window.atob( data );\n\n        try {\n\n          var response;\n          var responseType = ( this.responseType || '' ).toLowerCase();\n\n          switch ( responseType ) {\n\n            case 'arraybuffer':\n            case 'blob':\n\n              response = new ArrayBuffer( data.length );\n\n              var view = new Uint8Array( response );\n\n              for ( var i = 0; i < data.length; i ++ ) {\n\n                view[ i ] = data.charCodeAt( i );\n\n              }\n\n              if ( responseType === 'blob' ) {\n\n                response = new Blob( [ response ], { type: mimeType } );\n\n              }\n\n              break;\n\n            case 'document':\n\n              var parser = new DOMParser();\n              response = parser.parseFromString( data, mimeType );\n\n              break;\n\n            case 'json':\n\n              response = JSON.parse( data );\n\n              break;\n\n            default: // 'text' or other\n\n              response = data;\n\n              break;\n\n          }\n\n          // Wait for next browser tick\n          window.setTimeout( function () {\n\n            if ( onLoad ) onLoad( response );\n\n            scope.manager.itemEnd( url );\n\n          }, 0 );\n\n        } catch ( error ) {\n\n          // Wait for next browser tick\n          window.setTimeout( function () {\n\n            if ( onError ) onError( error );\n\n            scope.manager.itemError( url );\n\n          }, 0 );\n\n        }\n\n      } else {\n\n        var request = new XMLHttpRequest();\n        request.open( 'GET', url, true );\n\n        request.addEventListener( 'load', function ( event ) {\n\n          var response = event.target.response;\n\n          Cache.add( url, response );\n\n          if ( this.status === 200 ) {\n\n            if ( onLoad ) onLoad( response );\n\n            scope.manager.itemEnd( url );\n\n          } else if ( this.status === 0 ) {\n\n            // Some browsers return HTTP Status 0 when using non-http protocol\n            // e.g. 'file://' or 'data://'. Handle as success.\n\n            console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n            if ( onLoad ) onLoad( response );\n\n            scope.manager.itemEnd( url );\n\n          } else {\n\n            if ( onError ) onError( event );\n\n            scope.manager.itemError( url );\n\n          }\n\n        }, false );\n\n        if ( onProgress !== undefined ) {\n\n          request.addEventListener( 'progress', function ( event ) {\n\n            onProgress( event );\n\n          }, false );\n\n        }\n\n        request.addEventListener( 'error', function ( event ) {\n\n          if ( onError ) onError( event );\n\n          scope.manager.itemError( url );\n\n        }, false );\n\n        if ( this.responseType !== undefined ) request.responseType = this.responseType;\n        if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n        if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\n\n        request.send( null );\n\n      }\n\n      scope.manager.itemStart( url );\n\n      return request;\n\n    },\n\n    setPath: function ( value ) {\n\n      this.path = value;\n      return this;\n\n    },\n\n    setResponseType: function ( value ) {\n\n      this.responseType = value;\n      return this;\n\n    },\n\n    setWithCredentials: function ( value ) {\n\n      this.withCredentials = value;\n      return this;\n\n    },\n\n    setMimeType: function ( value ) {\n\n      this.mimeType = value;\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   *\n   * Abstract Base class to block based textures loader (dds, pvr, ...)\n   */\n\n  function CompressedTextureLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n    // override in sub classes\n    this._parser = null;\n\n  }\n\n  Object.assign( CompressedTextureLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var images = [];\n\n      var texture = new CompressedTexture();\n      texture.image = images;\n\n      var loader = new FileLoader( this.manager );\n      loader.setPath( this.path );\n      loader.setResponseType( 'arraybuffer' );\n\n      function loadTexture( i ) {\n\n        loader.load( url[ i ], function ( buffer ) {\n\n          var texDatas = scope._parser( buffer, true );\n\n          images[ i ] = {\n            width: texDatas.width,\n            height: texDatas.height,\n            format: texDatas.format,\n            mipmaps: texDatas.mipmaps\n          };\n\n          loaded += 1;\n\n          if ( loaded === 6 ) {\n\n            if ( texDatas.mipmapCount === 1 )\n              texture.minFilter = LinearFilter;\n\n            texture.format = texDatas.format;\n            texture.needsUpdate = true;\n\n            if ( onLoad ) onLoad( texture );\n\n          }\n\n        }, onProgress, onError );\n\n      }\n\n      if ( Array.isArray( url ) ) {\n\n        var loaded = 0;\n\n        for ( var i = 0, il = url.length; i < il; ++ i ) {\n\n          loadTexture( i );\n\n        }\n\n      } else {\n\n        // compressed cubemap texture stored in a single DDS file\n\n        loader.load( url, function ( buffer ) {\n\n          var texDatas = scope._parser( buffer, true );\n\n          if ( texDatas.isCubemap ) {\n\n            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n            for ( var f = 0; f < faces; f ++ ) {\n\n              images[ f ] = { mipmaps : [] };\n\n              for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n                images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n                images[ f ].format = texDatas.format;\n                images[ f ].width = texDatas.width;\n                images[ f ].height = texDatas.height;\n\n              }\n\n            }\n\n          } else {\n\n            texture.image.width = texDatas.width;\n            texture.image.height = texDatas.height;\n            texture.mipmaps = texDatas.mipmaps;\n\n          }\n\n          if ( texDatas.mipmapCount === 1 ) {\n\n            texture.minFilter = LinearFilter;\n\n          }\n\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n\n          if ( onLoad ) onLoad( texture );\n\n        }, onProgress, onError );\n\n      }\n\n      return texture;\n\n    },\n\n    setPath: function ( value ) {\n\n      this.path = value;\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author Nikos M. / https://github.com/foo123/\n   *\n   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n   */\n\n  function DataTextureLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n    // override in sub classes\n    this._parser = null;\n\n  }\n\n  Object.assign( DataTextureLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var texture = new DataTexture();\n\n      var loader = new FileLoader( this.manager );\n      loader.setResponseType( 'arraybuffer' );\n\n      loader.load( url, function ( buffer ) {\n\n        var texData = scope._parser( buffer );\n\n        if ( ! texData ) return;\n\n        if ( undefined !== texData.image ) {\n\n          texture.image = texData.image;\n\n        } else if ( undefined !== texData.data ) {\n\n          texture.image.width = texData.width;\n          texture.image.height = texData.height;\n          texture.image.data = texData.data;\n\n        }\n\n        texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\n        texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\n\n        texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\n        texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\n\n        texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n        if ( undefined !== texData.format ) {\n\n          texture.format = texData.format;\n\n        }\n        if ( undefined !== texData.type ) {\n\n          texture.type = texData.type;\n\n        }\n\n        if ( undefined !== texData.mipmaps ) {\n\n          texture.mipmaps = texData.mipmaps;\n\n        }\n\n        if ( 1 === texData.mipmapCount ) {\n\n          texture.minFilter = LinearFilter;\n\n        }\n\n        texture.needsUpdate = true;\n\n        if ( onLoad ) onLoad( texture, texData );\n\n      }, onProgress, onError );\n\n\n      return texture;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function ImageLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( ImageLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      if ( url === undefined ) url = '';\n\n      if ( this.path !== undefined ) url = this.path + url;\n\n      var scope = this;\n\n      var cached = Cache.get( url );\n\n      if ( cached !== undefined ) {\n\n        scope.manager.itemStart( url );\n\n        setTimeout( function () {\n\n          if ( onLoad ) onLoad( cached );\n\n          scope.manager.itemEnd( url );\n\n        }, 0 );\n\n        return cached;\n\n      }\n\n      var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n      image.addEventListener( 'load', function () {\n\n        Cache.add( url, this );\n\n        if ( onLoad ) onLoad( this );\n\n        scope.manager.itemEnd( url );\n\n      }, false );\n\n      /*\n      image.addEventListener( 'progress', function ( event ) {\n\n        if ( onProgress ) onProgress( event );\n\n      }, false );\n      */\n\n      image.addEventListener( 'error', function ( event ) {\n\n        if ( onError ) onError( event );\n\n        scope.manager.itemError( url );\n\n      }, false );\n\n      if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n      scope.manager.itemStart( url );\n\n      image.src = url;\n\n      return image;\n\n    },\n\n    setCrossOrigin: function ( value ) {\n\n      this.crossOrigin = value;\n      return this;\n\n    },\n\n    setPath: function ( value ) {\n\n      this.path = value;\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function CubeTextureLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( CubeTextureLoader.prototype, {\n\n    load: function ( urls, onLoad, onProgress, onError ) {\n\n      var texture = new CubeTexture();\n\n      var loader = new ImageLoader( this.manager );\n      loader.setCrossOrigin( this.crossOrigin );\n      loader.setPath( this.path );\n\n      var loaded = 0;\n\n      function loadTexture( i ) {\n\n        loader.load( urls[ i ], function ( image ) {\n\n          texture.images[ i ] = image;\n\n          loaded ++;\n\n          if ( loaded === 6 ) {\n\n            texture.needsUpdate = true;\n\n            if ( onLoad ) onLoad( texture );\n\n          }\n\n        }, undefined, onError );\n\n      }\n\n      for ( var i = 0; i < urls.length; ++ i ) {\n\n        loadTexture( i );\n\n      }\n\n      return texture;\n\n    },\n\n    setCrossOrigin: function ( value ) {\n\n      this.crossOrigin = value;\n      return this;\n\n    },\n\n    setPath: function ( value ) {\n\n      this.path = value;\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function TextureLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( TextureLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var texture = new Texture();\n\n      var loader = new ImageLoader( this.manager );\n      loader.setCrossOrigin( this.crossOrigin );\n      loader.setPath( this.path );\n      loader.load( url, function ( image ) {\n\n        // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n        var isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n        texture.format = isJPEG ? RGBFormat : RGBAFormat;\n        texture.image = image;\n        texture.needsUpdate = true;\n\n        if ( onLoad !== undefined ) {\n\n          onLoad( texture );\n\n        }\n\n      }, onProgress, onError );\n\n      return texture;\n\n    },\n\n    setCrossOrigin: function ( value ) {\n\n      this.crossOrigin = value;\n      return this;\n\n    },\n\n    setPath: function ( value ) {\n\n      this.path = value;\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Light( color, intensity ) {\n\n    Object3D.call( this );\n\n    this.type = 'Light';\n\n    this.color = new Color( color );\n    this.intensity = intensity !== undefined ? intensity : 1;\n\n    this.receiveShadow = undefined;\n\n  }\n\n  Light.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Light,\n\n    isLight: true,\n\n    copy: function ( source ) {\n\n      Object3D.prototype.copy.call( this, source );\n\n      this.color.copy( source.color );\n      this.intensity = source.intensity;\n\n      return this;\n\n    },\n\n    toJSON: function ( meta ) {\n\n      var data = Object3D.prototype.toJSON.call( this, meta );\n\n      data.object.color = this.color.getHex();\n      data.object.intensity = this.intensity;\n\n      if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n      if ( this.distance !== undefined ) data.object.distance = this.distance;\n      if ( this.angle !== undefined ) data.object.angle = this.angle;\n      if ( this.decay !== undefined ) data.object.decay = this.decay;\n      if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n      if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n      return data;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function HemisphereLight( skyColor, groundColor, intensity ) {\n\n    Light.call( this, skyColor, intensity );\n\n    this.type = 'HemisphereLight';\n\n    this.castShadow = undefined;\n\n    this.position.copy( Object3D.DefaultUp );\n    this.updateMatrix();\n\n    this.groundColor = new Color( groundColor );\n\n  }\n\n  HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: HemisphereLight,\n\n    isHemisphereLight: true,\n\n    copy: function ( source ) {\n\n      Light.prototype.copy.call( this, source );\n\n      this.groundColor.copy( source.groundColor );\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function LightShadow( camera ) {\n\n    this.camera = camera;\n\n    this.bias = 0;\n    this.radius = 1;\n\n    this.mapSize = new Vector2( 512, 512 );\n\n    this.map = null;\n    this.matrix = new Matrix4();\n\n  }\n\n  Object.assign( LightShadow.prototype, {\n\n    copy: function ( source ) {\n\n      this.camera = source.camera.clone();\n\n      this.bias = source.bias;\n      this.radius = source.radius;\n\n      this.mapSize.copy( source.mapSize );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    toJSON: function () {\n\n      var object = {};\n\n      if ( this.bias !== 0 ) object.bias = this.bias;\n      if ( this.radius !== 1 ) object.radius = this.radius;\n      if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n      object.camera = this.camera.toJSON( false ).object;\n      delete object.camera.matrix;\n\n      return object;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function SpotLightShadow() {\n\n    LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n  }\n\n  SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n    constructor: SpotLightShadow,\n\n    isSpotLightShadow: true,\n\n    update: function ( light ) {\n\n      var fov = _Math.RAD2DEG * 2 * light.angle;\n      var aspect = this.mapSize.width / this.mapSize.height;\n      var far = light.distance || 500;\n\n      var camera = this.camera;\n\n      if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n        camera.fov = fov;\n        camera.aspect = aspect;\n        camera.far = far;\n        camera.updateProjectionMatrix();\n\n      }\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function SpotLight( color, intensity, distance, angle, penumbra, decay ) {\n\n    Light.call( this, color, intensity );\n\n    this.type = 'SpotLight';\n\n    this.position.copy( Object3D.DefaultUp );\n    this.updateMatrix();\n\n    this.target = new Object3D();\n\n    Object.defineProperty( this, 'power', {\n      get: function () {\n        // intensity = power per solid angle.\n        // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n        return this.intensity * Math.PI;\n      },\n      set: function ( power ) {\n        // intensity = power per solid angle.\n        // ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n        this.intensity = power / Math.PI;\n      }\n    } );\n\n    this.distance = ( distance !== undefined ) ? distance : 0;\n    this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n    this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.\n\n    this.shadow = new SpotLightShadow();\n\n  }\n\n  SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: SpotLight,\n\n    isSpotLight: true,\n\n    copy: function ( source ) {\n\n      Light.prototype.copy.call( this, source );\n\n      this.distance = source.distance;\n      this.angle = source.angle;\n      this.penumbra = source.penumbra;\n      this.decay = source.decay;\n\n      this.target = source.target.clone();\n\n      this.shadow = source.shadow.clone();\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n\n  function PointLight( color, intensity, distance, decay ) {\n\n    Light.call( this, color, intensity );\n\n    this.type = 'PointLight';\n\n    Object.defineProperty( this, 'power', {\n      get: function () {\n        // intensity = power per solid angle.\n        // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n        return this.intensity * 4 * Math.PI;\n\n      },\n      set: function ( power ) {\n        // intensity = power per solid angle.\n        // ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n        this.intensity = power / ( 4 * Math.PI );\n      }\n    } );\n\n    this.distance = ( distance !== undefined ) ? distance : 0;\n    this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.\n\n    this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n  }\n\n  PointLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: PointLight,\n\n    isPointLight: true,\n\n    copy: function ( source ) {\n\n      Light.prototype.copy.call( this, source );\n\n      this.distance = source.distance;\n      this.decay = source.decay;\n\n      this.shadow = source.shadow.clone();\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function DirectionalLightShadow( ) {\n\n    LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n  }\n\n  DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\n\n    constructor: DirectionalLightShadow\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function DirectionalLight( color, intensity ) {\n\n    Light.call( this, color, intensity );\n\n    this.type = 'DirectionalLight';\n\n    this.position.copy( Object3D.DefaultUp );\n    this.updateMatrix();\n\n    this.target = new Object3D();\n\n    this.shadow = new DirectionalLightShadow();\n\n  }\n\n  DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: DirectionalLight,\n\n    isDirectionalLight: true,\n\n    copy: function ( source ) {\n\n      Light.prototype.copy.call( this, source );\n\n      this.target = source.target.clone();\n\n      this.shadow = source.shadow.clone();\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function AmbientLight( color, intensity ) {\n\n    Light.call( this, color, intensity );\n\n    this.type = 'AmbientLight';\n\n    this.castShadow = undefined;\n\n  }\n\n  AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: AmbientLight,\n\n    isAmbientLight: true\n\n  } );\n\n  /**\n   * @author tschw\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   */\n\n  var AnimationUtils = {\n\n    // same as Array.prototype.slice, but also works on typed arrays\n    arraySlice: function( array, from, to ) {\n\n      if ( AnimationUtils.isTypedArray( array ) ) {\n\n        return new array.constructor( array.subarray( from, to ) );\n\n      }\n\n      return array.slice( from, to );\n\n    },\n\n    // converts an array to a specific type\n    convertArray: function( array, type, forceClone ) {\n\n      if ( ! array || // let 'undefined' and 'null' pass\n          ! forceClone && array.constructor === type ) return array;\n\n      if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n        return new type( array ); // create typed array\n\n      }\n\n      return Array.prototype.slice.call( array ); // create Array\n\n    },\n\n    isTypedArray: function( object ) {\n\n      return ArrayBuffer.isView( object ) &&\n          ! ( object instanceof DataView );\n\n    },\n\n    // returns an array by which times and values can be sorted\n    getKeyframeOrder: function( times ) {\n\n      function compareTime( i, j ) {\n\n        return times[ i ] - times[ j ];\n\n      }\n\n      var n = times.length;\n      var result = new Array( n );\n      for ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n      result.sort( compareTime );\n\n      return result;\n\n    },\n\n    // uses the array previously returned by 'getKeyframeOrder' to sort data\n    sortedArray: function( values, stride, order ) {\n\n      var nValues = values.length;\n      var result = new values.constructor( nValues );\n\n      for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n        var srcOffset = order[ i ] * stride;\n\n        for ( var j = 0; j !== stride; ++ j ) {\n\n          result[ dstOffset ++ ] = values[ srcOffset + j ];\n\n        }\n\n      }\n\n      return result;\n\n    },\n\n    // function for parsing AOS keyframe formats\n    flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n      var i = 1, key = jsonKeys[ 0 ];\n\n      while ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n        key = jsonKeys[ i ++ ];\n\n      }\n\n      if ( key === undefined ) return; // no data\n\n      var value = key[ valuePropertyName ];\n      if ( value === undefined ) return; // no data\n\n      if ( Array.isArray( value ) ) {\n\n        do {\n\n          value = key[ valuePropertyName ];\n\n          if ( value !== undefined ) {\n\n            times.push( key.time );\n            values.push.apply( values, value ); // push all elements\n\n          }\n\n          key = jsonKeys[ i ++ ];\n\n        } while ( key !== undefined );\n\n      } else if ( value.toArray !== undefined ) {\n        // ...assume THREE.Math-ish\n\n        do {\n\n          value = key[ valuePropertyName ];\n\n          if ( value !== undefined ) {\n\n            times.push( key.time );\n            value.toArray( values, values.length );\n\n          }\n\n          key = jsonKeys[ i ++ ];\n\n        } while ( key !== undefined );\n\n      } else {\n        // otherwise push as-is\n\n        do {\n\n          value = key[ valuePropertyName ];\n\n          if ( value !== undefined ) {\n\n            times.push( key.time );\n            values.push( value );\n\n          }\n\n          key = jsonKeys[ i ++ ];\n\n        } while ( key !== undefined );\n\n      }\n\n    }\n\n  };\n\n  /**\n   * Abstract base class of interpolants over parametric samples.\n   *\n   * The parameter domain is one dimensional, typically the time or a path\n   * along a curve defined by the data.\n   *\n   * The sample values can have any dimensionality and derived classes may\n   * apply special interpretations to the data.\n   *\n   * This class provides the interval seek in a Template Method, deferring\n   * the actual interpolation to derived classes.\n   *\n   * Time complexity is O(1) for linear access crossing at most two points\n   * and O(log N) for random access, where N is the number of positions.\n   *\n   * References:\n   *\n   *    http://www.oodesign.com/template-method-pattern.html\n   *\n   * @author tschw\n   */\n\n  function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n\n    this.resultBuffer = resultBuffer !== undefined ?\n        resultBuffer : new sampleValues.constructor( sampleSize );\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n\n  }\n\n  Object.assign( Interpolant.prototype, {\n\n    evaluate: function( t ) {\n\n      var pp = this.parameterPositions,\n        i1 = this._cachedIndex,\n\n        t1 = pp[   i1   ],\n        t0 = pp[ i1 - 1 ];\n\n      validate_interval: {\n\n        seek: {\n\n          var right;\n\n          linear_scan: {\n            //- See http://jsperf.com/comparison-to-undefined/3\n            //- slower code:\n            //-\n            //-         if ( t >= t1 || t1 === undefined ) {\n            forward_scan: if ( ! ( t < t1 ) ) {\n\n              for ( var giveUpAt = i1 + 2; ;) {\n\n                if ( t1 === undefined ) {\n\n                  if ( t < t0 ) break forward_scan;\n\n                  // after end\n\n                  i1 = pp.length;\n                  this._cachedIndex = i1;\n                  return this.afterEnd_( i1 - 1, t, t0 );\n\n                }\n\n                if ( i1 === giveUpAt ) break; // this loop\n\n                t0 = t1;\n                t1 = pp[ ++ i1 ];\n\n                if ( t < t1 ) {\n\n                  // we have arrived at the sought interval\n                  break seek;\n\n                }\n\n              }\n\n              // prepare binary search on the right side of the index\n              right = pp.length;\n              break linear_scan;\n\n            }\n\n            //- slower code:\n            //-         if ( t < t0 || t0 === undefined ) {\n            if ( ! ( t >= t0 ) ) {\n\n              // looping?\n\n              var t1global = pp[ 1 ];\n\n              if ( t < t1global ) {\n\n                i1 = 2; // + 1, using the scan for the details\n                t0 = t1global;\n\n              }\n\n              // linear reverse scan\n\n              for ( var giveUpAt = i1 - 2; ;) {\n\n                if ( t0 === undefined ) {\n\n                  // before start\n\n                  this._cachedIndex = 0;\n                  return this.beforeStart_( 0, t, t1 );\n\n                }\n\n                if ( i1 === giveUpAt ) break; // this loop\n\n                t1 = t0;\n                t0 = pp[ -- i1 - 1 ];\n\n                if ( t >= t0 ) {\n\n                  // we have arrived at the sought interval\n                  break seek;\n\n                }\n\n              }\n\n              // prepare binary search on the left side of the index\n              right = i1;\n              i1 = 0;\n              break linear_scan;\n\n            }\n\n            // the interval is valid\n\n            break validate_interval;\n\n          } // linear scan\n\n          // binary search\n\n          while ( i1 < right ) {\n\n            var mid = ( i1 + right ) >>> 1;\n\n            if ( t < pp[ mid ] ) {\n\n              right = mid;\n\n            } else {\n\n              i1 = mid + 1;\n\n            }\n\n          }\n\n          t1 = pp[   i1   ];\n          t0 = pp[ i1 - 1 ];\n\n          // check boundary cases, again\n\n          if ( t0 === undefined ) {\n\n            this._cachedIndex = 0;\n            return this.beforeStart_( 0, t, t1 );\n\n          }\n\n          if ( t1 === undefined ) {\n\n            i1 = pp.length;\n            this._cachedIndex = i1;\n            return this.afterEnd_( i1 - 1, t0, t );\n\n          }\n\n        } // seek\n\n        this._cachedIndex = i1;\n\n        this.intervalChanged_( i1, t0, t1 );\n\n      } // validate_interval\n\n      return this.interpolate_( i1, t0, t, t1 );\n\n    },\n\n    settings: null, // optional, subclass-specific settings structure\n    // Note: The indirection allows central control of many interpolants.\n\n    // --- Protected interface\n\n    DefaultSettings_: {},\n\n    getSettings_: function() {\n\n      return this.settings || this.DefaultSettings_;\n\n    },\n\n    copySampleValue_: function( index ) {\n\n      // copies a sample value to the result buffer\n\n      var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n        offset = index * stride;\n\n      for ( var i = 0; i !== stride; ++ i ) {\n\n        result[ i ] = values[ offset + i ];\n\n      }\n\n      return result;\n\n    },\n\n    // Template methods for derived classes:\n\n    interpolate_: function( i1, t0, t, t1 ) {\n\n      throw new Error( \"call to abstract method\" );\n      // implementations shall return this.resultBuffer\n\n    },\n\n    intervalChanged_: function( i1, t0, t1 ) {\n\n      // empty\n\n    }\n\n  } );\n\n  //!\\ DECLARE ALIAS AFTER assign prototype !\n  Object.assign( Interpolant.prototype, {\n\n    //( 0, t, t0 ), returns this.resultBuffer\n    beforeStart_: Interpolant.prototype.copySampleValue_,\n\n    //( N-1, tN-1, t ), returns this.resultBuffer\n    afterEnd_: Interpolant.prototype.copySampleValue_,\n\n  } );\n\n  /**\n   * Fast and simple cubic spline interpolant.\n   *\n   * It was derived from a Hermitian construction setting the first derivative\n   * at each sample position to the linear slope between neighboring positions\n   * over their parameter interval.\n   *\n   * @author tschw\n   */\n\n  function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n    Interpolant.call(\n        this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n\n  }\n\n  CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n    constructor: CubicInterpolant,\n\n    DefaultSettings_: {\n\n      endingStart:  ZeroCurvatureEnding,\n      endingEnd:    ZeroCurvatureEnding\n\n    },\n\n    intervalChanged_: function( i1, t0, t1 ) {\n\n      var pp = this.parameterPositions,\n        iPrev = i1 - 2,\n        iNext = i1 + 1,\n\n        tPrev = pp[ iPrev ],\n        tNext = pp[ iNext ];\n\n      if ( tPrev === undefined ) {\n\n        switch ( this.getSettings_().endingStart ) {\n\n          case ZeroSlopeEnding:\n\n            // f'(t0) = 0\n            iPrev = i1;\n            tPrev = 2 * t0 - t1;\n\n            break;\n\n          case WrapAroundEnding:\n\n            // use the other end of the curve\n            iPrev = pp.length - 2;\n            tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n            break;\n\n          default: // ZeroCurvatureEnding\n\n            // f''(t0) = 0 a.k.a. Natural Spline\n            iPrev = i1;\n            tPrev = t1;\n\n        }\n\n      }\n\n      if ( tNext === undefined ) {\n\n        switch ( this.getSettings_().endingEnd ) {\n\n          case ZeroSlopeEnding:\n\n            // f'(tN) = 0\n            iNext = i1;\n            tNext = 2 * t1 - t0;\n\n            break;\n\n          case WrapAroundEnding:\n\n            // use the other end of the curve\n            iNext = 1;\n            tNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n            break;\n\n          default: // ZeroCurvatureEnding\n\n            // f''(tN) = 0, a.k.a. Natural Spline\n            iNext = i1 - 1;\n            tNext = t0;\n\n        }\n\n      }\n\n      var halfDt = ( t1 - t0 ) * 0.5,\n        stride = this.valueSize;\n\n      this._weightPrev = halfDt / ( t0 - tPrev );\n      this._weightNext = halfDt / ( tNext - t1 );\n      this._offsetPrev = iPrev * stride;\n      this._offsetNext = iNext * stride;\n\n    },\n\n    interpolate_: function( i1, t0, t, t1 ) {\n\n      var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n\n        o1 = i1 * stride,   o0 = o1 - stride,\n        oP = this._offsetPrev,  oN = this._offsetNext,\n        wP = this._weightPrev,  wN = this._weightNext,\n\n        p = ( t - t0 ) / ( t1 - t0 ),\n        pp = p * p,\n        ppp = pp * p;\n\n      // evaluate polynomials\n\n      var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n      var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n      var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n      var sN =       wN   * ppp   -           wN      * pp;\n\n      // combine data linearly\n\n      for ( var i = 0; i !== stride; ++ i ) {\n\n        result[ i ] =\n            sP * values[ oP + i ] +\n            s0 * values[ o0 + i ] +\n            s1 * values[ o1 + i ] +\n            sN * values[ oN + i ];\n\n      }\n\n      return result;\n\n    }\n\n  } );\n\n  /**\n   * @author tschw\n   */\n\n  function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n  }\n\n  LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n    constructor: LinearInterpolant,\n\n    interpolate_: function( i1, t0, t, t1 ) {\n\n      var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n\n        offset1 = i1 * stride,\n        offset0 = offset1 - stride,\n\n        weight1 = ( t - t0 ) / ( t1 - t0 ),\n        weight0 = 1 - weight1;\n\n      for ( var i = 0; i !== stride; ++ i ) {\n\n        result[ i ] =\n            values[ offset0 + i ] * weight0 +\n            values[ offset1 + i ] * weight1;\n\n      }\n\n      return result;\n\n    }\n\n  } );\n\n  /**\n   *\n   * Interpolant that evaluates to the sample value at the position preceeding\n   * the parameter.\n   *\n   * @author tschw\n   */\n\n  function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n  }\n\n  DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n    constructor: DiscreteInterpolant,\n\n    interpolate_: function( i1, t0, t, t1 ) {\n\n      return this.copySampleValue_( i1 - 1 );\n\n    }\n\n  } );\n\n  var KeyframeTrackPrototype;\n\n  KeyframeTrackPrototype = {\n\n    TimeBufferType: Float32Array,\n    ValueBufferType: Float32Array,\n\n    DefaultInterpolation: InterpolateLinear,\n\n    InterpolantFactoryMethodDiscrete: function ( result ) {\n\n      return new DiscreteInterpolant(\n          this.times, this.values, this.getValueSize(), result );\n\n    },\n\n    InterpolantFactoryMethodLinear: function ( result ) {\n\n      return new LinearInterpolant(\n          this.times, this.values, this.getValueSize(), result );\n\n    },\n\n    InterpolantFactoryMethodSmooth: function ( result ) {\n\n      return new CubicInterpolant(\n          this.times, this.values, this.getValueSize(), result );\n\n    },\n\n    setInterpolation: function ( interpolation ) {\n\n      var factoryMethod;\n\n      switch ( interpolation ) {\n\n        case InterpolateDiscrete:\n\n          factoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n          break;\n\n        case InterpolateLinear:\n\n          factoryMethod = this.InterpolantFactoryMethodLinear;\n\n          break;\n\n        case InterpolateSmooth:\n\n          factoryMethod = this.InterpolantFactoryMethodSmooth;\n\n          break;\n\n      }\n\n      if ( factoryMethod === undefined ) {\n\n        var message = \"unsupported interpolation for \" +\n            this.ValueTypeName + \" keyframe track named \" + this.name;\n\n        if ( this.createInterpolant === undefined ) {\n\n          // fall back to default, unless the default itself is messed up\n          if ( interpolation !== this.DefaultInterpolation ) {\n\n            this.setInterpolation( this.DefaultInterpolation );\n\n          } else {\n\n            throw new Error( message ); // fatal, in this case\n\n          }\n\n        }\n\n        console.warn( message );\n        return;\n\n      }\n\n      this.createInterpolant = factoryMethod;\n\n    },\n\n    getInterpolation: function () {\n\n      switch ( this.createInterpolant ) {\n\n        case this.InterpolantFactoryMethodDiscrete:\n\n          return InterpolateDiscrete;\n\n        case this.InterpolantFactoryMethodLinear:\n\n          return InterpolateLinear;\n\n        case this.InterpolantFactoryMethodSmooth:\n\n          return InterpolateSmooth;\n\n      }\n\n    },\n\n    getValueSize: function () {\n\n      return this.values.length / this.times.length;\n\n    },\n\n    // move all keyframes either forwards or backwards in time\n    shift: function ( timeOffset ) {\n\n      if ( timeOffset !== 0.0 ) {\n\n        var times = this.times;\n\n        for ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n          times[ i ] += timeOffset;\n\n        }\n\n      }\n\n      return this;\n\n    },\n\n    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n    scale: function ( timeScale ) {\n\n      if ( timeScale !== 1.0 ) {\n\n        var times = this.times;\n\n        for ( var i = 0, n = times.length; i !== n; ++ i ) {\n\n          times[ i ] *= timeScale;\n\n        }\n\n      }\n\n      return this;\n\n    },\n\n    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n    trim: function ( startTime, endTime ) {\n\n      var times = this.times,\n        nKeys = times.length,\n        from = 0,\n        to = nKeys - 1;\n\n      while ( from !== nKeys && times[ from ] < startTime ) ++ from;\n      while ( to !== - 1 && times[ to ] > endTime ) -- to;\n\n      ++ to; // inclusive -> exclusive bound\n\n      if ( from !== 0 || to !== nKeys ) {\n\n        // empty tracks are forbidden, so keep at least one keyframe\n        if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\n\n        var stride = this.getValueSize();\n        this.times = AnimationUtils.arraySlice( times, from, to );\n        this.values = AnimationUtils.\n            arraySlice( this.values, from * stride, to * stride );\n\n      }\n\n      return this;\n\n    },\n\n    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n    validate: function () {\n\n      var valid = true;\n\n      var valueSize = this.getValueSize();\n      if ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n        console.error( \"invalid value size in track\", this );\n        valid = false;\n\n      }\n\n      var times = this.times,\n        values = this.values,\n\n        nKeys = times.length;\n\n      if ( nKeys === 0 ) {\n\n        console.error( \"track is empty\", this );\n        valid = false;\n\n      }\n\n      var prevTime = null;\n\n      for ( var i = 0; i !== nKeys; i ++ ) {\n\n        var currTime = times[ i ];\n\n        if ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n          console.error( \"time is not a valid number\", this, i, currTime );\n          valid = false;\n          break;\n\n        }\n\n        if ( prevTime !== null && prevTime > currTime ) {\n\n          console.error( \"out of order keys\", this, i, currTime, prevTime );\n          valid = false;\n          break;\n\n        }\n\n        prevTime = currTime;\n\n      }\n\n      if ( values !== undefined ) {\n\n        if ( AnimationUtils.isTypedArray( values ) ) {\n\n          for ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n            var value = values[ i ];\n\n            if ( isNaN( value ) ) {\n\n              console.error( \"value is not a valid number\", this, i, value );\n              valid = false;\n              break;\n\n            }\n\n          }\n\n        }\n\n      }\n\n      return valid;\n\n    },\n\n    // removes equivalent sequential keys as common in morph target sequences\n    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n    optimize: function () {\n\n      var times = this.times,\n        values = this.values,\n        stride = this.getValueSize(),\n\n        smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n        writeIndex = 1,\n        lastIndex = times.length - 1;\n\n      for ( var i = 1; i < lastIndex; ++ i ) {\n\n        var keep = false;\n\n        var time = times[ i ];\n        var timeNext = times[ i + 1 ];\n\n        // remove adjacent keyframes scheduled at the same time\n\n        if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n          if ( ! smoothInterpolation ) {\n\n            // remove unnecessary keyframes same as their neighbors\n\n            var offset = i * stride,\n              offsetP = offset - stride,\n              offsetN = offset + stride;\n\n            for ( var j = 0; j !== stride; ++ j ) {\n\n              var value = values[ offset + j ];\n\n              if ( value !== values[ offsetP + j ] ||\n                  value !== values[ offsetN + j ] ) {\n\n                keep = true;\n                break;\n\n              }\n\n            }\n\n          } else keep = true;\n\n        }\n\n        // in-place compaction\n\n        if ( keep ) {\n\n          if ( i !== writeIndex ) {\n\n            times[ writeIndex ] = times[ i ];\n\n            var readOffset = i * stride,\n              writeOffset = writeIndex * stride;\n\n            for ( var j = 0; j !== stride; ++ j )\n\n              values[ writeOffset + j ] = values[ readOffset + j ];\n\n          }\n\n          ++ writeIndex;\n\n        }\n\n      }\n\n      // flush last keyframe (compaction looks ahead)\n\n      if ( lastIndex > 0 ) {\n\n        times[ writeIndex ] = times[ lastIndex ];\n\n        for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )\n\n          values[ writeOffset + j ] = values[ readOffset + j ];\n\n        ++ writeIndex;\n\n      }\n\n      if ( writeIndex !== times.length ) {\n\n        this.times = AnimationUtils.arraySlice( times, 0, writeIndex );\n        this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n      }\n\n      return this;\n\n    }\n\n  };\n\n  function KeyframeTrackConstructor( name, times, values, interpolation ) {\n\n    if( name === undefined ) throw new Error( \"track name is undefined\" );\n\n    if( times === undefined || times.length === 0 ) {\n\n      throw new Error( \"no keyframes in track named \" + name );\n\n    }\n\n    this.name = name;\n\n    this.times = AnimationUtils.convertArray( times, this.TimeBufferType );\n    this.values = AnimationUtils.convertArray( values, this.ValueBufferType );\n\n    this.setInterpolation( interpolation || this.DefaultInterpolation );\n\n    this.validate();\n    this.optimize();\n\n  }\n\n  /**\n   *\n   * A Track of vectored keyframe values.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function VectorKeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n  }\n\n  VectorKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: VectorKeyframeTrack,\n\n    ValueTypeName: 'vector'\n\n    // ValueBufferType is inherited\n\n    // DefaultInterpolation is inherited\n\n  } );\n\n  /**\n   * Spherical linear unit quaternion interpolant.\n   *\n   * @author tschw\n   */\n\n  function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n    Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n  }\n\n  QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\n\n    constructor: QuaternionLinearInterpolant,\n\n    interpolate_: function( i1, t0, t, t1 ) {\n\n      var result = this.resultBuffer,\n        values = this.sampleValues,\n        stride = this.valueSize,\n\n        offset = i1 * stride,\n\n        alpha = ( t - t0 ) / ( t1 - t0 );\n\n      for ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n        Quaternion.slerpFlat( result, 0,\n            values, offset - stride, values, offset, alpha );\n\n      }\n\n      return result;\n\n    }\n\n  } );\n\n  /**\n   *\n   * A Track of quaternion keyframe values.\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function QuaternionKeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n  }\n\n  QuaternionKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: QuaternionKeyframeTrack,\n\n    ValueTypeName: 'quaternion',\n\n    // ValueBufferType is inherited\n\n    DefaultInterpolation: InterpolateLinear,\n\n    InterpolantFactoryMethodLinear: function( result ) {\n\n      return new QuaternionLinearInterpolant(\n          this.times, this.values, this.getValueSize(), result );\n\n    },\n\n    InterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n  } );\n\n  /**\n   *\n   * A Track of numeric keyframe values.\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function NumberKeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n  }\n\n  NumberKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: NumberKeyframeTrack,\n\n    ValueTypeName: 'number'\n\n    // ValueBufferType is inherited\n\n    // DefaultInterpolation is inherited\n\n  } );\n\n  /**\n   *\n   * A Track that interpolates Strings\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function StringKeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n  }\n\n  StringKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: StringKeyframeTrack,\n\n    ValueTypeName: 'string',\n    ValueBufferType: Array,\n\n    DefaultInterpolation: InterpolateDiscrete,\n\n    InterpolantFactoryMethodLinear: undefined,\n\n    InterpolantFactoryMethodSmooth: undefined\n\n  } );\n\n  /**\n   *\n   * A Track of Boolean keyframe values.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function BooleanKeyframeTrack( name, times, values ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values );\n\n  }\n\n  BooleanKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: BooleanKeyframeTrack,\n\n    ValueTypeName: 'bool',\n    ValueBufferType: Array,\n\n    DefaultInterpolation: InterpolateDiscrete,\n\n    InterpolantFactoryMethodLinear: undefined,\n    InterpolantFactoryMethodSmooth: undefined\n\n    // Note: Actually this track could have a optimized / compressed\n    // representation of a single value and a custom interpolant that\n    // computes \"firstValue ^ isOdd( index )\".\n\n  } );\n\n  /**\n   *\n   * A Track of keyframe values that represent color.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function ColorKeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.call( this, name, times, values, interpolation );\n\n  }\n\n  ColorKeyframeTrack.prototype =\n      Object.assign( Object.create( KeyframeTrackPrototype ), {\n\n    constructor: ColorKeyframeTrack,\n\n    ValueTypeName: 'color'\n\n    // ValueBufferType is inherited\n\n    // DefaultInterpolation is inherited\n\n\n    // Note: Very basic implementation and nothing special yet.\n    // However, this is the place for color space parameterization.\n\n  } );\n\n  /**\n   *\n   * A timed sequence of keyframes for a specific property.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function KeyframeTrack( name, times, values, interpolation ) {\n\n    KeyframeTrackConstructor.apply( this, arguments );\n\n  }\n\n  KeyframeTrack.prototype = KeyframeTrackPrototype;\n  KeyframeTrackPrototype.constructor = KeyframeTrack;\n\n  // Static methods:\n\n  Object.assign( KeyframeTrack, {\n\n    // Serialization (in static context, because of constructor invocation\n    // and automatic invocation of .toJSON):\n\n    parse: function( json ) {\n\n      if( json.type === undefined ) {\n\n        throw new Error( \"track type undefined, can not parse\" );\n\n      }\n\n      var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n      if ( json.times === undefined ) {\n\n        var times = [], values = [];\n\n        AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n        json.times = times;\n        json.values = values;\n\n      }\n\n      // derived classes can define a static parse method\n      if ( trackType.parse !== undefined ) {\n\n        return trackType.parse( json );\n\n      } else {\n\n        // by default, we asssume a constructor compatible with the base\n        return new trackType(\n            json.name, json.times, json.values, json.interpolation );\n\n      }\n\n    },\n\n    toJSON: function( track ) {\n\n      var trackType = track.constructor;\n\n      var json;\n\n      // derived classes can define a static toJSON method\n      if ( trackType.toJSON !== undefined ) {\n\n        json = trackType.toJSON( track );\n\n      } else {\n\n        // by default, we assume the data can be serialized as-is\n        json = {\n\n          'name': track.name,\n          'times': AnimationUtils.convertArray( track.times, Array ),\n          'values': AnimationUtils.convertArray( track.values, Array )\n\n        };\n\n        var interpolation = track.getInterpolation();\n\n        if ( interpolation !== track.DefaultInterpolation ) {\n\n          json.interpolation = interpolation;\n\n        }\n\n      }\n\n      json.type = track.ValueTypeName; // mandatory\n\n      return json;\n\n    },\n\n    _getTrackTypeForValueTypeName: function( typeName ) {\n\n      switch( typeName.toLowerCase() ) {\n\n        case \"scalar\":\n        case \"double\":\n        case \"float\":\n        case \"number\":\n        case \"integer\":\n\n          return NumberKeyframeTrack;\n\n        case \"vector\":\n        case \"vector2\":\n        case \"vector3\":\n        case \"vector4\":\n\n          return VectorKeyframeTrack;\n\n        case \"color\":\n\n          return ColorKeyframeTrack;\n\n        case \"quaternion\":\n\n          return QuaternionKeyframeTrack;\n\n        case \"bool\":\n        case \"boolean\":\n\n          return BooleanKeyframeTrack;\n\n        case \"string\":\n\n          return StringKeyframeTrack;\n\n      }\n\n      throw new Error( \"Unsupported typeName: \" + typeName );\n\n    }\n\n  } );\n\n  /**\n   *\n   * Reusable set of Tracks that represent an animation.\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   */\n\n  function AnimationClip( name, duration, tracks ) {\n\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = ( duration !== undefined ) ? duration : - 1;\n\n    this.uuid = _Math.generateUUID();\n\n    // this means it should figure out its duration by scanning the tracks\n    if ( this.duration < 0 ) {\n\n      this.resetDuration();\n\n    }\n\n    this.optimize();\n\n  }\n\n  Object.assign( AnimationClip, {\n\n    parse: function ( json ) {\n\n      var tracks = [],\n        jsonTracks = json.tracks,\n        frameTime = 1.0 / ( json.fps || 1.0 );\n\n      for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n        tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n      }\n\n      return new AnimationClip( json.name, json.duration, tracks );\n\n    },\n\n    toJSON: function ( clip ) {\n\n      var tracks = [],\n        clipTracks = clip.tracks;\n\n      var json = {\n\n        'name': clip.name,\n        'duration': clip.duration,\n        'tracks': tracks\n\n      };\n\n      for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n        tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n      }\n\n      return json;\n\n    },\n\n    CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\n\n      var numMorphTargets = morphTargetSequence.length;\n      var tracks = [];\n\n      for ( var i = 0; i < numMorphTargets; i ++ ) {\n\n        var times = [];\n        var values = [];\n\n        times.push(\n            ( i + numMorphTargets - 1 ) % numMorphTargets,\n            i,\n            ( i + 1 ) % numMorphTargets );\n\n        values.push( 0, 1, 0 );\n\n        var order = AnimationUtils.getKeyframeOrder( times );\n        times = AnimationUtils.sortedArray( times, 1, order );\n        values = AnimationUtils.sortedArray( values, 1, order );\n\n        // if there is a key at the first frame, duplicate it as the\n        // last frame as well for perfect loop.\n        if ( ! noLoop && times[ 0 ] === 0 ) {\n\n          times.push( numMorphTargets );\n          values.push( values[ 0 ] );\n\n        }\n\n        tracks.push(\n            new NumberKeyframeTrack(\n              '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n              times, values\n            ).scale( 1.0 / fps ) );\n\n      }\n\n      return new AnimationClip( name, - 1, tracks );\n\n    },\n\n    findByName: function ( objectOrClipArray, name ) {\n\n      var clipArray = objectOrClipArray;\n\n      if ( ! Array.isArray( objectOrClipArray ) ) {\n\n        var o = objectOrClipArray;\n        clipArray = o.geometry && o.geometry.animations || o.animations;\n\n      }\n\n      for ( var i = 0; i < clipArray.length; i ++ ) {\n\n        if ( clipArray[ i ].name === name ) {\n\n          return clipArray[ i ];\n\n        }\n\n      }\n\n      return null;\n\n    },\n\n    CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\n\n      var animationToMorphTargets = {};\n\n      // tested with https://regex101.com/ on trick sequences\n      // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n      var pattern = /^([\\w-]*?)([\\d]+)$/;\n\n      // sort morph target names into animation groups based\n      // patterns like Walk_001, Walk_002, Run_001, Run_002\n      for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n        var morphTarget = morphTargets[ i ];\n        var parts = morphTarget.name.match( pattern );\n\n        if ( parts && parts.length > 1 ) {\n\n          var name = parts[ 1 ];\n\n          var animationMorphTargets = animationToMorphTargets[ name ];\n          if ( ! animationMorphTargets ) {\n\n            animationToMorphTargets[ name ] = animationMorphTargets = [];\n\n          }\n\n          animationMorphTargets.push( morphTarget );\n\n        }\n\n      }\n\n      var clips = [];\n\n      for ( var name in animationToMorphTargets ) {\n\n        clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n      }\n\n      return clips;\n\n    },\n\n    // parse the animation.hierarchy format\n    parseAnimation: function ( animation, bones ) {\n\n      if ( ! animation ) {\n\n        console.error( \"  no animation in JSONLoader data\" );\n        return null;\n\n      }\n\n      var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n        // only return track if there are actually keys.\n        if ( animationKeys.length !== 0 ) {\n\n          var times = [];\n          var values = [];\n\n          AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\n\n          // empty keys are filtered out, so check again\n          if ( times.length !== 0 ) {\n\n            destTracks.push( new trackType( trackName, times, values ) );\n\n          }\n\n        }\n\n      };\n\n      var tracks = [];\n\n      var clipName = animation.name || 'default';\n      // automatic length determination in AnimationClip.\n      var duration = animation.length || - 1;\n      var fps = animation.fps || 30;\n\n      var hierarchyTracks = animation.hierarchy || [];\n\n      for ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n        var animationKeys = hierarchyTracks[ h ].keys;\n\n        // skip empty tracks\n        if ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n        // process morph targets in a way exactly compatible\n        // with AnimationHandler.init( animation )\n        if ( animationKeys[ 0 ].morphTargets ) {\n\n          // figure out all morph targets used in this track\n          var morphTargetNames = {};\n\n          for ( var k = 0; k < animationKeys.length; k ++ ) {\n\n            if ( animationKeys[ k ].morphTargets ) {\n\n              for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n                morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n              }\n\n            }\n\n          }\n\n          // create a track for each morph target with all zero\n          // morphTargetInfluences except for the keys in which\n          // the morphTarget is named.\n          for ( var morphTargetName in morphTargetNames ) {\n\n            var times = [];\n            var values = [];\n\n            for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n              var animationKey = animationKeys[ k ];\n\n              times.push( animationKey.time );\n              values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n            }\n\n            tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n          }\n\n          duration = morphTargetNames.length * ( fps || 1.0 );\n\n        } else {\n\n          // ...assume skeletal animation\n\n          var boneName = '.bones[' + bones[ h ].name + ']';\n\n          addNonemptyTrack(\n              VectorKeyframeTrack, boneName + '.position',\n              animationKeys, 'pos', tracks );\n\n          addNonemptyTrack(\n              QuaternionKeyframeTrack, boneName + '.quaternion',\n              animationKeys, 'rot', tracks );\n\n          addNonemptyTrack(\n              VectorKeyframeTrack, boneName + '.scale',\n              animationKeys, 'scl', tracks );\n\n        }\n\n      }\n\n      if ( tracks.length === 0 ) {\n\n        return null;\n\n      }\n\n      var clip = new AnimationClip( clipName, duration, tracks );\n\n      return clip;\n\n    }\n\n  } );\n\n  Object.assign( AnimationClip.prototype, {\n\n    resetDuration: function () {\n\n      var tracks = this.tracks, duration = 0;\n\n      for ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n        var track = this.tracks[ i ];\n\n        duration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n      }\n\n      this.duration = duration;\n\n    },\n\n    trim: function () {\n\n      for ( var i = 0; i < this.tracks.length; i ++ ) {\n\n        this.tracks[ i ].trim( 0, this.duration );\n\n      }\n\n      return this;\n\n    },\n\n    optimize: function () {\n\n      for ( var i = 0; i < this.tracks.length; i ++ ) {\n\n        this.tracks[ i ].optimize();\n\n      }\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function MaterialLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n    this.textures = {};\n\n  }\n\n  Object.assign( MaterialLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var loader = new FileLoader( scope.manager );\n      loader.load( url, function ( text ) {\n\n        onLoad( scope.parse( JSON.parse( text ) ) );\n\n      }, onProgress, onError );\n\n    },\n\n    setTextures: function ( value ) {\n\n      this.textures = value;\n\n    },\n\n    parse: function ( json ) {\n\n      var textures = this.textures;\n\n      function getTexture( name ) {\n\n        if ( textures[ name ] === undefined ) {\n\n          console.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n        }\n\n        return textures[ name ];\n\n      }\n\n      var material = new Materials[ json.type ]();\n\n      if ( json.uuid !== undefined ) material.uuid = json.uuid;\n      if ( json.name !== undefined ) material.name = json.name;\n      if ( json.color !== undefined ) material.color.setHex( json.color );\n      if ( json.roughness !== undefined ) material.roughness = json.roughness;\n      if ( json.metalness !== undefined ) material.metalness = json.metalness;\n      if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n      if ( json.specular !== undefined ) material.specular.setHex( json.specular );\n      if ( json.shininess !== undefined ) material.shininess = json.shininess;\n      if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\n      if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\n      if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n      if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n      if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n      if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n      if ( json.fog !== undefined ) material.fog = json.fog;\n      if ( json.shading !== undefined ) material.shading = json.shading;\n      if ( json.blending !== undefined ) material.blending = json.blending;\n      if ( json.side !== undefined ) material.side = json.side;\n      if ( json.opacity !== undefined ) material.opacity = json.opacity;\n      if ( json.transparent !== undefined ) material.transparent = json.transparent;\n      if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n      if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n      if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n      if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n      if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n      if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n      if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n      if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n      if ( json.skinning !== undefined ) material.skinning = json.skinning;\n      if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\n\n      // for PointsMaterial\n\n      if ( json.size !== undefined ) material.size = json.size;\n      if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n      // maps\n\n      if ( json.map !== undefined ) material.map = getTexture( json.map );\n\n      if ( json.alphaMap !== undefined ) {\n\n        material.alphaMap = getTexture( json.alphaMap );\n        material.transparent = true;\n\n      }\n\n      if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n      if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n      if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n      if ( json.normalScale !== undefined ) {\n\n        var normalScale = json.normalScale;\n\n        if ( Array.isArray( normalScale ) === false ) {\n\n          // Blender exporter used to export a scalar. See #7459\n\n          normalScale = [ normalScale, normalScale ];\n\n        }\n\n        material.normalScale = new Vector2().fromArray( normalScale );\n\n      }\n\n      if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n      if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n      if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n      if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n      if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n      if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n      if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n      if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\n      if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\n      if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n      if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n      if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n      if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n      if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n      if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n      // MultiMaterial\n\n      if ( json.materials !== undefined ) {\n\n        for ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n          material.materials.push( this.parse( json.materials[ i ] ) );\n\n        }\n\n      }\n\n      return material;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function BufferGeometryLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( BufferGeometryLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var loader = new FileLoader( scope.manager );\n      loader.load( url, function ( text ) {\n\n        onLoad( scope.parse( JSON.parse( text ) ) );\n\n      }, onProgress, onError );\n\n    },\n\n    parse: function ( json ) {\n\n      var geometry = new BufferGeometry();\n\n      var index = json.data.index;\n\n      var TYPED_ARRAYS = {\n        'Int8Array': Int8Array,\n        'Uint8Array': Uint8Array,\n        'Uint8ClampedArray': Uint8ClampedArray,\n        'Int16Array': Int16Array,\n        'Uint16Array': Uint16Array,\n        'Int32Array': Int32Array,\n        'Uint32Array': Uint32Array,\n        'Float32Array': Float32Array,\n        'Float64Array': Float64Array\n      };\n\n      if ( index !== undefined ) {\n\n        var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n        geometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n      }\n\n      var attributes = json.data.attributes;\n\n      for ( var key in attributes ) {\n\n        var attribute = attributes[ key ];\n        var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n        geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n      }\n\n      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n      if ( groups !== undefined ) {\n\n        for ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n          var group = groups[ i ];\n\n          geometry.addGroup( group.start, group.count, group.materialIndex );\n\n        }\n\n      }\n\n      var boundingSphere = json.data.boundingSphere;\n\n      if ( boundingSphere !== undefined ) {\n\n        var center = new Vector3();\n\n        if ( boundingSphere.center !== undefined ) {\n\n          center.fromArray( boundingSphere.center );\n\n        }\n\n        geometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n      }\n\n      return geometry;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Loader() {\n\n    this.onLoadStart = function () {};\n    this.onLoadProgress = function () {};\n    this.onLoadComplete = function () {};\n\n  }\n\n  Loader.Handlers = {\n\n    handlers: [],\n\n    add: function ( regex, loader ) {\n\n      this.handlers.push( regex, loader );\n\n    },\n\n    get: function ( file ) {\n\n      var handlers = this.handlers;\n\n      for ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n        var regex = handlers[ i ];\n        var loader = handlers[ i + 1 ];\n\n        if ( regex.test( file ) ) {\n\n          return loader;\n\n        }\n\n      }\n\n      return null;\n\n    }\n\n  };\n\n  Object.assign( Loader.prototype, {\n\n    crossOrigin: undefined,\n\n    extractUrlBase: function ( url ) {\n\n      var parts = url.split( '/' );\n\n      if ( parts.length === 1 ) return './';\n\n      parts.pop();\n\n      return parts.join( '/' ) + '/';\n\n    },\n\n    initMaterials: function ( materials, texturePath, crossOrigin ) {\n\n      var array = [];\n\n      for ( var i = 0; i < materials.length; ++ i ) {\n\n        array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n      }\n\n      return array;\n\n    },\n\n    createMaterial: ( function () {\n\n      var BlendingMode = {\n        NoBlending: NoBlending,\n        NormalBlending: NormalBlending,\n        AdditiveBlending: AdditiveBlending,\n        SubtractiveBlending: SubtractiveBlending,\n        MultiplyBlending: MultiplyBlending,\n        CustomBlending: CustomBlending\n      };\n\n      var color = new Color();\n      var textureLoader = new TextureLoader();\n      var materialLoader = new MaterialLoader();\n\n      return function createMaterial( m, texturePath, crossOrigin ) {\n\n        // convert from old material format\n\n        var textures = {};\n\n        function loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n          var fullPath = texturePath + path;\n          var loader = Loader.Handlers.get( fullPath );\n\n          var texture;\n\n          if ( loader !== null ) {\n\n            texture = loader.load( fullPath );\n\n          } else {\n\n            textureLoader.setCrossOrigin( crossOrigin );\n            texture = textureLoader.load( fullPath );\n\n          }\n\n          if ( repeat !== undefined ) {\n\n            texture.repeat.fromArray( repeat );\n\n            if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\n            if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\n\n          }\n\n          if ( offset !== undefined ) {\n\n            texture.offset.fromArray( offset );\n\n          }\n\n          if ( wrap !== undefined ) {\n\n            if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\n            if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\n\n            if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\n            if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\n\n          }\n\n          if ( anisotropy !== undefined ) {\n\n            texture.anisotropy = anisotropy;\n\n          }\n\n          var uuid = _Math.generateUUID();\n\n          textures[ uuid ] = texture;\n\n          return uuid;\n\n        }\n\n        //\n\n        var json = {\n          uuid: _Math.generateUUID(),\n          type: 'MeshLambertMaterial'\n        };\n\n        for ( var name in m ) {\n\n          var value = m[ name ];\n\n          switch ( name ) {\n\n            case 'DbgColor':\n            case 'DbgIndex':\n            case 'opticalDensity':\n            case 'illumination':\n              break;\n            case 'DbgName':\n              json.name = value;\n              break;\n            case 'blending':\n              json.blending = BlendingMode[ value ];\n              break;\n            case 'colorAmbient':\n            case 'mapAmbient':\n              console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n              break;\n            case 'colorDiffuse':\n              json.color = color.fromArray( value ).getHex();\n              break;\n            case 'colorSpecular':\n              json.specular = color.fromArray( value ).getHex();\n              break;\n            case 'colorEmissive':\n              json.emissive = color.fromArray( value ).getHex();\n              break;\n            case 'specularCoef':\n              json.shininess = value;\n              break;\n            case 'shading':\n              if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n              if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n              if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n              break;\n            case 'mapDiffuse':\n              json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n              break;\n            case 'mapDiffuseRepeat':\n            case 'mapDiffuseOffset':\n            case 'mapDiffuseWrap':\n            case 'mapDiffuseAnisotropy':\n              break;\n            case 'mapEmissive':\n              json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n              break;\n            case 'mapEmissiveRepeat':\n            case 'mapEmissiveOffset':\n            case 'mapEmissiveWrap':\n            case 'mapEmissiveAnisotropy':\n              break;\n            case 'mapLight':\n              json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n              break;\n            case 'mapLightRepeat':\n            case 'mapLightOffset':\n            case 'mapLightWrap':\n            case 'mapLightAnisotropy':\n              break;\n            case 'mapAO':\n              json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n              break;\n            case 'mapAORepeat':\n            case 'mapAOOffset':\n            case 'mapAOWrap':\n            case 'mapAOAnisotropy':\n              break;\n            case 'mapBump':\n              json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n              break;\n            case 'mapBumpScale':\n              json.bumpScale = value;\n              break;\n            case 'mapBumpRepeat':\n            case 'mapBumpOffset':\n            case 'mapBumpWrap':\n            case 'mapBumpAnisotropy':\n              break;\n            case 'mapNormal':\n              json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n              break;\n            case 'mapNormalFactor':\n              json.normalScale = [ value, value ];\n              break;\n            case 'mapNormalRepeat':\n            case 'mapNormalOffset':\n            case 'mapNormalWrap':\n            case 'mapNormalAnisotropy':\n              break;\n            case 'mapSpecular':\n              json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n              break;\n            case 'mapSpecularRepeat':\n            case 'mapSpecularOffset':\n            case 'mapSpecularWrap':\n            case 'mapSpecularAnisotropy':\n              break;\n            case 'mapMetalness':\n              json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n              break;\n            case 'mapMetalnessRepeat':\n            case 'mapMetalnessOffset':\n            case 'mapMetalnessWrap':\n            case 'mapMetalnessAnisotropy':\n              break;\n            case 'mapRoughness':\n              json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n              break;\n            case 'mapRoughnessRepeat':\n            case 'mapRoughnessOffset':\n            case 'mapRoughnessWrap':\n            case 'mapRoughnessAnisotropy':\n              break;\n            case 'mapAlpha':\n              json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n              break;\n            case 'mapAlphaRepeat':\n            case 'mapAlphaOffset':\n            case 'mapAlphaWrap':\n            case 'mapAlphaAnisotropy':\n              break;\n            case 'flipSided':\n              json.side = BackSide;\n              break;\n            case 'doubleSided':\n              json.side = DoubleSide;\n              break;\n            case 'transparency':\n              console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n              json.opacity = value;\n              break;\n            case 'depthTest':\n            case 'depthWrite':\n            case 'colorWrite':\n            case 'opacity':\n            case 'reflectivity':\n            case 'transparent':\n            case 'visible':\n            case 'wireframe':\n              json[ name ] = value;\n              break;\n            case 'vertexColors':\n              if ( value === true ) json.vertexColors = VertexColors;\n              if ( value === 'face' ) json.vertexColors = FaceColors;\n              break;\n            default:\n              console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n              break;\n\n          }\n\n        }\n\n        if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n        if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n        if ( json.opacity < 1 ) json.transparent = true;\n\n        materialLoader.setTextures( textures );\n\n        return materialLoader.parse( json );\n\n      };\n\n    } )()\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function JSONLoader( manager ) {\n\n    if ( typeof manager === 'boolean' ) {\n\n      console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n      manager = undefined;\n\n    }\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n    this.withCredentials = false;\n\n  }\n\n  Object.assign( JSONLoader.prototype, {\n\n    load: function( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );\n\n      var loader = new FileLoader( this.manager );\n      loader.setWithCredentials( this.withCredentials );\n      loader.load( url, function ( text ) {\n\n        var json = JSON.parse( text );\n        var metadata = json.metadata;\n\n        if ( metadata !== undefined ) {\n\n          var type = metadata.type;\n\n          if ( type !== undefined ) {\n\n            if ( type.toLowerCase() === 'object' ) {\n\n              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n              return;\n\n            }\n\n            if ( type.toLowerCase() === 'scene' ) {\n\n              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n              return;\n\n            }\n\n          }\n\n        }\n\n        var object = scope.parse( json, texturePath );\n        onLoad( object.geometry, object.materials );\n\n      }, onProgress, onError );\n\n    },\n\n    setTexturePath: function ( value ) {\n\n      this.texturePath = value;\n\n    },\n\n    parse: function ( json, texturePath ) {\n\n      var geometry = new Geometry(),\n      scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n      parseModel( scale );\n\n      parseSkin();\n      parseMorphing( scale );\n      parseAnimations();\n\n      geometry.computeFaceNormals();\n      geometry.computeBoundingSphere();\n\n      function parseModel( scale ) {\n\n        function isBitSet( value, position ) {\n\n          return value & ( 1 << position );\n\n        }\n\n        var i, j, fi,\n\n        offset, zLength,\n\n      colorIndex, normalIndex, uvIndex, materialIndex,\n\n        type,\n        isQuad,\n        hasMaterial,\n        hasFaceVertexUv,\n        hasFaceNormal, hasFaceVertexNormal,\n        hasFaceColor, hasFaceVertexColor,\n\n      vertex, face, faceA, faceB, hex, normal,\n\n        uvLayer, uv, u, v,\n\n        faces = json.faces,\n        vertices = json.vertices,\n        normals = json.normals,\n        colors = json.colors,\n\n        nUvLayers = 0;\n\n        if ( json.uvs !== undefined ) {\n\n          // disregard empty arrays\n\n          for ( i = 0; i < json.uvs.length; i ++ ) {\n\n            if ( json.uvs[ i ].length ) nUvLayers ++;\n\n          }\n\n          for ( i = 0; i < nUvLayers; i ++ ) {\n\n            geometry.faceVertexUvs[ i ] = [];\n\n          }\n\n        }\n\n        offset = 0;\n        zLength = vertices.length;\n\n        while ( offset < zLength ) {\n\n          vertex = new Vector3();\n\n          vertex.x = vertices[ offset ++ ] * scale;\n          vertex.y = vertices[ offset ++ ] * scale;\n          vertex.z = vertices[ offset ++ ] * scale;\n\n          geometry.vertices.push( vertex );\n\n        }\n\n        offset = 0;\n        zLength = faces.length;\n\n        while ( offset < zLength ) {\n\n          type = faces[ offset ++ ];\n\n\n          isQuad              = isBitSet( type, 0 );\n          hasMaterial         = isBitSet( type, 1 );\n          hasFaceVertexUv     = isBitSet( type, 3 );\n          hasFaceNormal       = isBitSet( type, 4 );\n          hasFaceVertexNormal = isBitSet( type, 5 );\n          hasFaceColor       = isBitSet( type, 6 );\n          hasFaceVertexColor  = isBitSet( type, 7 );\n\n          // console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n          if ( isQuad ) {\n\n            faceA = new Face3();\n            faceA.a = faces[ offset ];\n            faceA.b = faces[ offset + 1 ];\n            faceA.c = faces[ offset + 3 ];\n\n            faceB = new Face3();\n            faceB.a = faces[ offset + 1 ];\n            faceB.b = faces[ offset + 2 ];\n            faceB.c = faces[ offset + 3 ];\n\n            offset += 4;\n\n            if ( hasMaterial ) {\n\n              materialIndex = faces[ offset ++ ];\n              faceA.materialIndex = materialIndex;\n              faceB.materialIndex = materialIndex;\n\n            }\n\n            // to get face <=> uv index correspondence\n\n            fi = geometry.faces.length;\n\n            if ( hasFaceVertexUv ) {\n\n              for ( i = 0; i < nUvLayers; i ++ ) {\n\n                uvLayer = json.uvs[ i ];\n\n                geometry.faceVertexUvs[ i ][ fi ] = [];\n                geometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n                for ( j = 0; j < 4; j ++ ) {\n\n                  uvIndex = faces[ offset ++ ];\n\n                  u = uvLayer[ uvIndex * 2 ];\n                  v = uvLayer[ uvIndex * 2 + 1 ];\n\n                  uv = new Vector2( u, v );\n\n                  if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n                  if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n                }\n\n              }\n\n            }\n\n            if ( hasFaceNormal ) {\n\n              normalIndex = faces[ offset ++ ] * 3;\n\n              faceA.normal.set(\n                normals[ normalIndex ++ ],\n                normals[ normalIndex ++ ],\n                normals[ normalIndex ]\n              );\n\n              faceB.normal.copy( faceA.normal );\n\n            }\n\n            if ( hasFaceVertexNormal ) {\n\n              for ( i = 0; i < 4; i ++ ) {\n\n                normalIndex = faces[ offset ++ ] * 3;\n\n                normal = new Vector3(\n                  normals[ normalIndex ++ ],\n                  normals[ normalIndex ++ ],\n                  normals[ normalIndex ]\n                );\n\n\n                if ( i !== 2 ) faceA.vertexNormals.push( normal );\n                if ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n              }\n\n            }\n\n\n            if ( hasFaceColor ) {\n\n              colorIndex = faces[ offset ++ ];\n              hex = colors[ colorIndex ];\n\n              faceA.color.setHex( hex );\n              faceB.color.setHex( hex );\n\n            }\n\n\n            if ( hasFaceVertexColor ) {\n\n              for ( i = 0; i < 4; i ++ ) {\n\n                colorIndex = faces[ offset ++ ];\n                hex = colors[ colorIndex ];\n\n                if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\n                if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\n\n              }\n\n            }\n\n            geometry.faces.push( faceA );\n            geometry.faces.push( faceB );\n\n          } else {\n\n            face = new Face3();\n            face.a = faces[ offset ++ ];\n            face.b = faces[ offset ++ ];\n            face.c = faces[ offset ++ ];\n\n            if ( hasMaterial ) {\n\n              materialIndex = faces[ offset ++ ];\n              face.materialIndex = materialIndex;\n\n            }\n\n            // to get face <=> uv index correspondence\n\n            fi = geometry.faces.length;\n\n            if ( hasFaceVertexUv ) {\n\n              for ( i = 0; i < nUvLayers; i ++ ) {\n\n                uvLayer = json.uvs[ i ];\n\n                geometry.faceVertexUvs[ i ][ fi ] = [];\n\n                for ( j = 0; j < 3; j ++ ) {\n\n                  uvIndex = faces[ offset ++ ];\n\n                  u = uvLayer[ uvIndex * 2 ];\n                  v = uvLayer[ uvIndex * 2 + 1 ];\n\n                  uv = new Vector2( u, v );\n\n                  geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n                }\n\n              }\n\n            }\n\n            if ( hasFaceNormal ) {\n\n              normalIndex = faces[ offset ++ ] * 3;\n\n              face.normal.set(\n                normals[ normalIndex ++ ],\n                normals[ normalIndex ++ ],\n                normals[ normalIndex ]\n              );\n\n            }\n\n            if ( hasFaceVertexNormal ) {\n\n              for ( i = 0; i < 3; i ++ ) {\n\n                normalIndex = faces[ offset ++ ] * 3;\n\n                normal = new Vector3(\n                  normals[ normalIndex ++ ],\n                  normals[ normalIndex ++ ],\n                  normals[ normalIndex ]\n                );\n\n                face.vertexNormals.push( normal );\n\n              }\n\n            }\n\n\n            if ( hasFaceColor ) {\n\n              colorIndex = faces[ offset ++ ];\n              face.color.setHex( colors[ colorIndex ] );\n\n            }\n\n\n            if ( hasFaceVertexColor ) {\n\n              for ( i = 0; i < 3; i ++ ) {\n\n                colorIndex = faces[ offset ++ ];\n                face.vertexColors.push( new Color( colors[ colorIndex ] ) );\n\n              }\n\n            }\n\n            geometry.faces.push( face );\n\n          }\n\n        }\n\n      }\n\n      function parseSkin() {\n\n        var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n        if ( json.skinWeights ) {\n\n          for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n            var x =                               json.skinWeights[ i ];\n            var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n            var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n            var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n            geometry.skinWeights.push( new Vector4( x, y, z, w ) );\n\n          }\n\n        }\n\n        if ( json.skinIndices ) {\n\n          for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n            var a =                               json.skinIndices[ i ];\n            var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n            var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n            var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n            geometry.skinIndices.push( new Vector4( a, b, c, d ) );\n\n          }\n\n        }\n\n        geometry.bones = json.bones;\n\n        if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n          console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n            geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n        }\n\n      }\n\n      function parseMorphing( scale ) {\n\n        if ( json.morphTargets !== undefined ) {\n\n          for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n            geometry.morphTargets[ i ] = {};\n            geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n            geometry.morphTargets[ i ].vertices = [];\n\n            var dstVertices = geometry.morphTargets[ i ].vertices;\n            var srcVertices = json.morphTargets[ i ].vertices;\n\n            for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n              var vertex = new Vector3();\n              vertex.x = srcVertices[ v ] * scale;\n              vertex.y = srcVertices[ v + 1 ] * scale;\n              vertex.z = srcVertices[ v + 2 ] * scale;\n\n              dstVertices.push( vertex );\n\n            }\n\n          }\n\n        }\n\n        if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n          console.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n          var faces = geometry.faces;\n          var morphColors = json.morphColors[ 0 ].colors;\n\n          for ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n            faces[ i ].color.fromArray( morphColors, i * 3 );\n\n          }\n\n        }\n\n      }\n\n      function parseAnimations() {\n\n        var outputAnimations = [];\n\n        // parse old style Bone/Hierarchy animations\n        var animations = [];\n\n        if ( json.animation !== undefined ) {\n\n          animations.push( json.animation );\n\n        }\n\n        if ( json.animations !== undefined ) {\n\n          if ( json.animations.length ) {\n\n            animations = animations.concat( json.animations );\n\n          } else {\n\n            animations.push( json.animations );\n\n          }\n\n        }\n\n        for ( var i = 0; i < animations.length; i ++ ) {\n\n          var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n          if ( clip ) outputAnimations.push( clip );\n\n        }\n\n        // parse implicit morph animations\n        if ( geometry.morphTargets ) {\n\n          // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n          var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n          outputAnimations = outputAnimations.concat( morphAnimationClips );\n\n        }\n\n        if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n      }\n\n      if ( json.materials === undefined || json.materials.length === 0 ) {\n\n        return { geometry: geometry };\n\n      } else {\n\n        var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n        return { geometry: geometry, materials: materials };\n\n      }\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function ObjectLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n    this.texturePath = '';\n\n  }\n\n  Object.assign( ObjectLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      if ( this.texturePath === '' ) {\n\n        this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n      }\n\n      var scope = this;\n\n      var loader = new FileLoader( scope.manager );\n      loader.load( url, function ( text ) {\n\n        var json = null;\n\n        try {\n\n          json = JSON.parse( text );\n\n        } catch ( error ) {\n\n          if ( onError !== undefined ) onError( error );\n\n          console.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n          return;\n\n        }\n\n        var metadata = json.metadata;\n\n        if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n          console.error( 'THREE.ObjectLoader: Can\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\n          return;\n\n        }\n\n        scope.parse( json, onLoad );\n\n      }, onProgress, onError );\n\n    },\n\n    setTexturePath: function ( value ) {\n\n      this.texturePath = value;\n\n    },\n\n    setCrossOrigin: function ( value ) {\n\n      this.crossOrigin = value;\n\n    },\n\n    parse: function ( json, onLoad ) {\n\n      var geometries = this.parseGeometries( json.geometries );\n\n      var images = this.parseImages( json.images, function () {\n\n        if ( onLoad !== undefined ) onLoad( object );\n\n      } );\n\n      var textures = this.parseTextures( json.textures, images );\n      var materials = this.parseMaterials( json.materials, textures );\n\n      var object = this.parseObject( json.object, geometries, materials );\n\n      if ( json.animations ) {\n\n        object.animations = this.parseAnimations( json.animations );\n\n      }\n\n      if ( json.images === undefined || json.images.length === 0 ) {\n\n        if ( onLoad !== undefined ) onLoad( object );\n\n      }\n\n      return object;\n\n    },\n\n    parseGeometries: function ( json ) {\n\n      var geometries = {};\n\n      if ( json !== undefined ) {\n\n        var geometryLoader = new JSONLoader();\n        var bufferGeometryLoader = new BufferGeometryLoader();\n\n        for ( var i = 0, l = json.length; i < l; i ++ ) {\n\n          var geometry;\n          var data = json[ i ];\n\n          switch ( data.type ) {\n\n            case 'PlaneGeometry':\n            case 'PlaneBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.width,\n                data.height,\n                data.widthSegments,\n                data.heightSegments\n              );\n\n              break;\n\n            case 'BoxGeometry':\n            case 'BoxBufferGeometry':\n            case 'CubeGeometry': // backwards compatible\n\n              geometry = new Geometries[ data.type ](\n                data.width,\n                data.height,\n                data.depth,\n                data.widthSegments,\n                data.heightSegments,\n                data.depthSegments\n              );\n\n              break;\n\n            case 'CircleGeometry':\n            case 'CircleBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.segments,\n                data.thetaStart,\n                data.thetaLength\n              );\n\n              break;\n\n            case 'CylinderGeometry':\n            case 'CylinderBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radiusTop,\n                data.radiusBottom,\n                data.height,\n                data.radialSegments,\n                data.heightSegments,\n                data.openEnded,\n                data.thetaStart,\n                data.thetaLength\n              );\n\n              break;\n\n            case 'ConeGeometry':\n            case 'ConeBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.height,\n                data.radialSegments,\n                data.heightSegments,\n                data.openEnded,\n                data.thetaStart,\n                data.thetaLength\n              );\n\n              break;\n\n            case 'SphereGeometry':\n            case 'SphereBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.widthSegments,\n                data.heightSegments,\n                data.phiStart,\n                data.phiLength,\n                data.thetaStart,\n                data.thetaLength\n              );\n\n              break;\n\n            case 'DodecahedronGeometry':\n            case 'IcosahedronGeometry':\n            case 'OctahedronGeometry':\n            case 'TetrahedronGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.detail\n              );\n\n              break;\n\n            case 'RingGeometry':\n            case 'RingBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.innerRadius,\n                data.outerRadius,\n                data.thetaSegments,\n                data.phiSegments,\n                data.thetaStart,\n                data.thetaLength\n              );\n\n              break;\n\n            case 'TorusGeometry':\n            case 'TorusBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.tube,\n                data.radialSegments,\n                data.tubularSegments,\n                data.arc\n              );\n\n              break;\n\n            case 'TorusKnotGeometry':\n            case 'TorusKnotBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.radius,\n                data.tube,\n                data.tubularSegments,\n                data.radialSegments,\n                data.p,\n                data.q\n              );\n\n              break;\n\n            case 'LatheGeometry':\n            case 'LatheBufferGeometry':\n\n              geometry = new Geometries[ data.type ](\n                data.points,\n                data.segments,\n                data.phiStart,\n                data.phiLength\n              );\n\n              break;\n\n            case 'BufferGeometry':\n\n              geometry = bufferGeometryLoader.parse( data );\n\n              break;\n\n            case 'Geometry':\n\n              geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n              break;\n\n            default:\n\n              console.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n              continue;\n\n          }\n\n          geometry.uuid = data.uuid;\n\n          if ( data.name !== undefined ) geometry.name = data.name;\n\n          geometries[ data.uuid ] = geometry;\n\n        }\n\n      }\n\n      return geometries;\n\n    },\n\n    parseMaterials: function ( json, textures ) {\n\n      var materials = {};\n\n      if ( json !== undefined ) {\n\n        var loader = new MaterialLoader();\n        loader.setTextures( textures );\n\n        for ( var i = 0, l = json.length; i < l; i ++ ) {\n\n          var material = loader.parse( json[ i ] );\n          materials[ material.uuid ] = material;\n\n        }\n\n      }\n\n      return materials;\n\n    },\n\n    parseAnimations: function ( json ) {\n\n      var animations = [];\n\n      for ( var i = 0; i < json.length; i ++ ) {\n\n        var clip = AnimationClip.parse( json[ i ] );\n\n        animations.push( clip );\n\n      }\n\n      return animations;\n\n    },\n\n    parseImages: function ( json, onLoad ) {\n\n      var scope = this;\n      var images = {};\n\n      function loadImage( url ) {\n\n        scope.manager.itemStart( url );\n\n        return loader.load( url, function () {\n\n          scope.manager.itemEnd( url );\n\n        }, undefined, function () {\n\n          scope.manager.itemError( url );\n\n        } );\n\n      }\n\n      if ( json !== undefined && json.length > 0 ) {\n\n        var manager = new LoadingManager( onLoad );\n\n        var loader = new ImageLoader( manager );\n        loader.setCrossOrigin( this.crossOrigin );\n\n        for ( var i = 0, l = json.length; i < l; i ++ ) {\n\n          var image = json[ i ];\n          var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n          images[ image.uuid ] = loadImage( path );\n\n        }\n\n      }\n\n      return images;\n\n    },\n\n    parseTextures: function ( json, images ) {\n\n      var TextureMapping = {\n        UVMapping: UVMapping,\n        CubeReflectionMapping: CubeReflectionMapping,\n        CubeRefractionMapping: CubeRefractionMapping,\n        EquirectangularReflectionMapping: EquirectangularReflectionMapping,\n        EquirectangularRefractionMapping: EquirectangularRefractionMapping,\n        SphericalReflectionMapping: SphericalReflectionMapping,\n        CubeUVReflectionMapping: CubeUVReflectionMapping,\n        CubeUVRefractionMapping: CubeUVRefractionMapping\n      };\n\n      var TextureWrapping = {\n        RepeatWrapping: RepeatWrapping,\n        ClampToEdgeWrapping: ClampToEdgeWrapping,\n        MirroredRepeatWrapping: MirroredRepeatWrapping\n      };\n\n      var TextureFilter = {\n        NearestFilter: NearestFilter,\n        NearestMipMapNearestFilter: NearestMipMapNearestFilter,\n        NearestMipMapLinearFilter: NearestMipMapLinearFilter,\n        LinearFilter: LinearFilter,\n        LinearMipMapNearestFilter: LinearMipMapNearestFilter,\n        LinearMipMapLinearFilter: LinearMipMapLinearFilter\n      };\n\n      function parseConstant( value, type ) {\n\n        if ( typeof( value ) === 'number' ) return value;\n\n        console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n        return type[ value ];\n\n      }\n\n      var textures = {};\n\n      if ( json !== undefined ) {\n\n        for ( var i = 0, l = json.length; i < l; i ++ ) {\n\n          var data = json[ i ];\n\n          if ( data.image === undefined ) {\n\n            console.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n          }\n\n          if ( images[ data.image ] === undefined ) {\n\n            console.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n          }\n\n          var texture = new Texture( images[ data.image ] );\n          texture.needsUpdate = true;\n\n          texture.uuid = data.uuid;\n\n          if ( data.name !== undefined ) texture.name = data.name;\n\n          if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );\n\n          if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n          if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n          if ( data.wrap !== undefined ) {\n\n            texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );\n            texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );\n\n          }\n\n          if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );\n          if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );\n          if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n          if ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n          textures[ data.uuid ] = texture;\n\n        }\n\n      }\n\n      return textures;\n\n    },\n\n    parseObject: function () {\n\n      var matrix = new Matrix4();\n\n      return function parseObject( data, geometries, materials ) {\n\n        var object;\n\n        function getGeometry( name ) {\n\n          if ( geometries[ name ] === undefined ) {\n\n            console.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n          }\n\n          return geometries[ name ];\n\n        }\n\n        function getMaterial( name ) {\n\n          if ( name === undefined ) return undefined;\n\n          if ( materials[ name ] === undefined ) {\n\n            console.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n          }\n\n          return materials[ name ];\n\n        }\n\n        switch ( data.type ) {\n\n          case 'Scene':\n\n            object = new Scene();\n\n            if ( data.background !== undefined ) {\n\n              if ( Number.isInteger( data.background ) ) {\n\n                object.background = new Color( data.background );\n\n              }\n\n            }\n\n            if ( data.fog !== undefined ) {\n\n              if ( data.fog.type === 'Fog' ) {\n\n                object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n              } else if ( data.fog.type === 'FogExp2' ) {\n\n                object.fog = new FogExp2( data.fog.color, data.fog.density );\n\n              }\n\n            }\n\n            break;\n\n          case 'PerspectiveCamera':\n\n            object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n            if ( data.focus !== undefined ) object.focus = data.focus;\n            if ( data.zoom !== undefined ) object.zoom = data.zoom;\n            if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n            if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n            if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n            break;\n\n          case 'OrthographicCamera':\n\n            object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n            break;\n\n          case 'AmbientLight':\n\n            object = new AmbientLight( data.color, data.intensity );\n\n            break;\n\n          case 'DirectionalLight':\n\n            object = new DirectionalLight( data.color, data.intensity );\n\n            break;\n\n          case 'PointLight':\n\n            object = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n            break;\n\n          case 'SpotLight':\n\n            object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n            break;\n\n          case 'HemisphereLight':\n\n            object = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n            break;\n\n          case 'Mesh':\n\n            var geometry = getGeometry( data.geometry );\n            var material = getMaterial( data.material );\n\n            if ( geometry.bones && geometry.bones.length > 0 ) {\n\n              object = new SkinnedMesh( geometry, material );\n\n            } else {\n\n              object = new Mesh( geometry, material );\n\n            }\n\n            break;\n\n          case 'LOD':\n\n            object = new LOD();\n\n            break;\n\n          case 'Line':\n\n            object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n            break;\n\n          case 'LineLoop':\n\n            object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n            break;\n\n          case 'LineSegments':\n\n            object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n            break;\n\n          case 'PointCloud':\n          case 'Points':\n\n            object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n            break;\n\n          case 'Sprite':\n\n            object = new Sprite( getMaterial( data.material ) );\n\n            break;\n\n          case 'Group':\n\n            object = new Group();\n\n            break;\n\n          case 'SkinnedMesh':\n\n            console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );\n\n          default:\n\n            object = new Object3D();\n\n        }\n\n        object.uuid = data.uuid;\n\n        if ( data.name !== undefined ) object.name = data.name;\n        if ( data.matrix !== undefined ) {\n\n          matrix.fromArray( data.matrix );\n          matrix.decompose( object.position, object.quaternion, object.scale );\n\n        } else {\n\n          if ( data.position !== undefined ) object.position.fromArray( data.position );\n          if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n          if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n          if ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n        }\n\n        if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n        if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n        if ( data.shadow ) {\n\n          if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n          if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n          if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n          if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n        }\n\n        if ( data.visible !== undefined ) object.visible = data.visible;\n        if ( data.userData !== undefined ) object.userData = data.userData;\n\n        if ( data.children !== undefined ) {\n\n          for ( var child in data.children ) {\n\n            object.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n          }\n\n        }\n\n        if ( data.type === 'LOD' ) {\n\n          var levels = data.levels;\n\n          for ( var l = 0; l < levels.length; l ++ ) {\n\n            var level = levels[ l ];\n            var child = object.getObjectByProperty( 'uuid', level.object );\n\n            if ( child !== undefined ) {\n\n              object.addLevel( child, level.distance );\n\n            }\n\n          }\n\n        }\n\n        return object;\n\n      };\n\n    }()\n\n  } );\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   *\n   * Bezier Curves formulas obtained from\n   * http://en.wikipedia.org/wiki/Bzier_curve\n   */\n\n  function CatmullRom( t, p0, p1, p2, p3 ) {\n\n    var v0 = ( p2 - p0 ) * 0.5;\n    var v1 = ( p3 - p1 ) * 0.5;\n    var t2 = t * t;\n    var t3 = t * t2;\n    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n  }\n\n  //\n\n  function QuadraticBezierP0( t, p ) {\n\n    var k = 1 - t;\n    return k * k * p;\n\n  }\n\n  function QuadraticBezierP1( t, p ) {\n\n    return 2 * ( 1 - t ) * t * p;\n\n  }\n\n  function QuadraticBezierP2( t, p ) {\n\n    return t * t * p;\n\n  }\n\n  function QuadraticBezier( t, p0, p1, p2 ) {\n\n    return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n      QuadraticBezierP2( t, p2 );\n\n  }\n\n  //\n\n  function CubicBezierP0( t, p ) {\n\n    var k = 1 - t;\n    return k * k * k * p;\n\n  }\n\n  function CubicBezierP1( t, p ) {\n\n    var k = 1 - t;\n    return 3 * k * k * t * p;\n\n  }\n\n  function CubicBezierP2( t, p ) {\n\n    return 3 * ( 1 - t ) * t * t * p;\n\n  }\n\n  function CubicBezierP3( t, p ) {\n\n    return t * t * t * p;\n\n  }\n\n  function CubicBezier( t, p0, p1, p2, p3 ) {\n\n    return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n      CubicBezierP3( t, p3 );\n\n  }\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * Extensible curve object\n   *\n   * Some common of Curve methods\n   * .getPoint(t), getTangent(t)\n   * .getPointAt(u), getTangentAt(u)\n   * .getPoints(), .getSpacedPoints()\n   * .getLength()\n   * .updateArcLengths()\n   *\n   * This following classes subclasses THREE.Curve:\n   *\n   * -- 2d classes --\n   * THREE.LineCurve\n   * THREE.QuadraticBezierCurve\n   * THREE.CubicBezierCurve\n   * THREE.SplineCurve\n   * THREE.ArcCurve\n   * THREE.EllipseCurve\n   *\n   * -- 3d classes --\n   * THREE.LineCurve3\n   * THREE.QuadraticBezierCurve3\n   * THREE.CubicBezierCurve3\n   * THREE.CatmullRomCurve3\n   *\n   * A series of curves can be represented as a THREE.CurvePath\n   *\n   **/\n\n  /**************************************************************\n   *  Abstract Curve base class\n   **************************************************************/\n\n  function Curve() {}\n\n  Object.assign( Curve.prototype, {\n\n    // Virtual base class method to overwrite and implement in subclasses\n    //  - t [0 .. 1]\n\n    getPoint: function () {\n\n      console.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n      return null;\n\n    },\n\n    // Get point at relative position in curve according to arc length\n    // - u [0 .. 1]\n\n    getPointAt: function ( u ) {\n\n      var t = this.getUtoTmapping( u );\n      return this.getPoint( t );\n\n    },\n\n    // Get sequence of points using getPoint( t )\n\n    getPoints: function ( divisions ) {\n\n      if ( divisions === undefined ) divisions = 5;\n\n      var points = [];\n\n      for ( var d = 0; d <= divisions; d ++ ) {\n\n        points.push( this.getPoint( d / divisions ) );\n\n      }\n\n      return points;\n\n    },\n\n    // Get sequence of points using getPointAt( u )\n\n    getSpacedPoints: function ( divisions ) {\n\n      if ( divisions === undefined ) divisions = 5;\n\n      var points = [];\n\n      for ( var d = 0; d <= divisions; d ++ ) {\n\n        points.push( this.getPointAt( d / divisions ) );\n\n      }\n\n      return points;\n\n    },\n\n    // Get total curve arc length\n\n    getLength: function () {\n\n      var lengths = this.getLengths();\n      return lengths[ lengths.length - 1 ];\n\n    },\n\n    // Get list of cumulative segment lengths\n\n    getLengths: function ( divisions ) {\n\n      if ( divisions === undefined ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n      if ( this.cacheArcLengths\n        && ( this.cacheArcLengths.length === divisions + 1 )\n        && ! this.needsUpdate ) {\n\n        //console.log( \"cached\", this.cacheArcLengths );\n        return this.cacheArcLengths;\n\n      }\n\n      this.needsUpdate = false;\n\n      var cache = [];\n      var current, last = this.getPoint( 0 );\n      var p, sum = 0;\n\n      cache.push( 0 );\n\n      for ( p = 1; p <= divisions; p ++ ) {\n\n        current = this.getPoint( p / divisions );\n        sum += current.distanceTo( last );\n        cache.push( sum );\n        last = current;\n\n      }\n\n      this.cacheArcLengths = cache;\n\n      return cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n    },\n\n    updateArcLengths: function () {\n\n      this.needsUpdate = true;\n      this.getLengths();\n\n    },\n\n    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n    getUtoTmapping: function ( u, distance ) {\n\n      var arcLengths = this.getLengths();\n\n      var i = 0, il = arcLengths.length;\n\n      var targetArcLength; // The targeted u distance value to get\n\n      if ( distance ) {\n\n        targetArcLength = distance;\n\n      } else {\n\n        targetArcLength = u * arcLengths[ il - 1 ];\n\n      }\n\n      //var time = Date.now();\n\n      // binary search for the index with largest value smaller than target u distance\n\n      var low = 0, high = il - 1, comparison;\n\n      while ( low <= high ) {\n\n        i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n        comparison = arcLengths[ i ] - targetArcLength;\n\n        if ( comparison < 0 ) {\n\n          low = i + 1;\n\n        } else if ( comparison > 0 ) {\n\n          high = i - 1;\n\n        } else {\n\n          high = i;\n          break;\n\n          // DONE\n\n        }\n\n      }\n\n      i = high;\n\n      //console.log('b' , i, low, high, Date.now()- time);\n\n      if ( arcLengths[ i ] === targetArcLength ) {\n\n        var t = i / ( il - 1 );\n        return t;\n\n      }\n\n      // we could get finer grain at lengths, or use simple interpolation between two points\n\n      var lengthBefore = arcLengths[ i ];\n      var lengthAfter = arcLengths[ i + 1 ];\n\n      var segmentLength = lengthAfter - lengthBefore;\n\n      // determine where we are between the 'before' and 'after' points\n\n      var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n      // add that fractional amount to t\n\n      var t = ( i + segmentFraction ) / ( il - 1 );\n\n      return t;\n\n    },\n\n    // Returns a unit vector tangent at t\n    // In case any sub curve does not implement its tangent derivation,\n    // 2 points a small delta apart will be used to find its gradient\n    // which seems to give a reasonable approximation\n\n    getTangent: function ( t ) {\n\n      var delta = 0.0001;\n      var t1 = t - delta;\n      var t2 = t + delta;\n\n      // Capping in case of danger\n\n      if ( t1 < 0 ) t1 = 0;\n      if ( t2 > 1 ) t2 = 1;\n\n      var pt1 = this.getPoint( t1 );\n      var pt2 = this.getPoint( t2 );\n\n      var vec = pt2.clone().sub( pt1 );\n      return vec.normalize();\n\n    },\n\n    getTangentAt: function ( u ) {\n\n      var t = this.getUtoTmapping( u );\n      return this.getTangent( t );\n\n    },\n\n    computeFrenetFrames: function ( segments, closed ) {\n\n      // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n      var normal = new Vector3();\n\n      var tangents = [];\n      var normals = [];\n      var binormals = [];\n\n      var vec = new Vector3();\n      var mat = new Matrix4();\n\n      var i, u, theta;\n\n      // compute the tangent vectors for each segment on the curve\n\n      for ( i = 0; i <= segments; i ++ ) {\n\n        u = i / segments;\n\n        tangents[ i ] = this.getTangentAt( u );\n        tangents[ i ].normalize();\n\n      }\n\n      // select an initial normal vector perpendicular to the first tangent vector,\n      // and in the direction of the minimum tangent xyz component\n\n      normals[ 0 ] = new Vector3();\n      binormals[ 0 ] = new Vector3();\n      var min = Number.MAX_VALUE;\n      var tx = Math.abs( tangents[ 0 ].x );\n      var ty = Math.abs( tangents[ 0 ].y );\n      var tz = Math.abs( tangents[ 0 ].z );\n\n      if ( tx <= min ) {\n\n        min = tx;\n        normal.set( 1, 0, 0 );\n\n      }\n\n      if ( ty <= min ) {\n\n        min = ty;\n        normal.set( 0, 1, 0 );\n\n      }\n\n      if ( tz <= min ) {\n\n        normal.set( 0, 0, 1 );\n\n      }\n\n      vec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n      normals[ 0 ].crossVectors( tangents[ 0 ], vec );\n      binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n      // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n      for ( i = 1; i <= segments; i ++ ) {\n\n        normals[ i ] = normals[ i - 1 ].clone();\n\n        binormals[ i ] = binormals[ i - 1 ].clone();\n\n        vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n        if ( vec.length() > Number.EPSILON ) {\n\n          vec.normalize();\n\n          theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n          normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n        }\n\n        binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n      }\n\n      // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n      if ( closed === true ) {\n\n        theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n        theta /= segments;\n\n        if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n          theta = - theta;\n\n        }\n\n        for ( i = 1; i <= segments; i ++ ) {\n\n          // twist a little...\n          normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n          binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n        }\n\n      }\n\n      return {\n        tangents: tangents,\n        normals: normals,\n        binormals: binormals\n      };\n\n    }\n\n  } );\n\n  function LineCurve( v1, v2 ) {\n\n    this.v1 = v1;\n    this.v2 = v2;\n\n  }\n\n  LineCurve.prototype = Object.create( Curve.prototype );\n  LineCurve.prototype.constructor = LineCurve;\n\n  LineCurve.prototype.isLineCurve = true;\n\n  LineCurve.prototype.getPoint = function ( t ) {\n\n    if ( t === 1 ) {\n\n      return this.v2.clone();\n\n    }\n\n    var point = this.v2.clone().sub( this.v1 );\n    point.multiplyScalar( t ).add( this.v1 );\n\n    return point;\n\n  };\n\n  // Line curve is linear, so we can overwrite default getPointAt\n\n  LineCurve.prototype.getPointAt = function ( u ) {\n\n    return this.getPoint( u );\n\n  };\n\n  LineCurve.prototype.getTangent = function ( t ) {\n\n    var tangent = this.v2.clone().sub( this.v1 );\n\n    return tangent.normalize();\n\n  };\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   *\n   **/\n\n  /**************************************************************\n   *  Curved Path - a curve path is simply a array of connected\n   *  curves, but retains the api of a curve\n   **************************************************************/\n\n  function CurvePath() {\n\n    this.curves = [];\n\n    this.autoClose = false; // Automatically closes the path\n\n  }\n\n  CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\n\n    constructor: CurvePath,\n\n    add: function ( curve ) {\n\n      this.curves.push( curve );\n\n    },\n\n    closePath: function () {\n\n      // Add a line curve if start and end of lines are not connected\n      var startPoint = this.curves[ 0 ].getPoint( 0 );\n      var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n      if ( ! startPoint.equals( endPoint ) ) {\n\n        this.curves.push( new LineCurve( endPoint, startPoint ) );\n\n      }\n\n    },\n\n    // To get accurate point with reference to\n    // entire path distance at time t,\n    // following has to be done:\n\n    // 1. Length of each sub path have to be known\n    // 2. Locate and identify type of curve\n    // 3. Get t for the curve\n    // 4. Return curve.getPointAt(t')\n\n    getPoint: function ( t ) {\n\n      var d = t * this.getLength();\n      var curveLengths = this.getCurveLengths();\n      var i = 0;\n\n      // To think about boundaries points.\n\n      while ( i < curveLengths.length ) {\n\n        if ( curveLengths[ i ] >= d ) {\n\n          var diff = curveLengths[ i ] - d;\n          var curve = this.curves[ i ];\n\n          var segmentLength = curve.getLength();\n          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n          return curve.getPointAt( u );\n\n        }\n\n        i ++;\n\n      }\n\n      return null;\n\n      // loop where sum != 0, sum > d , sum+1 <d\n\n    },\n\n    // We cannot use the default THREE.Curve getPoint() with getLength() because in\n    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n    // getPoint() depends on getLength\n\n    getLength: function () {\n\n      var lens = this.getCurveLengths();\n      return lens[ lens.length - 1 ];\n\n    },\n\n    // cacheLengths must be recalculated.\n    updateArcLengths: function () {\n\n      this.needsUpdate = true;\n      this.cacheLengths = null;\n      this.getLengths();\n\n    },\n\n    // Compute lengths and cache them\n    // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n    getCurveLengths: function () {\n\n      // We use cache values if curves and cache array are same length\n\n      if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n        return this.cacheLengths;\n\n      }\n\n      // Get length of sub-curve\n      // Push sums into cached array\n\n      var lengths = [], sums = 0;\n\n      for ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n        sums += this.curves[ i ].getLength();\n        lengths.push( sums );\n\n      }\n\n      this.cacheLengths = lengths;\n\n      return lengths;\n\n    },\n\n    getSpacedPoints: function ( divisions ) {\n\n      if ( divisions === undefined ) divisions = 40;\n\n      var points = [];\n\n      for ( var i = 0; i <= divisions; i ++ ) {\n\n        points.push( this.getPoint( i / divisions ) );\n\n      }\n\n      if ( this.autoClose ) {\n\n        points.push( points[ 0 ] );\n\n      }\n\n      return points;\n\n    },\n\n    getPoints: function ( divisions ) {\n\n      divisions = divisions || 12;\n\n      var points = [], last;\n\n      for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n        var curve = curves[ i ];\n        var resolution = (curve && curve.isEllipseCurve) ? divisions * 2\n          : (curve && curve.isLineCurve) ? 1\n          : (curve && curve.isSplineCurve) ? divisions * curve.points.length\n          : divisions;\n\n        var pts = curve.getPoints( resolution );\n\n        for ( var j = 0; j < pts.length; j++ ) {\n\n          var point = pts[ j ];\n\n          if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n          points.push( point );\n          last = point;\n\n        }\n\n      }\n\n      if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n        points.push( points[ 0 ] );\n\n      }\n\n      return points;\n\n    },\n\n    /**************************************************************\n     *  Create Geometries Helpers\n     **************************************************************/\n\n    /// Generate geometry from path points (for Line or Points objects)\n\n    createPointsGeometry: function ( divisions ) {\n\n      var pts = this.getPoints( divisions );\n      return this.createGeometry( pts );\n\n    },\n\n    // Generate geometry from equidistant sampling along the path\n\n    createSpacedPointsGeometry: function ( divisions ) {\n\n      var pts = this.getSpacedPoints( divisions );\n      return this.createGeometry( pts );\n\n    },\n\n    createGeometry: function ( points ) {\n\n      var geometry = new Geometry();\n\n      for ( var i = 0, l = points.length; i < l; i ++ ) {\n\n        var point = points[ i ];\n        geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n      }\n\n      return geometry;\n\n    }\n\n  } );\n\n  function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n    this.aX = aX;\n    this.aY = aY;\n\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n\n    this.aClockwise = aClockwise;\n\n    this.aRotation = aRotation || 0;\n\n  }\n\n  EllipseCurve.prototype = Object.create( Curve.prototype );\n  EllipseCurve.prototype.constructor = EllipseCurve;\n\n  EllipseCurve.prototype.isEllipseCurve = true;\n\n  EllipseCurve.prototype.getPoint = function ( t ) {\n\n    var twoPi = Math.PI * 2;\n    var deltaAngle = this.aEndAngle - this.aStartAngle;\n    var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n    // ensures that deltaAngle is 0 .. 2 PI\n    while ( deltaAngle < 0 ) deltaAngle += twoPi;\n    while ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n    if ( deltaAngle < Number.EPSILON ) {\n\n      if ( samePoints ) {\n\n        deltaAngle = 0;\n\n      } else {\n\n        deltaAngle = twoPi;\n\n      }\n\n    }\n\n    if ( this.aClockwise === true && ! samePoints ) {\n\n      if ( deltaAngle === twoPi ) {\n\n        deltaAngle = - twoPi;\n\n      } else {\n\n        deltaAngle = deltaAngle - twoPi;\n\n      }\n\n    }\n\n    var angle = this.aStartAngle + t * deltaAngle;\n    var x = this.aX + this.xRadius * Math.cos( angle );\n    var y = this.aY + this.yRadius * Math.sin( angle );\n\n    if ( this.aRotation !== 0 ) {\n\n      var cos = Math.cos( this.aRotation );\n      var sin = Math.sin( this.aRotation );\n\n      var tx = x - this.aX;\n      var ty = y - this.aY;\n\n      // Rotate the point about the center of the ellipse.\n      x = tx * cos - ty * sin + this.aX;\n      y = tx * sin + ty * cos + this.aY;\n\n    }\n\n    return new Vector2( x, y );\n\n  };\n\n  function SplineCurve( points /* array of Vector2 */ ) {\n\n    this.points = ( points === undefined ) ? [] : points;\n\n  }\n\n  SplineCurve.prototype = Object.create( Curve.prototype );\n  SplineCurve.prototype.constructor = SplineCurve;\n\n  SplineCurve.prototype.isSplineCurve = true;\n\n  SplineCurve.prototype.getPoint = function ( t ) {\n\n    var points = this.points;\n    var point = ( points.length - 1 ) * t;\n\n    var intPoint = Math.floor( point );\n    var weight = point - intPoint;\n\n    var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n    var point1 = points[ intPoint ];\n    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n    return new Vector2(\n      CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),\n      CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )\n    );\n\n  };\n\n  function CubicBezierCurve( v0, v1, v2, v3 ) {\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n\n  }\n\n  CubicBezierCurve.prototype = Object.create( Curve.prototype );\n  CubicBezierCurve.prototype.constructor = CubicBezierCurve;\n\n  CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n    return new Vector2(\n      CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n      CubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n    );\n\n  };\n\n  function QuadraticBezierCurve( v0, v1, v2 ) {\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n\n  }\n\n  QuadraticBezierCurve.prototype = Object.create( Curve.prototype );\n  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\n\n  QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n    return new Vector2(\n      QuadraticBezier( t, v0.x, v1.x, v2.x ),\n      QuadraticBezier( t, v0.y, v1.y, v2.y )\n    );\n\n  };\n\n  var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {\n\n    fromPoints: function ( vectors ) {\n\n      this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n      for ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n        this.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n      }\n\n    },\n\n    moveTo: function ( x, y ) {\n\n      this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n    },\n\n    lineTo: function ( x, y ) {\n\n      var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n      this.curves.push( curve );\n\n      this.currentPoint.set( x, y );\n\n    },\n\n    quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n      var curve = new QuadraticBezierCurve(\n        this.currentPoint.clone(),\n        new Vector2( aCPx, aCPy ),\n        new Vector2( aX, aY )\n      );\n\n      this.curves.push( curve );\n\n      this.currentPoint.set( aX, aY );\n\n    },\n\n    bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n      var curve = new CubicBezierCurve(\n        this.currentPoint.clone(),\n        new Vector2( aCP1x, aCP1y ),\n        new Vector2( aCP2x, aCP2y ),\n        new Vector2( aX, aY )\n      );\n\n      this.curves.push( curve );\n\n      this.currentPoint.set( aX, aY );\n\n    },\n\n    splineThru: function ( pts /*Array of Vector*/ ) {\n\n      var npts = [ this.currentPoint.clone() ].concat( pts );\n\n      var curve = new SplineCurve( npts );\n      this.curves.push( curve );\n\n      this.currentPoint.copy( pts[ pts.length - 1 ] );\n\n    },\n\n    arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n\n      this.absarc( aX + x0, aY + y0, aRadius,\n        aStartAngle, aEndAngle, aClockwise );\n\n    },\n\n    absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n      this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n    },\n\n    ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n\n      this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n    },\n\n    absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n      var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n      if ( this.curves.length > 0 ) {\n\n        // if a previous curve is present, attempt to join\n        var firstPoint = curve.getPoint( 0 );\n\n        if ( ! firstPoint.equals( this.currentPoint ) ) {\n\n          this.lineTo( firstPoint.x, firstPoint.y );\n\n        }\n\n      }\n\n      this.curves.push( curve );\n\n      var lastPoint = curve.getPoint( 1 );\n      this.currentPoint.copy( lastPoint );\n\n    }\n\n  } );\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * Creates free form 2d path using series of points, lines or curves.\n   **/\n\n  function Path( points ) {\n\n    CurvePath.call( this );\n    this.currentPoint = new Vector2();\n\n    if ( points ) {\n\n      this.fromPoints( points );\n\n    }\n\n  }\n\n  Path.prototype = PathPrototype;\n  PathPrototype.constructor = Path;\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * Defines a 2d shape plane using paths.\n   **/\n\n  // STEP 1 Create a path.\n  // STEP 2 Turn path into shape.\n  // STEP 3 ExtrudeGeometry takes in Shape/Shapes\n  // STEP 3a - Extract points from each shape, turn to vertices\n  // STEP 3b - Triangulate each shape, add faces.\n\n  function Shape() {\n\n    Path.apply( this, arguments );\n\n    this.holes = [];\n\n  }\n\n  Shape.prototype = Object.assign( Object.create( PathPrototype ), {\n\n    constructor: Shape,\n\n    getPointsHoles: function ( divisions ) {\n\n      var holesPts = [];\n\n      for ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n        holesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n      }\n\n      return holesPts;\n\n    },\n\n    // Get points of shape and holes (keypoints based on segments parameter)\n\n    extractAllPoints: function ( divisions ) {\n\n      return {\n\n        shape: this.getPoints( divisions ),\n        holes: this.getPointsHoles( divisions )\n\n      };\n\n    },\n\n    extractPoints: function ( divisions ) {\n\n      return this.extractAllPoints( divisions );\n\n    }\n\n  } );\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n   **/\n\n  function ShapePath() {\n\n    this.subPaths = [];\n    this.currentPath = null;\n\n  }\n\n  Object.assign( ShapePath.prototype, {\n\n    moveTo: function ( x, y ) {\n\n      this.currentPath = new Path();\n      this.subPaths.push( this.currentPath );\n      this.currentPath.moveTo( x, y );\n\n    },\n\n    lineTo: function ( x, y ) {\n\n      this.currentPath.lineTo( x, y );\n\n    },\n\n    quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n      this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n    },\n\n    bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n      this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n    },\n\n    splineThru: function ( pts ) {\n\n      this.currentPath.splineThru( pts );\n\n    },\n\n    toShapes: function ( isCCW, noHoles ) {\n\n      function toShapesNoHoles( inSubpaths ) {\n\n        var shapes = [];\n\n        for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n          var tmpPath = inSubpaths[ i ];\n\n          var tmpShape = new Shape();\n          tmpShape.curves = tmpPath.curves;\n\n          shapes.push( tmpShape );\n\n        }\n\n        return shapes;\n\n      }\n\n      function isPointInsidePolygon( inPt, inPolygon ) {\n\n        var polyLen = inPolygon.length;\n\n        // inPt on polygon contour => immediate success    or\n        // toggling of inside/outside at every single! intersection point of an edge\n        //  with the horizontal line through inPt, left of inPt\n        //  not counting lowerY endpoints of edges and whole edges on that line\n        var inside = false;\n        for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n          var edgeLowPt  = inPolygon[ p ];\n          var edgeHighPt = inPolygon[ q ];\n\n          var edgeDx = edgeHighPt.x - edgeLowPt.x;\n          var edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n          if ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n            // not parallel\n            if ( edgeDy < 0 ) {\n\n              edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n              edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n            }\n            if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;\n\n            if ( inPt.y === edgeLowPt.y ) {\n\n              if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?\n              // continue;        // no intersection or edgeLowPt => doesn't count !!!\n\n            } else {\n\n              var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n              if ( perpEdge === 0 )       return  true;   // inPt is on contour ?\n              if ( perpEdge < 0 )         continue;\n              inside = ! inside;    // true intersection left of inPt\n\n            }\n\n          } else {\n\n            // parallel or collinear\n            if ( inPt.y !== edgeLowPt.y )     continue;     // parallel\n            // edge lies on the same horizontal line as inPt\n            if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n               ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !\n            // continue;\n\n          }\n\n        }\n\n        return  inside;\n\n      }\n\n      var isClockWise = ShapeUtils.isClockWise;\n\n      var subPaths = this.subPaths;\n      if ( subPaths.length === 0 ) return [];\n\n      if ( noHoles === true ) return  toShapesNoHoles( subPaths );\n\n\n      var solid, tmpPath, tmpShape, shapes = [];\n\n      if ( subPaths.length === 1 ) {\n\n        tmpPath = subPaths[ 0 ];\n        tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push( tmpShape );\n        return shapes;\n\n      }\n\n      var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n      holesFirst = isCCW ? ! holesFirst : holesFirst;\n\n      // console.log(\"Holes first\", holesFirst);\n\n      var betterShapeHoles = [];\n      var newShapes = [];\n      var newShapeHoles = [];\n      var mainIdx = 0;\n      var tmpPoints;\n\n      newShapes[ mainIdx ] = undefined;\n      newShapeHoles[ mainIdx ] = [];\n\n      for ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n        tmpPath = subPaths[ i ];\n        tmpPoints = tmpPath.getPoints();\n        solid = isClockWise( tmpPoints );\n        solid = isCCW ? ! solid : solid;\n\n        if ( solid ) {\n\n          if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx ++;\n\n          newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n          newShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n          if ( holesFirst ) mainIdx ++;\n          newShapeHoles[ mainIdx ] = [];\n\n          //console.log('cw', i);\n\n        } else {\n\n          newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n          //console.log('ccw', i);\n\n        }\n\n      }\n\n      // only Holes? -> probably all Shapes with wrong orientation\n      if ( ! newShapes[ 0 ] ) return  toShapesNoHoles( subPaths );\n\n\n      if ( newShapes.length > 1 ) {\n\n        var ambiguous = false;\n        var toChange = [];\n\n        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n          betterShapeHoles[ sIdx ] = [];\n\n        }\n\n        for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n          var sho = newShapeHoles[ sIdx ];\n\n          for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n            var ho = sho[ hIdx ];\n            var hole_unassigned = true;\n\n            for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n              if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n                if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n                if ( hole_unassigned ) {\n\n                  hole_unassigned = false;\n                  betterShapeHoles[ s2Idx ].push( ho );\n\n                } else {\n\n                  ambiguous = true;\n\n                }\n\n              }\n\n            }\n            if ( hole_unassigned ) {\n\n              betterShapeHoles[ sIdx ].push( ho );\n\n            }\n\n          }\n\n        }\n        // console.log(\"ambiguous: \", ambiguous);\n        if ( toChange.length > 0 ) {\n\n          // console.log(\"to change: \", toChange);\n          if ( ! ambiguous )  newShapeHoles = betterShapeHoles;\n\n        }\n\n      }\n\n      var tmpHoles;\n\n      for ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n        tmpShape = newShapes[ i ].s;\n        shapes.push( tmpShape );\n        tmpHoles = newShapeHoles[ i ];\n\n        for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n          tmpShape.holes.push( tmpHoles[ j ].h );\n\n        }\n\n      }\n\n      //console.log(\"shape\", shapes);\n\n      return shapes;\n\n    }\n\n  } );\n\n  /**\n   * @author zz85 / http://www.lab4games.net/zz85/blog\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Font( data ) {\n\n    this.data = data;\n\n  }\n\n  Object.assign( Font.prototype, {\n\n    isFont: true,\n\n    generateShapes: function ( text, size, divisions ) {\n\n      function createPaths( text ) {\n\n        var chars = String( text ).split( '' );\n        var scale = size / data.resolution;\n        var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n        var offsetX = 0, offsetY = 0;\n\n        var paths = [];\n\n        for ( var i = 0; i < chars.length; i ++ ) {\n\n          var char = chars[ i ];\n\n          if ( char === '\\n' ) {\n\n            offsetX = 0;\n            offsetY -= line_height;\n\n          } else {\n\n            var ret = createPath( char, scale, offsetX, offsetY );\n            offsetX += ret.offsetX;\n            paths.push( ret.path );\n\n          }\n\n        }\n\n        return paths;\n\n      }\n\n      function createPath( c, scale, offsetX, offsetY ) {\n\n        var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n        if ( ! glyph ) return;\n\n        var path = new ShapePath();\n\n        var pts = [];\n        var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n        if ( glyph.o ) {\n\n          var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n          for ( var i = 0, l = outline.length; i < l; ) {\n\n            var action = outline[ i ++ ];\n\n            switch ( action ) {\n\n              case 'm': // moveTo\n\n                x = outline[ i ++ ] * scale + offsetX;\n                y = outline[ i ++ ] * scale + offsetY;\n\n                path.moveTo( x, y );\n\n                break;\n\n              case 'l': // lineTo\n\n                x = outline[ i ++ ] * scale + offsetX;\n                y = outline[ i ++ ] * scale + offsetY;\n\n                path.lineTo( x, y );\n\n                break;\n\n              case 'q': // quadraticCurveTo\n\n                cpx  = outline[ i ++ ] * scale + offsetX;\n                cpy  = outline[ i ++ ] * scale + offsetY;\n                cpx1 = outline[ i ++ ] * scale + offsetX;\n                cpy1 = outline[ i ++ ] * scale + offsetY;\n\n                path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n                laste = pts[ pts.length - 1 ];\n\n                if ( laste ) {\n\n                  cpx0 = laste.x;\n                  cpy0 = laste.y;\n\n                  for ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n                    var t = i2 / divisions;\n                    QuadraticBezier( t, cpx0, cpx1, cpx );\n                    QuadraticBezier( t, cpy0, cpy1, cpy );\n\n                  }\n\n                }\n\n                break;\n\n              case 'b': // bezierCurveTo\n\n                cpx  = outline[ i ++ ] * scale + offsetX;\n                cpy  = outline[ i ++ ] * scale + offsetY;\n                cpx1 = outline[ i ++ ] * scale + offsetX;\n                cpy1 = outline[ i ++ ] * scale + offsetY;\n                cpx2 = outline[ i ++ ] * scale + offsetX;\n                cpy2 = outline[ i ++ ] * scale + offsetY;\n\n                path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n                laste = pts[ pts.length - 1 ];\n\n                if ( laste ) {\n\n                  cpx0 = laste.x;\n                  cpy0 = laste.y;\n\n                  for ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n                    var t = i2 / divisions;\n                    CubicBezier( t, cpx0, cpx1, cpx2, cpx );\n                    CubicBezier( t, cpy0, cpy1, cpy2, cpy );\n\n                  }\n\n                }\n\n                break;\n\n            }\n\n          }\n\n        }\n\n        return { offsetX: glyph.ha * scale, path: path };\n\n      }\n\n      //\n\n      if ( size === undefined ) size = 100;\n      if ( divisions === undefined ) divisions = 4;\n\n      var data = this.data;\n\n      var paths = createPaths( text );\n      var shapes = [];\n\n      for ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n        Array.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n      }\n\n      return shapes;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function FontLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( FontLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var scope = this;\n\n      var loader = new FileLoader( this.manager );\n      loader.load( url, function ( text ) {\n\n        var json;\n\n        try {\n\n          json = JSON.parse( text );\n\n        } catch ( e ) {\n\n          console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n          json = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n        }\n\n        var font = scope.parse( json );\n\n        if ( onLoad ) onLoad( font );\n\n      }, onProgress, onError );\n\n    },\n\n    parse: function ( json ) {\n\n      return new Font( json );\n\n    }\n\n  } );\n\n  var context;\n\n  var AudioContext = {\n\n    getContext: function () {\n\n      if ( context === undefined ) {\n\n        context = new ( window.AudioContext || window.webkitAudioContext )();\n\n      }\n\n      return context;\n\n    },\n\n    setContext: function ( value ) {\n\n      context = value;\n\n    }\n\n  };\n\n  /**\n   * @author Reece Aaron Lecrivain / http://reecenotes.com/\n   */\n\n  function AudioLoader( manager ) {\n\n    this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n  }\n\n  Object.assign( AudioLoader.prototype, {\n\n    load: function ( url, onLoad, onProgress, onError ) {\n\n      var loader = new FileLoader( this.manager );\n      loader.setResponseType( 'arraybuffer' );\n      loader.load( url, function ( buffer ) {\n\n        var context = AudioContext.getContext();\n\n        context.decodeAudioData( buffer, function ( audioBuffer ) {\n\n          onLoad( audioBuffer );\n\n        } );\n\n      }, onProgress, onError );\n\n    }\n\n  } );\n\n  /**\n   * @author abelnation / http://github.com/abelnation\n   */\n\n  function RectAreaLight ( color, intensity, width, height ) {\n\n    Light.call( this, color, intensity );\n\n    this.type = 'RectAreaLight';\n\n    this.position.set( 0, 1, 0 );\n    this.updateMatrix();\n\n    this.width = ( width !== undefined ) ? width : 10;\n    this.height = ( height !== undefined ) ? height : 10;\n\n    // TODO (abelnation): distance/decay\n\n    // TODO (abelnation): update method for RectAreaLight to update transform to lookat target\n\n    // TODO (abelnation): shadows\n    // this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n  }\n\n  // TODO (abelnation): RectAreaLight update when light shape is changed\n  RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\n\n    constructor: RectAreaLight,\n\n    isRectAreaLight: true,\n\n    copy: function ( source ) {\n\n      Light.prototype.copy.call( this, source );\n\n      this.width = source.width;\n      this.height = source.height;\n\n      // this.shadow = source.shadow.clone();\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function StereoCamera() {\n\n    this.type = 'StereoCamera';\n\n    this.aspect = 1;\n\n    this.eyeSep = 0.064;\n\n    this.cameraL = new PerspectiveCamera();\n    this.cameraL.layers.enable( 1 );\n    this.cameraL.matrixAutoUpdate = false;\n\n    this.cameraR = new PerspectiveCamera();\n    this.cameraR.layers.enable( 2 );\n    this.cameraR.matrixAutoUpdate = false;\n\n  }\n\n  Object.assign( StereoCamera.prototype, {\n\n    update: ( function () {\n\n      var instance, focus, fov, aspect, near, far, zoom;\n\n      var eyeRight = new Matrix4();\n      var eyeLeft = new Matrix4();\n\n      return function update( camera ) {\n\n        var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\n                          aspect !== camera.aspect * this.aspect || near !== camera.near ||\n                          far !== camera.far || zoom !== camera.zoom;\n\n        if ( needsUpdate ) {\n\n          instance = this;\n          focus = camera.focus;\n          fov = camera.fov;\n          aspect = camera.aspect * this.aspect;\n          near = camera.near;\n          far = camera.far;\n          zoom = camera.zoom;\n\n          // Off-axis stereoscopic effect based on\n          // http://paulbourke.net/stereographics/stereorender/\n\n          var projectionMatrix = camera.projectionMatrix.clone();\n          var eyeSep = this.eyeSep / 2;\n          var eyeSepOnProjection = eyeSep * near / focus;\n          var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\n          var xmin, xmax;\n\n          // translate xOffset\n\n          eyeLeft.elements[ 12 ] = - eyeSep;\n          eyeRight.elements[ 12 ] = eyeSep;\n\n          // for left eye\n\n          xmin = - ymax * aspect + eyeSepOnProjection;\n          xmax = ymax * aspect + eyeSepOnProjection;\n\n          projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n          projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n          this.cameraL.projectionMatrix.copy( projectionMatrix );\n\n          // for right eye\n\n          xmin = - ymax * aspect - eyeSepOnProjection;\n          xmax = ymax * aspect - eyeSepOnProjection;\n\n          projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n          projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n          this.cameraR.projectionMatrix.copy( projectionMatrix );\n\n        }\n\n        this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n        this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n      };\n\n    } )()\n\n  } );\n\n  /**\n   * Camera for rendering cube maps\n   *  - renders scene into axis-aligned cube\n   *\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function CubeCamera( near, far, cubeResolution ) {\n\n    Object3D.call( this );\n\n    this.type = 'CubeCamera';\n\n    var fov = 90, aspect = 1;\n\n    var cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n    cameraPX.up.set( 0, - 1, 0 );\n    cameraPX.lookAt( new Vector3( 1, 0, 0 ) );\n    this.add( cameraPX );\n\n    var cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n    cameraNX.up.set( 0, - 1, 0 );\n    cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\n    this.add( cameraNX );\n\n    var cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n    cameraPY.up.set( 0, 0, 1 );\n    cameraPY.lookAt( new Vector3( 0, 1, 0 ) );\n    this.add( cameraPY );\n\n    var cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n    cameraNY.up.set( 0, 0, - 1 );\n    cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\n    this.add( cameraNY );\n\n    var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n    cameraPZ.up.set( 0, - 1, 0 );\n    cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\n    this.add( cameraPZ );\n\n    var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n    cameraNZ.up.set( 0, - 1, 0 );\n    cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\n    this.add( cameraNZ );\n\n    var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\n\n    this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n    this.renderTarget.texture.name = \"CubeCamera\";\n\n    this.updateCubeMap = function ( renderer, scene ) {\n\n      if ( this.parent === null ) this.updateMatrixWorld();\n\n      var renderTarget = this.renderTarget;\n      var generateMipmaps = renderTarget.texture.generateMipmaps;\n\n      renderTarget.texture.generateMipmaps = false;\n\n      renderTarget.activeCubeFace = 0;\n      renderer.render( scene, cameraPX, renderTarget );\n\n      renderTarget.activeCubeFace = 1;\n      renderer.render( scene, cameraNX, renderTarget );\n\n      renderTarget.activeCubeFace = 2;\n      renderer.render( scene, cameraPY, renderTarget );\n\n      renderTarget.activeCubeFace = 3;\n      renderer.render( scene, cameraNY, renderTarget );\n\n      renderTarget.activeCubeFace = 4;\n      renderer.render( scene, cameraPZ, renderTarget );\n\n      renderTarget.texture.generateMipmaps = generateMipmaps;\n\n      renderTarget.activeCubeFace = 5;\n      renderer.render( scene, cameraNZ, renderTarget );\n\n      renderer.setRenderTarget( null );\n\n    };\n\n  }\n\n  CubeCamera.prototype = Object.create( Object3D.prototype );\n  CubeCamera.prototype.constructor = CubeCamera;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function AudioListener() {\n\n    Object3D.call( this );\n\n    this.type = 'AudioListener';\n\n    this.context = AudioContext.getContext();\n\n    this.gain = this.context.createGain();\n    this.gain.connect( this.context.destination );\n\n    this.filter = null;\n\n  }\n\n  AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: AudioListener,\n\n    getInput: function () {\n\n      return this.gain;\n\n    },\n\n    removeFilter: function ( ) {\n\n      if ( this.filter !== null ) {\n\n        this.gain.disconnect( this.filter );\n        this.filter.disconnect( this.context.destination );\n        this.gain.connect( this.context.destination );\n        this.filter = null;\n\n      }\n\n    },\n\n    getFilter: function () {\n\n      return this.filter;\n\n    },\n\n    setFilter: function ( value ) {\n\n      if ( this.filter !== null ) {\n\n        this.gain.disconnect( this.filter );\n        this.filter.disconnect( this.context.destination );\n\n      } else {\n\n        this.gain.disconnect( this.context.destination );\n\n      }\n\n      this.filter = value;\n      this.gain.connect( this.filter );\n      this.filter.connect( this.context.destination );\n\n    },\n\n    getMasterVolume: function () {\n\n      return this.gain.gain.value;\n\n    },\n\n    setMasterVolume: function ( value ) {\n\n      this.gain.gain.value = value;\n\n    },\n\n    updateMatrixWorld: ( function () {\n\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n      var scale = new Vector3();\n\n      var orientation = new Vector3();\n\n      return function updateMatrixWorld( force ) {\n\n        Object3D.prototype.updateMatrixWorld.call( this, force );\n\n        var listener = this.context.listener;\n        var up = this.up;\n\n        this.matrixWorld.decompose( position, quaternion, scale );\n\n        orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n        if ( listener.positionX ) {\n\n          listener.positionX.setValueAtTime( position.x, this.context.currentTime );\n          listener.positionY.setValueAtTime( position.y, this.context.currentTime );\n          listener.positionZ.setValueAtTime( position.z, this.context.currentTime );\n          listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\n          listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\n          listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\n          listener.upX.setValueAtTime( up.x, this.context.currentTime );\n          listener.upY.setValueAtTime( up.y, this.context.currentTime );\n          listener.upZ.setValueAtTime( up.z, this.context.currentTime );\n\n        } else {\n\n          listener.setPosition( position.x, position.y, position.z );\n          listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n        }\n\n      };\n\n    } )()\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author Reece Aaron Lecrivain / http://reecenotes.com/\n   */\n\n  function Audio( listener ) {\n\n    Object3D.call( this );\n\n    this.type = 'Audio';\n\n    this.context = listener.context;\n\n    this.gain = this.context.createGain();\n    this.gain.connect( listener.getInput() );\n\n    this.autoplay = false;\n\n    this.buffer = null;\n    this.loop = false;\n    this.startTime = 0;\n    this.playbackRate = 1;\n    this.isPlaying = false;\n    this.hasPlaybackControl = true;\n    this.sourceType = 'empty';\n\n    this.filters = [];\n\n  }\n\n  Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {\n\n    constructor: Audio,\n\n    getOutput: function () {\n\n      return this.gain;\n\n    },\n\n    setNodeSource: function ( audioNode ) {\n\n      this.hasPlaybackControl = false;\n      this.sourceType = 'audioNode';\n      this.source = audioNode;\n      this.connect();\n\n      return this;\n\n    },\n\n    setBuffer: function ( audioBuffer ) {\n\n      this.buffer = audioBuffer;\n      this.sourceType = 'buffer';\n\n      if ( this.autoplay ) this.play();\n\n      return this;\n\n    },\n\n    play: function () {\n\n      if ( this.isPlaying === true ) {\n\n        console.warn( 'THREE.Audio: Audio is already playing.' );\n        return;\n\n      }\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return;\n\n      }\n\n      var source = this.context.createBufferSource();\n\n      source.buffer = this.buffer;\n      source.loop = this.loop;\n      source.onended = this.onEnded.bind( this );\n      source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\n      source.start( 0, this.startTime );\n\n      this.isPlaying = true;\n\n      this.source = source;\n\n      return this.connect();\n\n    },\n\n    pause: function () {\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return;\n\n      }\n\n      this.source.stop();\n      this.startTime = this.context.currentTime;\n      this.isPlaying = false;\n\n      return this;\n\n    },\n\n    stop: function () {\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return;\n\n      }\n\n      this.source.stop();\n      this.startTime = 0;\n      this.isPlaying = false;\n\n      return this;\n\n    },\n\n    connect: function () {\n\n      if ( this.filters.length > 0 ) {\n\n        this.source.connect( this.filters[ 0 ] );\n\n        for ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n          this.filters[ i - 1 ].connect( this.filters[ i ] );\n\n        }\n\n        this.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n      } else {\n\n        this.source.connect( this.getOutput() );\n\n      }\n\n      return this;\n\n    },\n\n    disconnect: function () {\n\n      if ( this.filters.length > 0 ) {\n\n        this.source.disconnect( this.filters[ 0 ] );\n\n        for ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n          this.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n        }\n\n        this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n      } else {\n\n        this.source.disconnect( this.getOutput() );\n\n      }\n\n      return this;\n\n    },\n\n    getFilters: function () {\n\n      return this.filters;\n\n    },\n\n    setFilters: function ( value ) {\n\n      if ( ! value ) value = [];\n\n      if ( this.isPlaying === true ) {\n\n        this.disconnect();\n        this.filters = value;\n        this.connect();\n\n      } else {\n\n        this.filters = value;\n\n      }\n\n      return this;\n\n    },\n\n    getFilter: function () {\n\n      return this.getFilters()[ 0 ];\n\n    },\n\n    setFilter: function ( filter ) {\n\n      return this.setFilters( filter ? [ filter ] : [] );\n\n    },\n\n    setPlaybackRate: function ( value ) {\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return;\n\n      }\n\n      this.playbackRate = value;\n\n      if ( this.isPlaying === true ) {\n\n        this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\n\n      }\n\n      return this;\n\n    },\n\n    getPlaybackRate: function () {\n\n      return this.playbackRate;\n\n    },\n\n    onEnded: function () {\n\n      this.isPlaying = false;\n\n    },\n\n    getLoop: function () {\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return false;\n\n      }\n\n      return this.loop;\n\n    },\n\n    setLoop: function ( value ) {\n\n      if ( this.hasPlaybackControl === false ) {\n\n        console.warn( 'THREE.Audio: this Audio has no playback control.' );\n        return;\n\n      }\n\n      this.loop = value;\n\n      if ( this.isPlaying === true ) {\n\n        this.source.loop = this.loop;\n\n      }\n\n      return this;\n\n    },\n\n    getVolume: function () {\n\n      return this.gain.gain.value;\n\n    },\n\n    setVolume: function ( value ) {\n\n      this.gain.gain.value = value;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function PositionalAudio( listener ) {\n\n    Audio.call( this, listener );\n\n    this.panner = this.context.createPanner();\n    this.panner.connect( this.gain );\n\n  }\n\n  PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\n\n    constructor: PositionalAudio,\n\n    getOutput: function () {\n\n      return this.panner;\n\n    },\n\n    getRefDistance: function () {\n\n      return this.panner.refDistance;\n\n    },\n\n    setRefDistance: function ( value ) {\n\n      this.panner.refDistance = value;\n\n    },\n\n    getRolloffFactor: function () {\n\n      return this.panner.rolloffFactor;\n\n    },\n\n    setRolloffFactor: function ( value ) {\n\n      this.panner.rolloffFactor = value;\n\n    },\n\n    getDistanceModel: function () {\n\n      return this.panner.distanceModel;\n\n    },\n\n    setDistanceModel: function ( value ) {\n\n      this.panner.distanceModel = value;\n\n    },\n\n    getMaxDistance: function () {\n\n      return this.panner.maxDistance;\n\n    },\n\n    setMaxDistance: function ( value ) {\n\n      this.panner.maxDistance = value;\n\n    },\n\n    updateMatrixWorld: ( function () {\n\n      var position = new Vector3();\n\n      return function updateMatrixWorld( force ) {\n\n        Object3D.prototype.updateMatrixWorld.call( this, force );\n\n        position.setFromMatrixPosition( this.matrixWorld );\n\n        this.panner.setPosition( position.x, position.y, position.z );\n\n      };\n\n    } )()\n\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function AudioAnalyser( audio, fftSize ) {\n\n    this.analyser = audio.context.createAnalyser();\n    this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n    this.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n    audio.getOutput().connect( this.analyser );\n\n  }\n\n  Object.assign( AudioAnalyser.prototype, {\n\n    getFrequencyData: function () {\n\n      this.analyser.getByteFrequencyData( this.data );\n\n      return this.data;\n\n    },\n\n    getAverageFrequency: function () {\n\n      var value = 0, data = this.getFrequencyData();\n\n      for ( var i = 0; i < data.length; i ++ ) {\n\n        value += data[ i ];\n\n      }\n\n      return value / data.length;\n\n    }\n\n  } );\n\n  /**\n   *\n   * Buffered scene graph property that allows weighted accumulation.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function PropertyMixer( binding, typeName, valueSize ) {\n\n    this.binding = binding;\n    this.valueSize = valueSize;\n\n    var bufferType = Float64Array,\n      mixFunction;\n\n    switch ( typeName ) {\n\n      case 'quaternion':\n        mixFunction = this._slerp;\n        break;\n\n      case 'string':\n      case 'bool':\n        bufferType = Array;\n        mixFunction = this._select;\n        break;\n\n      default:\n        mixFunction = this._lerp;\n\n    }\n\n    this.buffer = new bufferType( valueSize * 4 );\n    // layout: [ incoming | accu0 | accu1 | orig ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n\n    this._mixBufferRegion = mixFunction;\n\n    this.cumulativeWeight = 0;\n\n    this.useCount = 0;\n    this.referenceCount = 0;\n\n  }\n\n  Object.assign( PropertyMixer.prototype, {\n\n    // accumulate data in the 'incoming' region into 'accu<i>'\n    accumulate: function ( accuIndex, weight ) {\n\n      // note: happily accumulating nothing when weight = 0, the caller knows\n      // the weight and shouldn't have made the call in the first place\n\n      var buffer = this.buffer,\n        stride = this.valueSize,\n        offset = accuIndex * stride + stride,\n\n        currentWeight = this.cumulativeWeight;\n\n      if ( currentWeight === 0 ) {\n\n        // accuN := incoming * weight\n\n        for ( var i = 0; i !== stride; ++ i ) {\n\n          buffer[ offset + i ] = buffer[ i ];\n\n        }\n\n        currentWeight = weight;\n\n      } else {\n\n        // accuN := accuN + incoming * weight\n\n        currentWeight += weight;\n        var mix = weight / currentWeight;\n        this._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n      }\n\n      this.cumulativeWeight = currentWeight;\n\n    },\n\n    // apply the state of 'accu<i>' to the binding when accus differ\n    apply: function ( accuIndex ) {\n\n      var stride = this.valueSize,\n        buffer = this.buffer,\n        offset = accuIndex * stride + stride,\n\n        weight = this.cumulativeWeight,\n\n        binding = this.binding;\n\n      this.cumulativeWeight = 0;\n\n      if ( weight < 1 ) {\n\n        // accuN := accuN + original * ( 1 - cumulativeWeight )\n\n        var originalValueOffset = stride * 3;\n\n        this._mixBufferRegion(\n          buffer, offset, originalValueOffset, 1 - weight, stride );\n\n      }\n\n      for ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n        if ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n          // value has changed -> update scene graph\n\n          binding.setValue( buffer, offset );\n          break;\n\n        }\n\n      }\n\n    },\n\n    // remember the state of the bound property and copy it to both accus\n    saveOriginalState: function () {\n\n      var binding = this.binding;\n\n      var buffer = this.buffer,\n        stride = this.valueSize,\n\n        originalValueOffset = stride * 3;\n\n      binding.getValue( buffer, originalValueOffset );\n\n      // accu[0..1] := orig -- initially detect changes against the original\n      for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n        buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n      }\n\n      this.cumulativeWeight = 0;\n\n    },\n\n    // apply the state previously taken via 'saveOriginalState' to the binding\n    restoreOriginalState: function () {\n\n      var originalValueOffset = this.valueSize * 3;\n      this.binding.setValue( this.buffer, originalValueOffset );\n\n    },\n\n\n    // mix functions\n\n    _select: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n      if ( t >= 0.5 ) {\n\n        for ( var i = 0; i !== stride; ++ i ) {\n\n          buffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n        }\n\n      }\n\n    },\n\n    _slerp: function ( buffer, dstOffset, srcOffset, t ) {\n\n      Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n    },\n\n    _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\n\n      var s = 1 - t;\n\n      for ( var i = 0; i !== stride; ++ i ) {\n\n        var j = dstOffset + i;\n\n        buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n      }\n\n    }\n\n  } );\n\n  /**\n   *\n   * A reference to a real property in the scene graph.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function Composite( targetGroup, path, optionalParsedPath ) {\n\n    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_( path, parsedPath );\n\n  }\n\n  Object.assign( Composite.prototype, {\n\n    getValue: function ( array, offset ) {\n\n      this.bind(); // bind all binding\n\n      var firstValidIndex = this._targetGroup.nCachedObjects_,\n        binding = this._bindings[ firstValidIndex ];\n\n      // and only call .getValue on the first\n      if ( binding !== undefined ) binding.getValue( array, offset );\n\n    },\n\n    setValue: function ( array, offset ) {\n\n      var bindings = this._bindings;\n\n      for ( var i = this._targetGroup.nCachedObjects_,\n            n = bindings.length; i !== n; ++ i ) {\n\n        bindings[ i ].setValue( array, offset );\n\n      }\n\n    },\n\n    bind: function () {\n\n      var bindings = this._bindings;\n\n      for ( var i = this._targetGroup.nCachedObjects_,\n            n = bindings.length; i !== n; ++ i ) {\n\n        bindings[ i ].bind();\n\n      }\n\n    },\n\n    unbind: function () {\n\n      var bindings = this._bindings;\n\n      for ( var i = this._targetGroup.nCachedObjects_,\n            n = bindings.length; i !== n; ++ i ) {\n\n        bindings[ i ].unbind();\n\n      }\n\n    }\n\n  } );\n\n\n  function PropertyBinding( rootNode, path, parsedPath ) {\n\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n    this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\n\n    this.rootNode = rootNode;\n\n  }\n\n  Object.assign( PropertyBinding, {\n\n    Composite: Composite,\n\n    create: function ( root, path, parsedPath ) {\n\n      if ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n        return new PropertyBinding( root, path, parsedPath );\n\n      } else {\n\n        return new PropertyBinding.Composite( root, path, parsedPath );\n\n      }\n\n    },\n\n    parseTrackName: function ( trackName ) {\n\n      // matches strings in the form of:\n      //    nodeName.property\n      //    nodeName.property[accessor]\n      //    nodeName.material.property[accessor]\n      //    uuid.property[accessor]\n      //    uuid.objectName[objectIndex].propertyName[propertyIndex]\n      //    parentName/nodeName.property\n      //    parentName/parentName/nodeName.property[index]\n      //    .bone[Armature.DEF_cog].position\n      //    scene:helium_balloon_model:helium_balloon_model.position\n      // created and tested via https://regex101.com/#javascript\n\n      var re = /^((?:[\\w-]+[\\/:])*)([\\w-]+)?(?:\\.([\\w-]+)(?:\\[(.+)\\])?)?\\.([\\w-]+)(?:\\[(.+)\\])?$/;\n      var matches = re.exec( trackName );\n\n      if ( ! matches ) {\n\n        throw new Error( \"cannot parse trackName at all: \" + trackName );\n\n      }\n\n      var results = {\n        // directoryName: matches[ 1 ], // (tschw) currently unused\n        nodeName: matches[ 2 ],   // allowed to be null, specified root node.\n        objectName: matches[ 3 ],\n        objectIndex: matches[ 4 ],\n        propertyName: matches[ 5 ],\n        propertyIndex: matches[ 6 ] // allowed to be null, specifies that the whole property is set.\n      };\n\n      if ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n        throw new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n      }\n\n      return results;\n\n    },\n\n    findNode: function ( root, nodeName ) {\n\n      if ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n        return root;\n\n      }\n\n      // search into skeleton bones.\n      if ( root.skeleton ) {\n\n        var searchSkeleton = function ( skeleton ) {\n\n          for ( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n            var bone = skeleton.bones[ i ];\n\n            if ( bone.name === nodeName ) {\n\n              return bone;\n\n            }\n\n          }\n\n          return null;\n\n        };\n\n        var bone = searchSkeleton( root.skeleton );\n\n        if ( bone ) {\n\n          return bone;\n\n        }\n\n      }\n\n      // search into node subtree.\n      if ( root.children ) {\n\n        var searchNodeSubtree = function ( children ) {\n\n          for ( var i = 0; i < children.length; i ++ ) {\n\n            var childNode = children[ i ];\n\n            if ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n              return childNode;\n\n            }\n\n            var result = searchNodeSubtree( childNode.children );\n\n            if ( result ) return result;\n\n          }\n\n          return null;\n\n        };\n\n        var subTreeNode = searchNodeSubtree( root.children );\n\n        if ( subTreeNode ) {\n\n          return subTreeNode;\n\n        }\n\n      }\n\n      return null;\n\n    }\n\n  } );\n\n  Object.assign( PropertyBinding.prototype, { // prototype, continued\n\n    // these are used to \"bind\" a nonexistent property\n    _getValue_unavailable: function () {},\n    _setValue_unavailable: function () {},\n\n    BindingType: {\n      Direct: 0,\n      EntireArray: 1,\n      ArrayElement: 2,\n      HasFromToArray: 3\n    },\n\n    Versioning: {\n      None: 0,\n      NeedsUpdate: 1,\n      MatrixWorldNeedsUpdate: 2\n    },\n\n    GetterByBindingType: [\n\n      function getValue_direct( buffer, offset ) {\n\n        buffer[ offset ] = this.node[ this.propertyName ];\n\n      },\n\n      function getValue_array( buffer, offset ) {\n\n        var source = this.resolvedProperty;\n\n        for ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n          buffer[ offset ++ ] = source[ i ];\n\n        }\n\n      },\n\n      function getValue_arrayElement( buffer, offset ) {\n\n        buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n      },\n\n      function getValue_toArray( buffer, offset ) {\n\n        this.resolvedProperty.toArray( buffer, offset );\n\n      }\n\n    ],\n\n    SetterByBindingTypeAndVersioning: [\n\n      [\n        // Direct\n\n        function setValue_direct( buffer, offset ) {\n\n          this.node[ this.propertyName ] = buffer[ offset ];\n\n        },\n\n        function setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n          this.node[ this.propertyName ] = buffer[ offset ];\n          this.targetObject.needsUpdate = true;\n\n        },\n\n        function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n          this.node[ this.propertyName ] = buffer[ offset ];\n          this.targetObject.matrixWorldNeedsUpdate = true;\n\n        }\n\n      ], [\n\n        // EntireArray\n\n        function setValue_array( buffer, offset ) {\n\n          var dest = this.resolvedProperty;\n\n          for ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n            dest[ i ] = buffer[ offset ++ ];\n\n          }\n\n        },\n\n        function setValue_array_setNeedsUpdate( buffer, offset ) {\n\n          var dest = this.resolvedProperty;\n\n          for ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n            dest[ i ] = buffer[ offset ++ ];\n\n          }\n\n          this.targetObject.needsUpdate = true;\n\n        },\n\n        function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n          var dest = this.resolvedProperty;\n\n          for ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n            dest[ i ] = buffer[ offset ++ ];\n\n          }\n\n          this.targetObject.matrixWorldNeedsUpdate = true;\n\n        }\n\n      ], [\n\n        // ArrayElement\n\n        function setValue_arrayElement( buffer, offset ) {\n\n          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n        },\n\n        function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n          this.targetObject.needsUpdate = true;\n\n        },\n\n        function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n          this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n          this.targetObject.matrixWorldNeedsUpdate = true;\n\n        }\n\n      ], [\n\n        // HasToFromArray\n\n        function setValue_fromArray( buffer, offset ) {\n\n          this.resolvedProperty.fromArray( buffer, offset );\n\n        },\n\n        function setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n          this.resolvedProperty.fromArray( buffer, offset );\n          this.targetObject.needsUpdate = true;\n\n        },\n\n        function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n          this.resolvedProperty.fromArray( buffer, offset );\n          this.targetObject.matrixWorldNeedsUpdate = true;\n\n        }\n\n      ]\n\n    ],\n\n    getValue: function getValue_unbound( targetArray, offset ) {\n\n      this.bind();\n      this.getValue( targetArray, offset );\n\n      // Note: This class uses a State pattern on a per-method basis:\n      // 'bind' sets 'this.getValue' / 'setValue' and shadows the\n      // prototype version of these methods with one that represents\n      // the bound state. When the property is not found, the methods\n      // become no-ops.\n\n    },\n\n    setValue: function getValue_unbound( sourceArray, offset ) {\n\n      this.bind();\n      this.setValue( sourceArray, offset );\n\n    },\n\n    // create getter / setter pair for a property in the scene graph\n    bind: function () {\n\n      var targetObject = this.node,\n        parsedPath = this.parsedPath,\n\n        objectName = parsedPath.objectName,\n        propertyName = parsedPath.propertyName,\n        propertyIndex = parsedPath.propertyIndex;\n\n      if ( ! targetObject ) {\n\n        targetObject = PropertyBinding.findNode(\n            this.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n        this.node = targetObject;\n\n      }\n\n      // set fail state so we can just 'return' on error\n      this.getValue = this._getValue_unavailable;\n      this.setValue = this._setValue_unavailable;\n\n      // ensure there is a value node\n      if ( ! targetObject ) {\n\n        console.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n        return;\n\n      }\n\n      if ( objectName ) {\n\n        var objectIndex = parsedPath.objectIndex;\n\n        // special cases were we need to reach deeper into the hierarchy to get the face materials....\n        switch ( objectName ) {\n\n          case 'materials':\n\n            if ( ! targetObject.material ) {\n\n              console.error( '  can not bind to material as node does not have a material', this );\n              return;\n\n            }\n\n            if ( ! targetObject.material.materials ) {\n\n              console.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n              return;\n\n            }\n\n            targetObject = targetObject.material.materials;\n\n            break;\n\n          case 'bones':\n\n            if ( ! targetObject.skeleton ) {\n\n              console.error( '  can not bind to bones as node does not have a skeleton', this );\n              return;\n\n            }\n\n            // potential future optimization: skip this if propertyIndex is already an integer\n            // and convert the integer string to a true integer.\n\n            targetObject = targetObject.skeleton.bones;\n\n            // support resolving morphTarget names into indices.\n            for ( var i = 0; i < targetObject.length; i ++ ) {\n\n              if ( targetObject[ i ].name === objectIndex ) {\n\n                objectIndex = i;\n                break;\n\n              }\n\n            }\n\n            break;\n\n          default:\n\n            if ( targetObject[ objectName ] === undefined ) {\n\n              console.error( '  can not bind to objectName of node, undefined', this );\n              return;\n\n            }\n\n            targetObject = targetObject[ objectName ];\n\n        }\n\n\n        if ( objectIndex !== undefined ) {\n\n          if ( targetObject[ objectIndex ] === undefined ) {\n\n            console.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n            return;\n\n          }\n\n          targetObject = targetObject[ objectIndex ];\n\n        }\n\n      }\n\n      // resolve property\n      var nodeProperty = targetObject[ propertyName ];\n\n      if ( nodeProperty === undefined ) {\n\n        var nodeName = parsedPath.nodeName;\n\n        console.error( \"  trying to update property for track: \" + nodeName +\n          '.' + propertyName + \" but it wasn't found.\", targetObject );\n        return;\n\n      }\n\n      // determine versioning scheme\n      var versioning = this.Versioning.None;\n\n      if ( targetObject.needsUpdate !== undefined ) { // material\n\n        versioning = this.Versioning.NeedsUpdate;\n        this.targetObject = targetObject;\n\n      } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n        versioning = this.Versioning.MatrixWorldNeedsUpdate;\n        this.targetObject = targetObject;\n\n      }\n\n      // determine how the property gets bound\n      var bindingType = this.BindingType.Direct;\n\n      if ( propertyIndex !== undefined ) {\n\n        // access a sub element of the property array (only primitives are supported right now)\n\n        if ( propertyName === \"morphTargetInfluences\" ) {\n\n          // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n          // support resolving morphTarget names into indices.\n          if ( ! targetObject.geometry ) {\n\n            console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n            return;\n\n          }\n\n          if ( ! targetObject.geometry.morphTargets ) {\n\n            console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n            return;\n\n          }\n\n          for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n            if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n              propertyIndex = i;\n              break;\n\n            }\n\n          }\n\n        }\n\n        bindingType = this.BindingType.ArrayElement;\n\n        this.resolvedProperty = nodeProperty;\n        this.propertyIndex = propertyIndex;\n\n      } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n        // must use copy for Object3D.Euler/Quaternion\n\n        bindingType = this.BindingType.HasFromToArray;\n\n        this.resolvedProperty = nodeProperty;\n\n      } else if ( Array.isArray( nodeProperty ) ) {\n\n        bindingType = this.BindingType.EntireArray;\n\n        this.resolvedProperty = nodeProperty;\n\n      } else {\n\n        this.propertyName = propertyName;\n\n      }\n\n      // select getter / setter\n      this.getValue = this.GetterByBindingType[ bindingType ];\n      this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n    },\n\n    unbind: function () {\n\n      this.node = null;\n\n      // back to the prototype version of getValue / setValue\n      // note: avoiding to mutate the shape of 'this' via 'delete'\n      this.getValue = this._getValue_unbound;\n      this.setValue = this._setValue_unbound;\n\n    }\n\n  } );\n\n  //!\\ DECLARE ALIAS AFTER assign prototype !\n  Object.assign( PropertyBinding.prototype, {\n\n    // initial state of these methods that calls 'bind'\n    _getValue_unbound: PropertyBinding.prototype.getValue,\n    _setValue_unbound: PropertyBinding.prototype.setValue,\n\n  } );\n\n  /**\n   *\n   * A group of objects that receives a shared animation state.\n   *\n   * Usage:\n   *\n   *  - Add objects you would otherwise pass as 'root' to the\n   *    constructor or the .clipAction method of AnimationMixer.\n   *\n   *  - Instead pass this object as 'root'.\n   *\n   *  - You can also add and remove objects later when the mixer\n   *    is running.\n   *\n   * Note:\n   *\n   *    Objects of this class appear as one object to the mixer,\n   *    so cache control of the individual objects must be done\n   *    on the group.\n   *\n   * Limitation:\n   *\n   *  -   The animated properties must be compatible among the\n   *    all objects in the group.\n   *\n   *  - A single property can either be controlled through a\n   *    target group or directly, but not both.\n   *\n   * @author tschw\n   */\n\n  function AnimationObjectGroup( var_args ) {\n\n    this.uuid = _Math.generateUUID();\n\n    // cached objects followed by the active ones\n    this._objects = Array.prototype.slice.call( arguments );\n\n    this.nCachedObjects_ = 0;     // threshold\n    // note: read by PropertyBinding.Composite\n\n    var indices = {};\n    this._indicesByUUID = indices;    // for bookkeeping\n\n    for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n      indices[ arguments[ i ].uuid ] = i;\n\n    }\n\n    this._paths = [];         // inside: string\n    this._parsedPaths = [];       // inside: { we don't care, here }\n    this._bindings = [];        // inside: Array< PropertyBinding >\n    this._bindingsIndicesByPath = {};   // inside: indices in these arrays\n\n    var scope = this;\n\n    this.stats = {\n\n      objects: {\n        get total() { return scope._objects.length; },\n        get inUse() { return this.total - scope.nCachedObjects_; }\n      },\n\n      get bindingsPerObject() { return scope._bindings.length; }\n\n    };\n\n  }\n\n  Object.assign( AnimationObjectGroup.prototype, {\n\n    isAnimationObjectGroup: true,\n\n    add: function( var_args ) {\n\n      var objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n\n      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n        var object = arguments[ i ],\n          uuid = object.uuid,\n          index = indicesByUUID[ uuid ],\n          knownObject = undefined;\n\n        if ( index === undefined ) {\n\n          // unknown object -> add it to the ACTIVE region\n\n          index = nObjects ++;\n          indicesByUUID[ uuid ] = index;\n          objects.push( object );\n\n          // accounting is done, now do the same for all bindings\n\n          for ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n            bindings[ j ].push(\n                new PropertyBinding(\n                  object, paths[ j ], parsedPaths[ j ] ) );\n\n          }\n\n        } else if ( index < nCachedObjects ) {\n\n          knownObject = objects[ index ];\n\n          // move existing object to the ACTIVE region\n\n          var firstActiveIndex = -- nCachedObjects,\n            lastCachedObject = objects[ firstActiveIndex ];\n\n          indicesByUUID[ lastCachedObject.uuid ] = index;\n          objects[ index ] = lastCachedObject;\n\n          indicesByUUID[ uuid ] = firstActiveIndex;\n          objects[ firstActiveIndex ] = object;\n\n          // accounting is done, now do the same for all bindings\n\n          for ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n            var bindingsForPath = bindings[ j ],\n              lastCached = bindingsForPath[ firstActiveIndex ],\n              binding = bindingsForPath[ index ];\n\n            bindingsForPath[ index ] = lastCached;\n\n            if ( binding === undefined ) {\n\n              // since we do not bother to create new bindings\n              // for objects that are cached, the binding may\n              // or may not exist\n\n              binding = new PropertyBinding(\n                  object, paths[ j ], parsedPaths[ j ] );\n\n            }\n\n            bindingsForPath[ firstActiveIndex ] = binding;\n\n          }\n\n        } else if ( objects[ index ] !== knownObject ) {\n\n          console.error( \"Different objects with the same UUID \" +\n              \"detected. Clean the caches or recreate your \" +\n              \"infrastructure when reloading scenes...\" );\n\n        } // else the object is already where we want it to be\n\n      } // for arguments\n\n      this.nCachedObjects_ = nCachedObjects;\n\n    },\n\n    remove: function( var_args ) {\n\n      var objects = this._objects,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n\n      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n        var object = arguments[ i ],\n          uuid = object.uuid,\n          index = indicesByUUID[ uuid ];\n\n        if ( index !== undefined && index >= nCachedObjects ) {\n\n          // move existing object into the CACHED region\n\n          var lastCachedIndex = nCachedObjects ++,\n            firstActiveObject = objects[ lastCachedIndex ];\n\n          indicesByUUID[ firstActiveObject.uuid ] = index;\n          objects[ index ] = firstActiveObject;\n\n          indicesByUUID[ uuid ] = lastCachedIndex;\n          objects[ lastCachedIndex ] = object;\n\n          // accounting is done, now do the same for all bindings\n\n          for ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n            var bindingsForPath = bindings[ j ],\n              firstActive = bindingsForPath[ lastCachedIndex ],\n              binding = bindingsForPath[ index ];\n\n            bindingsForPath[ index ] = firstActive;\n            bindingsForPath[ lastCachedIndex ] = binding;\n\n          }\n\n        }\n\n      } // for arguments\n\n      this.nCachedObjects_ = nCachedObjects;\n\n    },\n\n    // remove & forget\n    uncache: function( var_args ) {\n\n      var objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        indicesByUUID = this._indicesByUUID,\n        bindings = this._bindings,\n        nBindings = bindings.length;\n\n      for ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n        var object = arguments[ i ],\n          uuid = object.uuid,\n          index = indicesByUUID[ uuid ];\n\n        if ( index !== undefined ) {\n\n          delete indicesByUUID[ uuid ];\n\n          if ( index < nCachedObjects ) {\n\n            // object is cached, shrink the CACHED region\n\n            var firstActiveIndex = -- nCachedObjects,\n              lastCachedObject = objects[ firstActiveIndex ],\n              lastIndex = -- nObjects,\n              lastObject = objects[ lastIndex ];\n\n            // last cached object takes this object's place\n            indicesByUUID[ lastCachedObject.uuid ] = index;\n            objects[ index ] = lastCachedObject;\n\n            // last object goes to the activated slot and pop\n            indicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n            objects[ firstActiveIndex ] = lastObject;\n            objects.pop();\n\n            // accounting is done, now do the same for all bindings\n\n            for ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n              var bindingsForPath = bindings[ j ],\n                lastCached = bindingsForPath[ firstActiveIndex ],\n                last = bindingsForPath[ lastIndex ];\n\n              bindingsForPath[ index ] = lastCached;\n              bindingsForPath[ firstActiveIndex ] = last;\n              bindingsForPath.pop();\n\n            }\n\n          } else {\n\n            // object is active, just swap with the last and pop\n\n            var lastIndex = -- nObjects,\n              lastObject = objects[ lastIndex ];\n\n            indicesByUUID[ lastObject.uuid ] = index;\n            objects[ index ] = lastObject;\n            objects.pop();\n\n            // accounting is done, now do the same for all bindings\n\n            for ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n              var bindingsForPath = bindings[ j ];\n\n              bindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n              bindingsForPath.pop();\n\n            }\n\n          } // cached or active\n\n        } // if object is known\n\n      } // for arguments\n\n      this.nCachedObjects_ = nCachedObjects;\n\n    },\n\n    // Internal interface used by befriended PropertyBinding.Composite:\n\n    subscribe_: function ( path, parsedPath ) {\n\n      // returns an array of bindings for the given path that is changed\n      // according to the contained objects in the group\n\n      var indicesByPath = this._bindingsIndicesByPath,\n        index = indicesByPath[ path ],\n        bindings = this._bindings;\n\n      if ( index !== undefined ) return bindings[ index ];\n\n      var paths = this._paths,\n        parsedPaths = this._parsedPaths,\n        objects = this._objects,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_,\n        bindingsForPath = new Array( nObjects );\n\n      index = bindings.length;\n\n      indicesByPath[ path ] = index;\n\n      paths.push( path );\n      parsedPaths.push( parsedPath );\n      bindings.push( bindingsForPath );\n\n      for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n        var object = objects[ i ];\n        bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n      }\n\n      return bindingsForPath;\n\n    },\n\n    unsubscribe_: function ( path ) {\n\n      // tells the group to forget about a property path and no longer\n      // update the array previously obtained with 'subscribe_'\n\n      var indicesByPath = this._bindingsIndicesByPath,\n        index = indicesByPath[ path ];\n\n      if ( index !== undefined ) {\n\n        var paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          bindings = this._bindings,\n          lastBindingsIndex = bindings.length - 1,\n          lastBindings = bindings[ lastBindingsIndex ],\n          lastBindingsPath = path[ lastBindingsIndex ];\n\n        indicesByPath[ lastBindingsPath ] = index;\n\n        bindings[ index ] = lastBindings;\n        bindings.pop();\n\n        parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n        parsedPaths.pop();\n\n        paths[ index ] = paths[ lastBindingsIndex ];\n        paths.pop();\n\n      }\n\n    }\n\n  } );\n\n  /**\n   *\n   * Action provided by AnimationMixer for scheduling clip playback on specific\n   * objects.\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   *\n   */\n\n  function AnimationAction( mixer, clip, localRoot ) {\n\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot || null;\n\n    var tracks = clip.tracks,\n      nTracks = tracks.length,\n      interpolants = new Array( nTracks );\n\n    var interpolantSettings = {\n        endingStart:  ZeroCurvatureEnding,\n        endingEnd:    ZeroCurvatureEnding\n    };\n\n    for ( var i = 0; i !== nTracks; ++ i ) {\n\n      var interpolant = tracks[ i ].createInterpolant( null );\n      interpolants[ i ] = interpolant;\n      interpolant.settings = interpolantSettings;\n\n    }\n\n    this._interpolantSettings = interpolantSettings;\n\n    this._interpolants = interpolants;  // bound by the mixer\n\n    // inside: PropertyMixer (managed by the mixer)\n    this._propertyBindings = new Array( nTracks );\n\n    this._cacheIndex = null;      // for the memory manager\n    this._byClipCacheIndex = null;    // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n\n    this.loop = LoopRepeat;\n    this._loopCount = -1;\n\n    // global mixer time when the action is to be started\n    // it's set back to 'null' upon start of the action\n    this._startTime = null;\n\n    // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n    this.time = 0;\n\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n\n    this.weight = 1;\n    this._effectiveWeight = 1;\n\n    this.repetitions = Infinity;    // no. of repetitions when looping\n\n    this.paused = false;        // false -> zero effective time scale\n    this.enabled = true;        // true -> zero effective weight\n\n    this.clampWhenFinished  = false;  // keep feeding the last frame?\n\n    this.zeroSlopeAtStart   = true;   // for smooth interpolation w/o separate\n    this.zeroSlopeAtEnd   = true;   // clips for start, loop and end\n\n  }\n\n  Object.assign( AnimationAction.prototype, {\n\n    // State & Scheduling\n\n    play: function() {\n\n      this._mixer._activateAction( this );\n\n      return this;\n\n    },\n\n    stop: function() {\n\n      this._mixer._deactivateAction( this );\n\n      return this.reset();\n\n    },\n\n    reset: function() {\n\n      this.paused = false;\n      this.enabled = true;\n\n      this.time = 0;      // restart clip\n      this._loopCount = -1; // forget previous loops\n      this._startTime = null; // forget scheduling\n\n      return this.stopFading().stopWarping();\n\n    },\n\n    isRunning: function() {\n\n      return this.enabled && ! this.paused && this.timeScale !== 0 &&\n          this._startTime === null && this._mixer._isActiveAction( this );\n\n    },\n\n    // return true when play has been called\n    isScheduled: function() {\n\n      return this._mixer._isActiveAction( this );\n\n    },\n\n    startAt: function( time ) {\n\n      this._startTime = time;\n\n      return this;\n\n    },\n\n    setLoop: function( mode, repetitions ) {\n\n      this.loop = mode;\n      this.repetitions = repetitions;\n\n      return this;\n\n    },\n\n    // Weight\n\n    // set the weight stopping any scheduled fading\n    // although .enabled = false yields an effective weight of zero, this\n    // method does *not* change .enabled, because it would be confusing\n    setEffectiveWeight: function( weight ) {\n\n      this.weight = weight;\n\n      // note: same logic as when updated at runtime\n      this._effectiveWeight = this.enabled ? weight : 0;\n\n      return this.stopFading();\n\n    },\n\n    // return the weight considering fading and .enabled\n    getEffectiveWeight: function() {\n\n      return this._effectiveWeight;\n\n    },\n\n    fadeIn: function( duration ) {\n\n      return this._scheduleFading( duration, 0, 1 );\n\n    },\n\n    fadeOut: function( duration ) {\n\n      return this._scheduleFading( duration, 1, 0 );\n\n    },\n\n    crossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n      fadeOutAction.fadeOut( duration );\n      this.fadeIn( duration );\n\n      if( warp ) {\n\n        var fadeInDuration = this._clip.duration,\n          fadeOutDuration = fadeOutAction._clip.duration,\n\n          startEndRatio = fadeOutDuration / fadeInDuration,\n          endStartRatio = fadeInDuration / fadeOutDuration;\n\n        fadeOutAction.warp( 1.0, startEndRatio, duration );\n        this.warp( endStartRatio, 1.0, duration );\n\n      }\n\n      return this;\n\n    },\n\n    crossFadeTo: function( fadeInAction, duration, warp ) {\n\n      return fadeInAction.crossFadeFrom( this, duration, warp );\n\n    },\n\n    stopFading: function() {\n\n      var weightInterpolant = this._weightInterpolant;\n\n      if ( weightInterpolant !== null ) {\n\n        this._weightInterpolant = null;\n        this._mixer._takeBackControlInterpolant( weightInterpolant );\n\n      }\n\n      return this;\n\n    },\n\n    // Time Scale Control\n\n    // set the weight stopping any scheduled warping\n    // although .paused = true yields an effective time scale of zero, this\n    // method does *not* change .paused, because it would be confusing\n    setEffectiveTimeScale: function( timeScale ) {\n\n      this.timeScale = timeScale;\n      this._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n      return this.stopWarping();\n\n    },\n\n    // return the time scale considering warping and .paused\n    getEffectiveTimeScale: function() {\n\n      return this._effectiveTimeScale;\n\n    },\n\n    setDuration: function( duration ) {\n\n      this.timeScale = this._clip.duration / duration;\n\n      return this.stopWarping();\n\n    },\n\n    syncWith: function( action ) {\n\n      this.time = action.time;\n      this.timeScale = action.timeScale;\n\n      return this.stopWarping();\n\n    },\n\n    halt: function( duration ) {\n\n      return this.warp( this._effectiveTimeScale, 0, duration );\n\n    },\n\n    warp: function( startTimeScale, endTimeScale, duration ) {\n\n      var mixer = this._mixer, now = mixer.time,\n        interpolant = this._timeScaleInterpolant,\n\n        timeScale = this.timeScale;\n\n      if ( interpolant === null ) {\n\n        interpolant = mixer._lendControlInterpolant();\n        this._timeScaleInterpolant = interpolant;\n\n      }\n\n      var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n\n      times[ 0 ] = now;\n      times[ 1 ] = now + duration;\n\n      values[ 0 ] = startTimeScale / timeScale;\n      values[ 1 ] = endTimeScale / timeScale;\n\n      return this;\n\n    },\n\n    stopWarping: function() {\n\n      var timeScaleInterpolant = this._timeScaleInterpolant;\n\n      if ( timeScaleInterpolant !== null ) {\n\n        this._timeScaleInterpolant = null;\n        this._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n      }\n\n      return this;\n\n    },\n\n    // Object Accessors\n\n    getMixer: function() {\n\n      return this._mixer;\n\n    },\n\n    getClip: function() {\n\n      return this._clip;\n\n    },\n\n    getRoot: function() {\n\n      return this._localRoot || this._mixer._root;\n\n    },\n\n    // Interna\n\n    _update: function( time, deltaTime, timeDirection, accuIndex ) {\n      // called by the mixer\n\n      var startTime = this._startTime;\n\n      if ( startTime !== null ) {\n\n        // check for scheduled start of action\n\n        var timeRunning = ( time - startTime ) * timeDirection;\n        if ( timeRunning < 0 || timeDirection === 0 ) {\n\n          return; // yet to come / don't decide when delta = 0\n\n        }\n\n        // start\n\n        this._startTime = null; // unschedule\n        deltaTime = timeDirection * timeRunning;\n\n      }\n\n      // apply time scale and advance time\n\n      deltaTime *= this._updateTimeScale( time );\n      var clipTime = this._updateTime( deltaTime );\n\n      // note: _updateTime may disable the action resulting in\n      // an effective weight of 0\n\n      var weight = this._updateWeight( time );\n\n      if ( weight > 0 ) {\n\n        var interpolants = this._interpolants;\n        var propertyMixers = this._propertyBindings;\n\n        for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n          interpolants[ j ].evaluate( clipTime );\n          propertyMixers[ j ].accumulate( accuIndex, weight );\n\n        }\n\n      }\n\n    },\n\n    _updateWeight: function( time ) {\n\n      var weight = 0;\n\n      if ( this.enabled ) {\n\n        weight = this.weight;\n        var interpolant = this._weightInterpolant;\n\n        if ( interpolant !== null ) {\n\n          var interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n          weight *= interpolantValue;\n\n          if ( time > interpolant.parameterPositions[ 1 ] ) {\n\n            this.stopFading();\n\n            if ( interpolantValue === 0 ) {\n\n              // faded out, disable\n              this.enabled = false;\n\n            }\n\n          }\n\n        }\n\n      }\n\n      this._effectiveWeight = weight;\n      return weight;\n\n    },\n\n    _updateTimeScale: function( time ) {\n\n      var timeScale = 0;\n\n      if ( ! this.paused ) {\n\n        timeScale = this.timeScale;\n\n        var interpolant = this._timeScaleInterpolant;\n\n        if ( interpolant !== null ) {\n\n          var interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n          timeScale *= interpolantValue;\n\n          if ( time > interpolant.parameterPositions[ 1 ] ) {\n\n            this.stopWarping();\n\n            if ( timeScale === 0 ) {\n\n              // motion has halted, pause\n              this.paused = true;\n\n            } else {\n\n              // warp done - apply final time scale\n              this.timeScale = timeScale;\n\n            }\n\n          }\n\n        }\n\n      }\n\n      this._effectiveTimeScale = timeScale;\n      return timeScale;\n\n    },\n\n    _updateTime: function( deltaTime ) {\n\n      var time = this.time + deltaTime;\n\n      if ( deltaTime === 0 ) return time;\n\n      var duration = this._clip.duration,\n\n        loop = this.loop,\n        loopCount = this._loopCount;\n\n      if ( loop === LoopOnce ) {\n\n        if ( loopCount === -1 ) {\n          // just started\n\n          this._loopCount = 0;\n          this._setEndings( true, true, false );\n\n        }\n\n        handle_stop: {\n\n          if ( time >= duration ) {\n\n            time = duration;\n\n          } else if ( time < 0 ) {\n\n            time = 0;\n\n          } else break handle_stop;\n\n          if ( this.clampWhenFinished ) this.paused = true;\n          else this.enabled = false;\n\n          this._mixer.dispatchEvent( {\n            type: 'finished', action: this,\n            direction: deltaTime < 0 ? -1 : 1\n          } );\n\n        }\n\n      } else { // repetitive Repeat or PingPong\n\n        var pingPong = ( loop === LoopPingPong );\n\n        if ( loopCount === -1 ) {\n          // just started\n\n          if ( deltaTime >= 0 ) {\n\n            loopCount = 0;\n\n            this._setEndings(\n                true, this.repetitions === 0, pingPong );\n\n          } else {\n\n            // when looping in reverse direction, the initial\n            // transition through zero counts as a repetition,\n            // so leave loopCount at -1\n\n            this._setEndings(\n                this.repetitions === 0, true, pingPong );\n\n          }\n\n        }\n\n        if ( time >= duration || time < 0 ) {\n          // wrap around\n\n          var loopDelta = Math.floor( time / duration ); // signed\n          time -= duration * loopDelta;\n\n          loopCount += Math.abs( loopDelta );\n\n          var pending = this.repetitions - loopCount;\n\n          if ( pending < 0 ) {\n            // have to stop (switch state, clamp time, fire event)\n\n            if ( this.clampWhenFinished ) this.paused = true;\n            else this.enabled = false;\n\n            time = deltaTime > 0 ? duration : 0;\n\n            this._mixer.dispatchEvent( {\n              type: 'finished', action: this,\n              direction: deltaTime > 0 ? 1 : -1\n            } );\n\n          } else {\n            // keep running\n\n            if ( pending === 0 ) {\n              // entering the last round\n\n              var atStart = deltaTime < 0;\n              this._setEndings( atStart, ! atStart, pingPong );\n\n            } else {\n\n              this._setEndings( false, false, pingPong );\n\n            }\n\n            this._loopCount = loopCount;\n\n            this._mixer.dispatchEvent( {\n              type: 'loop', action: this, loopDelta: loopDelta\n            } );\n\n          }\n\n        }\n\n        if ( pingPong && ( loopCount & 1 ) === 1 ) {\n          // invert time for the \"pong round\"\n\n          this.time = time;\n          return duration - time;\n\n        }\n\n      }\n\n      this.time = time;\n      return time;\n\n    },\n\n    _setEndings: function( atStart, atEnd, pingPong ) {\n\n      var settings = this._interpolantSettings;\n\n      if ( pingPong ) {\n\n        settings.endingStart  = ZeroSlopeEnding;\n        settings.endingEnd    = ZeroSlopeEnding;\n\n      } else {\n\n        // assuming for LoopOnce atStart == atEnd == true\n\n        if ( atStart ) {\n\n          settings.endingStart = this.zeroSlopeAtStart ?\n              ZeroSlopeEnding : ZeroCurvatureEnding;\n\n        } else {\n\n          settings.endingStart = WrapAroundEnding;\n\n        }\n\n        if ( atEnd ) {\n\n          settings.endingEnd = this.zeroSlopeAtEnd ?\n              ZeroSlopeEnding : ZeroCurvatureEnding;\n\n        } else {\n\n          settings.endingEnd   = WrapAroundEnding;\n\n        }\n\n      }\n\n    },\n\n    _scheduleFading: function( duration, weightNow, weightThen ) {\n\n      var mixer = this._mixer, now = mixer.time,\n        interpolant = this._weightInterpolant;\n\n      if ( interpolant === null ) {\n\n        interpolant = mixer._lendControlInterpolant();\n        this._weightInterpolant = interpolant;\n\n      }\n\n      var times = interpolant.parameterPositions,\n        values = interpolant.sampleValues;\n\n      times[ 0 ] = now;         values[ 0 ] = weightNow;\n      times[ 1 ] = now + duration;  values[ 1 ] = weightThen;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   *\n   * Player for AnimationClips.\n   *\n   *\n   * @author Ben Houston / http://clara.io/\n   * @author David Sarno / http://lighthaus.us/\n   * @author tschw\n   */\n\n  function AnimationMixer( root ) {\n\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n\n    this.time = 0;\n\n    this.timeScale = 1.0;\n\n  }\n\n  Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {\n\n    _bindAction: function ( action, prototypeAction ) {\n\n      var root = action._localRoot || this._root,\n        tracks = action._clip.tracks,\n        nTracks = tracks.length,\n        bindings = action._propertyBindings,\n        interpolants = action._interpolants,\n        rootUuid = root.uuid,\n        bindingsByRoot = this._bindingsByRootAndName,\n        bindingsByName = bindingsByRoot[ rootUuid ];\n\n      if ( bindingsByName === undefined ) {\n\n        bindingsByName = {};\n        bindingsByRoot[ rootUuid ] = bindingsByName;\n\n      }\n\n      for ( var i = 0; i !== nTracks; ++ i ) {\n\n        var track = tracks[ i ],\n          trackName = track.name,\n          binding = bindingsByName[ trackName ];\n\n        if ( binding !== undefined ) {\n\n          bindings[ i ] = binding;\n\n        } else {\n\n          binding = bindings[ i ];\n\n          if ( binding !== undefined ) {\n\n            // existing binding, make sure the cache knows\n\n            if ( binding._cacheIndex === null ) {\n\n              ++ binding.referenceCount;\n              this._addInactiveBinding( binding, rootUuid, trackName );\n\n            }\n\n            continue;\n\n          }\n\n          var path = prototypeAction && prototypeAction.\n              _propertyBindings[ i ].binding.parsedPath;\n\n          binding = new PropertyMixer(\n            PropertyBinding.create( root, trackName, path ),\n            track.ValueTypeName, track.getValueSize() );\n\n          ++ binding.referenceCount;\n          this._addInactiveBinding( binding, rootUuid, trackName );\n\n          bindings[ i ] = binding;\n\n        }\n\n        interpolants[ i ].resultBuffer = binding.buffer;\n\n      }\n\n    },\n\n    _activateAction: function ( action ) {\n\n      if ( ! this._isActiveAction( action ) ) {\n\n        if ( action._cacheIndex === null ) {\n\n          // this action has been forgotten by the cache, but the user\n          // appears to be still using it -> rebind\n\n          var rootUuid = ( action._localRoot || this._root ).uuid,\n            clipUuid = action._clip.uuid,\n            actionsForClip = this._actionsByClip[ clipUuid ];\n\n          this._bindAction( action,\n            actionsForClip && actionsForClip.knownActions[ 0 ] );\n\n          this._addInactiveAction( action, clipUuid, rootUuid );\n\n        }\n\n        var bindings = action._propertyBindings;\n\n        // increment reference counts / sort out state\n        for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n          var binding = bindings[ i ];\n\n          if ( binding.useCount ++ === 0 ) {\n\n            this._lendBinding( binding );\n            binding.saveOriginalState();\n\n          }\n\n        }\n\n        this._lendAction( action );\n\n      }\n\n    },\n\n    _deactivateAction: function ( action ) {\n\n      if ( this._isActiveAction( action ) ) {\n\n        var bindings = action._propertyBindings;\n\n        // decrement reference counts / sort out state\n        for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n          var binding = bindings[ i ];\n\n          if ( -- binding.useCount === 0 ) {\n\n            binding.restoreOriginalState();\n            this._takeBackBinding( binding );\n\n          }\n\n        }\n\n        this._takeBackAction( action );\n\n      }\n\n    },\n\n    // Memory manager\n\n    _initMemoryManager: function () {\n\n      this._actions = []; // 'nActiveActions' followed by inactive ones\n      this._nActiveActions = 0;\n\n      this._actionsByClip = {};\n      // inside:\n      // {\n      //    knownActions: Array< AnimationAction >  - used as prototypes\n      //    actionByRoot: AnimationAction     - lookup\n      // }\n\n\n      this._bindings = []; // 'nActiveBindings' followed by inactive ones\n      this._nActiveBindings = 0;\n\n      this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n      this._controlInterpolants = []; // same game as above\n      this._nActiveControlInterpolants = 0;\n\n      var scope = this;\n\n      this.stats = {\n\n        actions: {\n          get total() { return scope._actions.length; },\n          get inUse() { return scope._nActiveActions; }\n        },\n        bindings: {\n          get total() { return scope._bindings.length; },\n          get inUse() { return scope._nActiveBindings; }\n        },\n        controlInterpolants: {\n          get total() { return scope._controlInterpolants.length; },\n          get inUse() { return scope._nActiveControlInterpolants; }\n        }\n\n      };\n\n    },\n\n    // Memory management for AnimationAction objects\n\n    _isActiveAction: function ( action ) {\n\n      var index = action._cacheIndex;\n      return index !== null && index < this._nActiveActions;\n\n    },\n\n    _addInactiveAction: function ( action, clipUuid, rootUuid ) {\n\n      var actions = this._actions,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[ clipUuid ];\n\n      if ( actionsForClip === undefined ) {\n\n        actionsForClip = {\n\n          knownActions: [ action ],\n          actionByRoot: {}\n\n        };\n\n        action._byClipCacheIndex = 0;\n\n        actionsByClip[ clipUuid ] = actionsForClip;\n\n      } else {\n\n        var knownActions = actionsForClip.knownActions;\n\n        action._byClipCacheIndex = knownActions.length;\n        knownActions.push( action );\n\n      }\n\n      action._cacheIndex = actions.length;\n      actions.push( action );\n\n      actionsForClip.actionByRoot[ rootUuid ] = action;\n\n    },\n\n    _removeInactiveAction: function ( action ) {\n\n      var actions = this._actions,\n        lastInactiveAction = actions[ actions.length - 1 ],\n        cacheIndex = action._cacheIndex;\n\n      lastInactiveAction._cacheIndex = cacheIndex;\n      actions[ cacheIndex ] = lastInactiveAction;\n      actions.pop();\n\n      action._cacheIndex = null;\n\n\n      var clipUuid = action._clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[ clipUuid ],\n        knownActionsForClip = actionsForClip.knownActions,\n\n        lastKnownAction =\n          knownActionsForClip[ knownActionsForClip.length - 1 ],\n\n        byClipCacheIndex = action._byClipCacheIndex;\n\n      lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n      knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n      knownActionsForClip.pop();\n\n      action._byClipCacheIndex = null;\n\n\n      var actionByRoot = actionsForClip.actionByRoot,\n        rootUuid = ( action._localRoot || this._root ).uuid;\n\n      delete actionByRoot[ rootUuid ];\n\n      if ( knownActionsForClip.length === 0 ) {\n\n        delete actionsByClip[ clipUuid ];\n\n      }\n\n      this._removeInactiveBindingsForAction( action );\n\n    },\n\n    _removeInactiveBindingsForAction: function ( action ) {\n\n      var bindings = action._propertyBindings;\n      for ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n        var binding = bindings[ i ];\n\n        if ( -- binding.referenceCount === 0 ) {\n\n          this._removeInactiveBinding( binding );\n\n        }\n\n      }\n\n    },\n\n    _lendAction: function ( action ) {\n\n      // [ active actions |  inactive actions  ]\n      // [  active actions >| inactive actions ]\n      //                 s        a\n      //                  <-swap->\n      //                 a        s\n\n      var actions = this._actions,\n        prevIndex = action._cacheIndex,\n\n        lastActiveIndex = this._nActiveActions ++,\n\n        firstInactiveAction = actions[ lastActiveIndex ];\n\n      action._cacheIndex = lastActiveIndex;\n      actions[ lastActiveIndex ] = action;\n\n      firstInactiveAction._cacheIndex = prevIndex;\n      actions[ prevIndex ] = firstInactiveAction;\n\n    },\n\n    _takeBackAction: function ( action ) {\n\n      // [  active actions  | inactive actions ]\n      // [ active actions |< inactive actions  ]\n      //        a        s\n      //         <-swap->\n      //        s        a\n\n      var actions = this._actions,\n        prevIndex = action._cacheIndex,\n\n        firstInactiveIndex = -- this._nActiveActions,\n\n        lastActiveAction = actions[ firstInactiveIndex ];\n\n      action._cacheIndex = firstInactiveIndex;\n      actions[ firstInactiveIndex ] = action;\n\n      lastActiveAction._cacheIndex = prevIndex;\n      actions[ prevIndex ] = lastActiveAction;\n\n    },\n\n    // Memory management for PropertyMixer objects\n\n    _addInactiveBinding: function ( binding, rootUuid, trackName ) {\n\n      var bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[ rootUuid ],\n\n        bindings = this._bindings;\n\n      if ( bindingByName === undefined ) {\n\n        bindingByName = {};\n        bindingsByRoot[ rootUuid ] = bindingByName;\n\n      }\n\n      bindingByName[ trackName ] = binding;\n\n      binding._cacheIndex = bindings.length;\n      bindings.push( binding );\n\n    },\n\n    _removeInactiveBinding: function ( binding ) {\n\n      var bindings = this._bindings,\n        propBinding = binding.binding,\n        rootUuid = propBinding.rootNode.uuid,\n        trackName = propBinding.path,\n        bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[ rootUuid ],\n\n        lastInactiveBinding = bindings[ bindings.length - 1 ],\n        cacheIndex = binding._cacheIndex;\n\n      lastInactiveBinding._cacheIndex = cacheIndex;\n      bindings[ cacheIndex ] = lastInactiveBinding;\n      bindings.pop();\n\n      delete bindingByName[ trackName ];\n\n      remove_empty_map: {\n\n        for ( var _ in bindingByName ) break remove_empty_map;\n\n        delete bindingsByRoot[ rootUuid ];\n\n      }\n\n    },\n\n    _lendBinding: function ( binding ) {\n\n      var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n\n        lastActiveIndex = this._nActiveBindings ++,\n\n        firstInactiveBinding = bindings[ lastActiveIndex ];\n\n      binding._cacheIndex = lastActiveIndex;\n      bindings[ lastActiveIndex ] = binding;\n\n      firstInactiveBinding._cacheIndex = prevIndex;\n      bindings[ prevIndex ] = firstInactiveBinding;\n\n    },\n\n    _takeBackBinding: function ( binding ) {\n\n      var bindings = this._bindings,\n        prevIndex = binding._cacheIndex,\n\n        firstInactiveIndex = -- this._nActiveBindings,\n\n        lastActiveBinding = bindings[ firstInactiveIndex ];\n\n      binding._cacheIndex = firstInactiveIndex;\n      bindings[ firstInactiveIndex ] = binding;\n\n      lastActiveBinding._cacheIndex = prevIndex;\n      bindings[ prevIndex ] = lastActiveBinding;\n\n    },\n\n\n    // Memory management of Interpolants for weight and time scale\n\n    _lendControlInterpolant: function () {\n\n      var interpolants = this._controlInterpolants,\n        lastActiveIndex = this._nActiveControlInterpolants ++,\n        interpolant = interpolants[ lastActiveIndex ];\n\n      if ( interpolant === undefined ) {\n\n        interpolant = new LinearInterpolant(\n          new Float32Array( 2 ), new Float32Array( 2 ),\n          1, this._controlInterpolantsResultBuffer );\n\n        interpolant.__cacheIndex = lastActiveIndex;\n        interpolants[ lastActiveIndex ] = interpolant;\n\n      }\n\n      return interpolant;\n\n    },\n\n    _takeBackControlInterpolant: function ( interpolant ) {\n\n      var interpolants = this._controlInterpolants,\n        prevIndex = interpolant.__cacheIndex,\n\n        firstInactiveIndex = -- this._nActiveControlInterpolants,\n\n        lastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n      interpolant.__cacheIndex = firstInactiveIndex;\n      interpolants[ firstInactiveIndex ] = interpolant;\n\n      lastActiveInterpolant.__cacheIndex = prevIndex;\n      interpolants[ prevIndex ] = lastActiveInterpolant;\n\n    },\n\n    _controlInterpolantsResultBuffer: new Float32Array( 1 ),\n\n    // return an action for a clip optionally using a custom root target\n    // object (this method allocates a lot of dynamic memory in case a\n    // previously unknown clip/root combination is specified)\n    clipAction: function ( clip, optionalRoot ) {\n\n      var root = optionalRoot || this._root,\n        rootUuid = root.uuid,\n\n        clipObject = typeof clip === 'string' ?\n          AnimationClip.findByName( root, clip ) : clip,\n\n        clipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n        actionsForClip = this._actionsByClip[ clipUuid ],\n        prototypeAction = null;\n\n      if ( actionsForClip !== undefined ) {\n\n        var existingAction =\n            actionsForClip.actionByRoot[ rootUuid ];\n\n        if ( existingAction !== undefined ) {\n\n          return existingAction;\n\n        }\n\n        // we know the clip, so we don't have to parse all\n        // the bindings again but can just copy\n        prototypeAction = actionsForClip.knownActions[ 0 ];\n\n        // also, take the clip from the prototype action\n        if ( clipObject === null )\n          clipObject = prototypeAction._clip;\n\n      }\n\n      // clip must be known when specified via string\n      if ( clipObject === null ) return null;\n\n      // allocate all resources required to run it\n      var newAction = new AnimationAction( this, clipObject, optionalRoot );\n\n      this._bindAction( newAction, prototypeAction );\n\n      // and make the action known to the memory manager\n      this._addInactiveAction( newAction, clipUuid, rootUuid );\n\n      return newAction;\n\n    },\n\n    // get an existing action\n    existingAction: function ( clip, optionalRoot ) {\n\n      var root = optionalRoot || this._root,\n        rootUuid = root.uuid,\n\n        clipObject = typeof clip === 'string' ?\n          AnimationClip.findByName( root, clip ) : clip,\n\n        clipUuid = clipObject ? clipObject.uuid : clip,\n\n        actionsForClip = this._actionsByClip[ clipUuid ];\n\n      if ( actionsForClip !== undefined ) {\n\n        return actionsForClip.actionByRoot[ rootUuid ] || null;\n\n      }\n\n      return null;\n\n    },\n\n    // deactivates all previously scheduled actions\n    stopAllAction: function () {\n\n      var actions = this._actions,\n        nActions = this._nActiveActions,\n        bindings = this._bindings,\n        nBindings = this._nActiveBindings;\n\n      this._nActiveActions = 0;\n      this._nActiveBindings = 0;\n\n      for ( var i = 0; i !== nActions; ++ i ) {\n\n        actions[ i ].reset();\n\n      }\n\n      for ( var i = 0; i !== nBindings; ++ i ) {\n\n        bindings[ i ].useCount = 0;\n\n      }\n\n      return this;\n\n    },\n\n    // advance the time and update apply the animation\n    update: function ( deltaTime ) {\n\n      deltaTime *= this.timeScale;\n\n      var actions = this._actions,\n        nActions = this._nActiveActions,\n\n        time = this.time += deltaTime,\n        timeDirection = Math.sign( deltaTime ),\n\n        accuIndex = this._accuIndex ^= 1;\n\n      // run active actions\n\n      for ( var i = 0; i !== nActions; ++ i ) {\n\n        var action = actions[ i ];\n\n        if ( action.enabled ) {\n\n          action._update( time, deltaTime, timeDirection, accuIndex );\n\n        }\n\n      }\n\n      // update scene graph\n\n      var bindings = this._bindings,\n        nBindings = this._nActiveBindings;\n\n      for ( var i = 0; i !== nBindings; ++ i ) {\n\n        bindings[ i ].apply( accuIndex );\n\n      }\n\n      return this;\n\n    },\n\n    // return this mixer's root target object\n    getRoot: function () {\n\n      return this._root;\n\n    },\n\n    // free all resources specific to a particular clip\n    uncacheClip: function ( clip ) {\n\n      var actions = this._actions,\n        clipUuid = clip.uuid,\n        actionsByClip = this._actionsByClip,\n        actionsForClip = actionsByClip[ clipUuid ];\n\n      if ( actionsForClip !== undefined ) {\n\n        // note: just calling _removeInactiveAction would mess up the\n        // iteration state and also require updating the state we can\n        // just throw away\n\n        var actionsToRemove = actionsForClip.knownActions;\n\n        for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n          var action = actionsToRemove[ i ];\n\n          this._deactivateAction( action );\n\n          var cacheIndex = action._cacheIndex,\n            lastInactiveAction = actions[ actions.length - 1 ];\n\n          action._cacheIndex = null;\n          action._byClipCacheIndex = null;\n\n          lastInactiveAction._cacheIndex = cacheIndex;\n          actions[ cacheIndex ] = lastInactiveAction;\n          actions.pop();\n\n          this._removeInactiveBindingsForAction( action );\n\n        }\n\n        delete actionsByClip[ clipUuid ];\n\n      }\n\n    },\n\n    // free all resources specific to a particular root target object\n    uncacheRoot: function ( root ) {\n\n      var rootUuid = root.uuid,\n        actionsByClip = this._actionsByClip;\n\n      for ( var clipUuid in actionsByClip ) {\n\n        var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n          action = actionByRoot[ rootUuid ];\n\n        if ( action !== undefined ) {\n\n          this._deactivateAction( action );\n          this._removeInactiveAction( action );\n\n        }\n\n      }\n\n      var bindingsByRoot = this._bindingsByRootAndName,\n        bindingByName = bindingsByRoot[ rootUuid ];\n\n      if ( bindingByName !== undefined ) {\n\n        for ( var trackName in bindingByName ) {\n\n          var binding = bindingByName[ trackName ];\n          binding.restoreOriginalState();\n          this._removeInactiveBinding( binding );\n\n        }\n\n      }\n\n    },\n\n    // remove a targeted clip from the cache\n    uncacheAction: function ( clip, optionalRoot ) {\n\n      var action = this.existingAction( clip, optionalRoot );\n\n      if ( action !== null ) {\n\n        this._deactivateAction( action );\n        this._removeInactiveAction( action );\n\n      }\n\n    }\n\n  } );\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Uniform( value ) {\n\n    if ( typeof value === 'string' ) {\n\n      console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n      value = arguments[ 1 ];\n\n    }\n\n    this.value = value;\n\n  }\n\n  Uniform.prototype.clone = function () {\n\n    return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n  };\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   */\n\n  function InstancedBufferGeometry() {\n\n    BufferGeometry.call( this );\n\n    this.type = 'InstancedBufferGeometry';\n    this.maxInstancedCount = undefined;\n\n  }\n\n  InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\n  InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;\n\n  InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n  InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {\n\n    this.groups.push( {\n\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n\n    } );\n\n  };\n\n  InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n    var index = source.index;\n\n    if ( index !== null ) {\n\n      this.setIndex( index.clone() );\n\n    }\n\n    var attributes = source.attributes;\n\n    for ( var name in attributes ) {\n\n      var attribute = attributes[ name ];\n      this.addAttribute( name, attribute.clone() );\n\n    }\n\n    var groups = source.groups;\n\n    for ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n      var group = groups[ i ];\n      this.addGroup( group.start, group.count, group.materialIndex );\n\n    }\n\n    return this;\n\n  };\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   */\n\n  function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\n\n    this.uuid = _Math.generateUUID();\n\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n\n    this.normalized = normalized === true;\n\n  }\n\n  Object.defineProperties( InterleavedBufferAttribute.prototype, {\n\n    \"count\" : {\n\n      get: function () {\n\n        return this.data.count;\n\n      }\n\n    },\n\n    \"array\" : {\n\n      get: function () {\n\n        return this.data.array;\n\n      }\n\n    }\n\n  } );\n\n  Object.assign( InterleavedBufferAttribute.prototype, {\n\n    isInterleavedBufferAttribute: true,\n\n    setX: function ( index, x ) {\n\n      this.data.array[ index * this.data.stride + this.offset ] = x;\n\n      return this;\n\n    },\n\n    setY: function ( index, y ) {\n\n      this.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n      return this;\n\n    },\n\n    setZ: function ( index, z ) {\n\n      this.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n      return this;\n\n    },\n\n    setW: function ( index, w ) {\n\n      this.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n      return this;\n\n    },\n\n    getX: function ( index ) {\n\n      return this.data.array[ index * this.data.stride + this.offset ];\n\n    },\n\n    getY: function ( index ) {\n\n      return this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n    },\n\n    getZ: function ( index ) {\n\n      return this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n    },\n\n    getW: function ( index ) {\n\n      return this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n    },\n\n    setXY: function ( index, x, y ) {\n\n      index = index * this.data.stride + this.offset;\n\n      this.data.array[ index + 0 ] = x;\n      this.data.array[ index + 1 ] = y;\n\n      return this;\n\n    },\n\n    setXYZ: function ( index, x, y, z ) {\n\n      index = index * this.data.stride + this.offset;\n\n      this.data.array[ index + 0 ] = x;\n      this.data.array[ index + 1 ] = y;\n      this.data.array[ index + 2 ] = z;\n\n      return this;\n\n    },\n\n    setXYZW: function ( index, x, y, z, w ) {\n\n      index = index * this.data.stride + this.offset;\n\n      this.data.array[ index + 0 ] = x;\n      this.data.array[ index + 1 ] = y;\n      this.data.array[ index + 2 ] = z;\n      this.data.array[ index + 3 ] = w;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   */\n\n  function InterleavedBuffer( array, stride ) {\n\n    this.uuid = _Math.generateUUID();\n\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n\n    this.dynamic = false;\n    this.updateRange = { offset: 0, count: - 1 };\n\n    this.onUploadCallback = function () {};\n\n    this.version = 0;\n\n  }\n\n  Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\n\n    set: function ( value ) {\n\n      if ( value === true ) this.version ++;\n\n    }\n\n  } );\n\n  Object.assign( InterleavedBuffer.prototype, {\n\n    isInterleavedBuffer: true,\n\n    setArray: function ( array ) {\n\n      if ( Array.isArray( array ) ) {\n\n        throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n      }\n\n      this.count = array !== undefined ? array.length / this.stride : 0;\n      this.array = array;\n\n    },\n\n    setDynamic: function ( value ) {\n\n      this.dynamic = value;\n\n      return this;\n\n    },\n\n    copy: function ( source ) {\n\n      this.array = new source.array.constructor( source.array );\n      this.count = source.count;\n      this.stride = source.stride;\n      this.dynamic = source.dynamic;\n\n      return this;\n\n    },\n\n    copyAt: function ( index1, attribute, index2 ) {\n\n      index1 *= this.stride;\n      index2 *= attribute.stride;\n\n      for ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n        this.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n      }\n\n      return this;\n\n    },\n\n    set: function ( value, offset ) {\n\n      if ( offset === undefined ) offset = 0;\n\n      this.array.set( value, offset );\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    onUpload: function ( callback ) {\n\n      this.onUploadCallback = callback;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   */\n\n  function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\n\n    InterleavedBuffer.call( this, array, stride );\n\n    this.meshPerAttribute = meshPerAttribute || 1;\n\n  }\n\n  InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );\n  InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;\n\n  InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n  InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n    InterleavedBuffer.prototype.copy.call( this, source );\n\n    this.meshPerAttribute = source.meshPerAttribute;\n\n    return this;\n\n  };\n\n  /**\n   * @author benaadams / https://twitter.com/ben_a_adams\n   */\n\n  function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\n\n    BufferAttribute.call( this, array, itemSize );\n\n    this.meshPerAttribute = meshPerAttribute || 1;\n\n  }\n\n  InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\n  InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;\n\n  InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n  InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n    BufferAttribute.prototype.copy.call( this, source );\n\n    this.meshPerAttribute = source.meshPerAttribute;\n\n    return this;\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author bhouston / http://clara.io/\n   * @author stephomi / http://stephaneginier.com/\n   */\n\n  function Raycaster( origin, direction, near, far ) {\n\n    this.ray = new Ray( origin, direction );\n    // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near || 0;\n    this.far = far || Infinity;\n\n    this.params = {\n      Mesh: {},\n      Line: {},\n      LOD: {},\n      Points: { threshold: 1 },\n      Sprite: {}\n    };\n\n    Object.defineProperties( this.params, {\n      PointCloud: {\n        get: function () {\n          console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n          return this.Points;\n        }\n      }\n    } );\n\n  }\n\n  function ascSort( a, b ) {\n\n    return a.distance - b.distance;\n\n  }\n\n  function intersectObject( object, raycaster, intersects, recursive ) {\n\n    if ( object.visible === false ) return;\n\n    object.raycast( raycaster, intersects );\n\n    if ( recursive === true ) {\n\n      var children = object.children;\n\n      for ( var i = 0, l = children.length; i < l; i ++ ) {\n\n        intersectObject( children[ i ], raycaster, intersects, true );\n\n      }\n\n    }\n\n  }\n\n  Object.assign( Raycaster.prototype, {\n\n    linePrecision: 1,\n\n    set: function ( origin, direction ) {\n\n      // direction is assumed to be normalized (for accurate distance calculations)\n\n      this.ray.set( origin, direction );\n\n    },\n\n    setFromCamera: function ( coords, camera ) {\n\n      if ( (camera && camera.isPerspectiveCamera) ) {\n\n        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n      } else if ( (camera && camera.isOrthographicCamera) ) {\n\n        this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n      } else {\n\n        console.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n      }\n\n    },\n\n    intersectObject: function ( object, recursive ) {\n\n      var intersects = [];\n\n      intersectObject( object, this, intersects, recursive );\n\n      intersects.sort( ascSort );\n\n      return intersects;\n\n    },\n\n    intersectObjects: function ( objects, recursive ) {\n\n      var intersects = [];\n\n      if ( Array.isArray( objects ) === false ) {\n\n        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n        return intersects;\n\n      }\n\n      for ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n        intersectObject( objects[ i ], this, intersects, recursive );\n\n      }\n\n      intersects.sort( ascSort );\n\n      return intersects;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function Clock( autoStart ) {\n\n    this.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n\n    this.running = false;\n\n  }\n\n  Object.assign( Clock.prototype, {\n\n    start: function () {\n\n      this.startTime = ( performance || Date ).now();\n\n      this.oldTime = this.startTime;\n      this.elapsedTime = 0;\n      this.running = true;\n\n    },\n\n    stop: function () {\n\n      this.getElapsedTime();\n      this.running = false;\n\n    },\n\n    getElapsedTime: function () {\n\n      this.getDelta();\n      return this.elapsedTime;\n\n    },\n\n    getDelta: function () {\n\n      var diff = 0;\n\n      if ( this.autoStart && ! this.running ) {\n\n        this.start();\n\n      }\n\n      if ( this.running ) {\n\n        var newTime = ( performance || Date ).now();\n\n        diff = ( newTime - this.oldTime ) / 1000;\n        this.oldTime = newTime;\n\n        this.elapsedTime += diff;\n\n      }\n\n      return diff;\n\n    }\n\n  } );\n\n  /**\n   * @author bhouston / http://clara.io\n   * @author WestLangley / http://github.com/WestLangley\n   *\n   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n   *\n   * The poles (phi) are at the positive and negative y axis.\n   * The equator starts at positive z.\n   */\n\n  function Spherical( radius, phi, theta ) {\n\n    this.radius = ( radius !== undefined ) ? radius : 1.0;\n    this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n    this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n    return this;\n\n  }\n\n  Object.assign( Spherical.prototype, {\n\n    set: function ( radius, phi, theta ) {\n\n      this.radius = radius;\n      this.phi = phi;\n      this.theta = theta;\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( other ) {\n\n      this.radius = other.radius;\n      this.phi = other.phi;\n      this.theta = other.theta;\n\n      return this;\n\n    },\n\n    // restrict phi to be betwee EPS and PI-EPS\n    makeSafe: function() {\n\n      var EPS = 0.000001;\n      this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n      return this;\n\n    },\n\n    setFromVector3: function( vec3 ) {\n\n      this.radius = vec3.length();\n\n      if ( this.radius === 0 ) {\n\n        this.theta = 0;\n        this.phi = 0;\n\n      } else {\n\n        this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n        this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n      }\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author Mugen87 / https://github.com/Mugen87\n   *\n   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n   *\n   */\n\n  function Cylindrical( radius, theta, y ) {\n\n    this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\n    this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n    this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\n\n    return this;\n\n  }\n\n  Object.assign( Cylindrical.prototype, {\n\n    set: function ( radius, theta, y ) {\n\n      this.radius = radius;\n      this.theta = theta;\n      this.y = y;\n\n      return this;\n\n    },\n\n    clone: function () {\n\n      return new this.constructor().copy( this );\n\n    },\n\n    copy: function ( other ) {\n\n      this.radius = other.radius;\n      this.theta = other.theta;\n      this.y = other.y;\n\n      return this;\n\n    },\n\n    setFromVector3: function( vec3 ) {\n\n      this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\n      this.theta = Math.atan2( vec3.x, vec3.z );\n      this.y = vec3.y;\n\n      return this;\n\n    }\n\n  } );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function MorphBlendMesh( geometry, material ) {\n\n    Mesh.call( this, geometry, material );\n\n    this.animationsMap = {};\n    this.animationsList = [];\n\n    // prepare default animation\n    // (all frames played together in 1 second)\n\n    var numFrames = this.geometry.morphTargets.length;\n\n    var name = \"__default\";\n\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n\n    var fps = numFrames / 1;\n\n    this.createAnimation( name, startFrame, endFrame, fps );\n    this.setAnimationWeight( name, 1 );\n\n  }\n\n  MorphBlendMesh.prototype = Object.create( Mesh.prototype );\n  MorphBlendMesh.prototype.constructor = MorphBlendMesh;\n\n  MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n    var animation = {\n\n      start: start,\n      end: end,\n\n      length: end - start + 1,\n\n      fps: fps,\n      duration: ( end - start ) / fps,\n\n      lastFrame: 0,\n      currentFrame: 0,\n\n      active: false,\n\n      time: 0,\n      direction: 1,\n      weight: 1,\n\n      directionBackwards: false,\n      mirroredLoop: false\n\n    };\n\n    this.animationsMap[ name ] = animation;\n    this.animationsList.push( animation );\n\n  };\n\n  MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n    var pattern = /([a-z]+)_?(\\d+)/i;\n\n    var firstAnimation, frameRanges = {};\n\n    var geometry = this.geometry;\n\n    for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n      var morph = geometry.morphTargets[ i ];\n      var chunks = morph.name.match( pattern );\n\n      if ( chunks && chunks.length > 1 ) {\n\n        var name = chunks[ 1 ];\n\n        if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n        var range = frameRanges[ name ];\n\n        if ( i < range.start ) range.start = i;\n        if ( i > range.end ) range.end = i;\n\n        if ( ! firstAnimation ) firstAnimation = name;\n\n      }\n\n    }\n\n    for ( var name in frameRanges ) {\n\n      var range = frameRanges[ name ];\n      this.createAnimation( name, range.start, range.end, fps );\n\n    }\n\n    this.firstAnimation = firstAnimation;\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.direction = 1;\n      animation.directionBackwards = false;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.direction = - 1;\n      animation.directionBackwards = true;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.fps = fps;\n      animation.duration = ( animation.end - animation.start ) / animation.fps;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.duration = duration;\n      animation.fps = ( animation.end - animation.start ) / animation.duration;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.weight = weight;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.time = time;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n    var time = 0;\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      time = animation.time;\n\n    }\n\n    return time;\n\n  };\n\n  MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n    var duration = - 1;\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      duration = animation.duration;\n\n    }\n\n    return duration;\n\n  };\n\n  MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.time = 0;\n      animation.active = true;\n\n    } else {\n\n      console.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n    var animation = this.animationsMap[ name ];\n\n    if ( animation ) {\n\n      animation.active = false;\n\n    }\n\n  };\n\n  MorphBlendMesh.prototype.update = function ( delta ) {\n\n    for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n      var animation = this.animationsList[ i ];\n\n      if ( ! animation.active ) continue;\n\n      var frameTime = animation.duration / animation.length;\n\n      animation.time += animation.direction * delta;\n\n      if ( animation.mirroredLoop ) {\n\n        if ( animation.time > animation.duration || animation.time < 0 ) {\n\n          animation.direction *= - 1;\n\n          if ( animation.time > animation.duration ) {\n\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n\n          }\n\n          if ( animation.time < 0 ) {\n\n            animation.time = 0;\n            animation.directionBackwards = false;\n\n          }\n\n        }\n\n      } else {\n\n        animation.time = animation.time % animation.duration;\n\n        if ( animation.time < 0 ) animation.time += animation.duration;\n\n      }\n\n      var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n      var weight = animation.weight;\n\n      if ( keyframe !== animation.currentFrame ) {\n\n        this.morphTargetInfluences[ animation.lastFrame ] = 0;\n        this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n        this.morphTargetInfluences[ keyframe ] = 0;\n\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n\n      }\n\n      var mix = ( animation.time % frameTime ) / frameTime;\n\n      if ( animation.directionBackwards ) mix = 1 - mix;\n\n      if ( animation.currentFrame !== animation.lastFrame ) {\n\n        this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n        this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n      } else {\n\n        this.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n      }\n\n    }\n\n  };\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  function ImmediateRenderObject( material ) {\n\n    Object3D.call( this );\n\n    this.material = material;\n    this.render = function ( renderCallback ) {};\n\n  }\n\n  ImmediateRenderObject.prototype = Object.create( Object3D.prototype );\n  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\n\n  ImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n  */\n\n  function VertexNormalsHelper( object, size, hex, linewidth ) {\n\n    this.object = object;\n\n    this.size = ( size !== undefined ) ? size : 1;\n\n    var color = ( hex !== undefined ) ? hex : 0xff0000;\n\n    var width = ( linewidth !== undefined ) ? linewidth : 1;\n\n    //\n\n    var nNormals = 0;\n\n    var objGeometry = this.object.geometry;\n\n    if ( objGeometry && objGeometry.isGeometry ) {\n\n      nNormals = objGeometry.faces.length * 3;\n\n    } else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n      nNormals = objGeometry.attributes.normal.count;\n\n    }\n\n    //\n\n    var geometry = new BufferGeometry();\n\n    var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n    geometry.addAttribute( 'position', positions );\n\n    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n    //\n\n    this.matrixAutoUpdate = false;\n\n    this.update();\n\n  }\n\n  VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\n  VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\n  VertexNormalsHelper.prototype.update = ( function () {\n\n    var v1 = new Vector3();\n    var v2 = new Vector3();\n    var normalMatrix = new Matrix3();\n\n    return function update() {\n\n      var keys = [ 'a', 'b', 'c' ];\n\n      this.object.updateMatrixWorld( true );\n\n      normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n      var matrixWorld = this.object.matrixWorld;\n\n      var position = this.geometry.attributes.position;\n\n      //\n\n      var objGeometry = this.object.geometry;\n\n      if ( objGeometry && objGeometry.isGeometry ) {\n\n        var vertices = objGeometry.vertices;\n\n        var faces = objGeometry.faces;\n\n        var idx = 0;\n\n        for ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n          var face = faces[ i ];\n\n          for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n            var vertex = vertices[ face[ keys[ j ] ] ];\n\n            var normal = face.vertexNormals[ j ];\n\n            v1.copy( vertex ).applyMatrix4( matrixWorld );\n\n            v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n            position.setXYZ( idx, v1.x, v1.y, v1.z );\n\n            idx = idx + 1;\n\n            position.setXYZ( idx, v2.x, v2.y, v2.z );\n\n            idx = idx + 1;\n\n          }\n\n        }\n\n      } else if ( objGeometry && objGeometry.isBufferGeometry ) {\n\n        var objPos = objGeometry.attributes.position;\n\n        var objNorm = objGeometry.attributes.normal;\n\n        var idx = 0;\n\n        // for simplicity, ignore index and drawcalls, and render every normal\n\n        for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n          v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n          v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n          v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n          position.setXYZ( idx, v1.x, v1.y, v1.z );\n\n          idx = idx + 1;\n\n          position.setXYZ( idx, v2.x, v2.y, v2.z );\n\n          idx = idx + 1;\n\n        }\n\n      }\n\n      position.needsUpdate = true;\n\n      return this;\n\n    };\n\n  }() );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n  */\n\n  function SpotLightHelper( light ) {\n\n    Object3D.call( this );\n\n    this.light = light;\n    this.light.updateMatrixWorld();\n\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    var geometry = new BufferGeometry();\n\n    var positions = [\n      0, 0, 0,   0,   0,   1,\n      0, 0, 0,   1,   0,   1,\n      0, 0, 0, - 1,   0,   1,\n      0, 0, 0,   0,   1,   1,\n      0, 0, 0,   0, - 1,   1\n    ];\n\n    for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n      var p1 = ( i / l ) * Math.PI * 2;\n      var p2 = ( j / l ) * Math.PI * 2;\n\n      positions.push(\n        Math.cos( p1 ), Math.sin( p1 ), 1,\n        Math.cos( p2 ), Math.sin( p2 ), 1\n      );\n\n    }\n\n    geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n    var material = new LineBasicMaterial( { fog: false } );\n\n    this.cone = new LineSegments( geometry, material );\n    this.add( this.cone );\n\n    this.update();\n\n  }\n\n  SpotLightHelper.prototype = Object.create( Object3D.prototype );\n  SpotLightHelper.prototype.constructor = SpotLightHelper;\n\n  SpotLightHelper.prototype.dispose = function () {\n\n    this.cone.geometry.dispose();\n    this.cone.material.dispose();\n\n  };\n\n  SpotLightHelper.prototype.update = function () {\n\n    var vector = new Vector3();\n    var vector2 = new Vector3();\n\n    return function update() {\n\n      var coneLength = this.light.distance ? this.light.distance : 1000;\n      var coneWidth = coneLength * Math.tan( this.light.angle );\n\n      this.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n      vector.setFromMatrixPosition( this.light.matrixWorld );\n      vector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n      this.cone.lookAt( vector2.sub( vector ) );\n\n      this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n    };\n\n  }();\n\n  /**\n   * @author Sean Griffin / http://twitter.com/sgrif\n   * @author Michael Guerrero / http://realitymeltdown.com\n   * @author mrdoob / http://mrdoob.com/\n   * @author ikerr / http://verold.com\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function SkeletonHelper( object ) {\n\n    this.bones = this.getBoneList( object );\n\n    var geometry = new BufferGeometry();\n\n    var vertices = [];\n    var colors = [];\n\n    var color1 = new Color( 0, 0, 1 );\n    var color2 = new Color( 0, 1, 0 );\n\n    for ( var i = 0; i < this.bones.length; i ++ ) {\n\n      var bone = this.bones[ i ];\n\n      if ( bone.parent && bone.parent.isBone ) {\n\n        vertices.push( 0, 0, 0 );\n        vertices.push( 0, 0, 0 );\n        colors.push( color1.r, color1.g, color1.b );\n        colors.push( color2.r, color2.g, color2.b );\n\n      }\n\n    }\n\n    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n    var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n    LineSegments.call( this, geometry, material );\n\n    this.root = object;\n\n    this.matrix = object.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    this.update();\n\n  }\n\n\n  SkeletonHelper.prototype = Object.create( LineSegments.prototype );\n  SkeletonHelper.prototype.constructor = SkeletonHelper;\n\n  SkeletonHelper.prototype.getBoneList = function( object ) {\n\n    var boneList = [];\n\n    if ( object && object.isBone ) {\n\n      boneList.push( object );\n\n    }\n\n    for ( var i = 0; i < object.children.length; i ++ ) {\n\n      boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n    }\n\n    return boneList;\n\n  };\n\n  SkeletonHelper.prototype.update = function () {\n\n    var vector = new Vector3();\n\n    var boneMatrix = new Matrix4();\n    var matrixWorldInv = new Matrix4();\n\n    return function update() {\n\n      var geometry = this.geometry;\n      var position = geometry.getAttribute( 'position' );\n\n      matrixWorldInv.getInverse( this.root.matrixWorld );\n\n      for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {\n\n        var bone = this.bones[ i ];\n\n        if ( bone.parent && bone.parent.isBone ) {\n\n          boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n          vector.setFromMatrixPosition( boneMatrix );\n          position.setXYZ( j, vector.x, vector.y, vector.z );\n\n          boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n          vector.setFromMatrixPosition( boneMatrix );\n          position.setXYZ( j + 1, vector.x, vector.y, vector.z );\n\n          j += 2;\n\n        }\n\n      }\n\n      geometry.getAttribute( 'position' ).needsUpdate = true;\n\n    };\n\n  }();\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function PointLightHelper( light, sphereSize ) {\n\n    this.light = light;\n    this.light.updateMatrixWorld();\n\n    var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\n    var material = new MeshBasicMaterial( { wireframe: true, fog: false } );\n    material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n    Mesh.call( this, geometry, material );\n\n    this.matrix = this.light.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    /*\n    var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n    var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n    var d = light.distance;\n\n    if ( d === 0.0 ) {\n\n      this.lightDistance.visible = false;\n\n    } else {\n\n      this.lightDistance.scale.set( d, d, d );\n\n    }\n\n    this.add( this.lightDistance );\n    */\n\n  }\n\n  PointLightHelper.prototype = Object.create( Mesh.prototype );\n  PointLightHelper.prototype.constructor = PointLightHelper;\n\n  PointLightHelper.prototype.dispose = function () {\n\n    this.geometry.dispose();\n    this.material.dispose();\n\n  };\n\n  PointLightHelper.prototype.update = function () {\n\n    this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n    /*\n    var d = this.light.distance;\n\n    if ( d === 0.0 ) {\n\n      this.lightDistance.visible = false;\n\n    } else {\n\n      this.lightDistance.visible = true;\n      this.lightDistance.scale.set( d, d, d );\n\n    }\n    */\n\n  };\n\n  /**\n   * @author abelnation / http://github.com/abelnation\n   * @author Mugen87 / http://github.com/Mugen87\n   */\n\n  function RectAreaLightHelper( light ) {\n\n    Object3D.call( this );\n\n    this.light = light;\n    this.light.updateMatrixWorld();\n\n    var materialFront = new MeshBasicMaterial( {\n      color: light.color,\n      fog: false\n    } );\n\n    var materialBack = new MeshBasicMaterial( {\n      color: light.color,\n      fog: false,\n      wireframe: true\n    } );\n\n    var geometry = new BufferGeometry();\n\n    geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );\n\n    // shows the \"front\" of the light, e.g. where light comes from\n\n    this.add( new Mesh( geometry, materialFront ) );\n\n    // shows the \"back\" of the light, which does not emit light\n\n    this.add( new Mesh( geometry, materialBack ) );\n\n    this.update();\n\n  }\n\n  RectAreaLightHelper.prototype = Object.create( Object3D.prototype );\n  RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\n\n  RectAreaLightHelper.prototype.dispose = function () {\n\n    this.children[ 0 ].geometry.dispose();\n    this.children[ 0 ].material.dispose();\n    this.children[ 1 ].geometry.dispose();\n    this.children[ 1 ].material.dispose();\n\n  };\n\n  RectAreaLightHelper.prototype.update = function () {\n\n    var vector1 = new Vector3();\n    var vector2 = new Vector3();\n\n    return function update() {\n\n      var mesh1 = this.children[ 0 ];\n      var mesh2 = this.children[ 1 ];\n\n      if ( this.light.target ) {\n\n        vector1.setFromMatrixPosition( this.light.matrixWorld );\n        vector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n        var lookVec = vector2.clone().sub( vector1 );\n        mesh1.lookAt( lookVec );\n        mesh2.lookAt( lookVec );\n\n      }\n\n      // update materials\n\n      mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n      mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n      // calculate new dimensions of the helper\n\n      var hx = this.light.width * 0.5;\n      var hy = this.light.height * 0.5;\n\n      // because the buffer attribute is shared over both geometries, we only have to update once\n\n      var position = mesh1.geometry.getAttribute( 'position' );\n      var array = position.array;\n\n      // first face\n\n      array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;\n      array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;\n      array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;\n\n      // second face\n\n      array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;\n      array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;\n      array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;\n\n      position.needsUpdate = true;\n\n    };\n\n  }();\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   * @author Mugen87 / https://github.com/Mugen87\n   */\n\n  function HemisphereLightHelper( light, size ) {\n\n    Object3D.call( this );\n\n    this.light = light;\n    this.light.updateMatrixWorld();\n\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    var geometry = new OctahedronBufferGeometry( size );\n    geometry.rotateY( Math.PI * 0.5 );\n\n    var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );\n\n    var position = geometry.getAttribute( 'position' );\n    var colors = new Float32Array( position.count * 3 );\n\n    geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n    this.add( new Mesh( geometry, material ) );\n\n    this.update();\n\n  }\n\n  HemisphereLightHelper.prototype = Object.create( Object3D.prototype );\n  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\n\n  HemisphereLightHelper.prototype.dispose = function () {\n\n    this.children[ 0 ].geometry.dispose();\n    this.children[ 0 ].material.dispose();\n\n  };\n\n  HemisphereLightHelper.prototype.update = function () {\n\n    var vector = new Vector3();\n\n    var color1 = new Color();\n    var color2 = new Color();\n\n    return function update() {\n\n      var mesh = this.children[ 0 ];\n\n      var colors = mesh.geometry.getAttribute( 'color' );\n\n      color1.copy( this.light.color ).multiplyScalar( this.light.intensity );\n      color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n      for ( var i = 0, l = colors.count; i < l; i ++ ) {\n\n        var color = ( i < ( l / 2 ) ) ? color1 : color2;\n\n        colors.setXYZ( i, color.r, color.g, color.b );\n\n      }\n\n      mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n      colors.needsUpdate = true;\n\n    };\n\n  }();\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function GridHelper( size, divisions, color1, color2 ) {\n\n    size = size || 10;\n    divisions = divisions || 10;\n    color1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n    color2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n    var center = divisions / 2;\n    var step = size / divisions;\n    var halfSize = size / 2;\n\n    var vertices = [], colors = [];\n\n    for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n      vertices.push( - halfSize, 0, k, halfSize, 0, k );\n      vertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n      var color = i === center ? color1 : color2;\n\n      color.toArray( colors, j ); j += 3;\n      color.toArray( colors, j ); j += 3;\n      color.toArray( colors, j ); j += 3;\n      color.toArray( colors, j ); j += 3;\n\n    }\n\n    var geometry = new BufferGeometry();\n    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n    var material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n    LineSegments.call( this, geometry, material );\n\n  }\n\n  GridHelper.prototype = Object.create( LineSegments.prototype );\n  GridHelper.prototype.constructor = GridHelper;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author Mugen87 / http://github.com/Mugen87\n   * @author Hectate / http://www.github.com/Hectate\n   */\n\n  function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\n\n    radius = radius || 10;\n    radials = radials || 16;\n    circles = circles || 8;\n    divisions = divisions || 64;\n    color1 = new Color( color1 !== undefined ? color1 : 0x444444 );\n    color2 = new Color( color2 !== undefined ? color2 : 0x888888 );\n\n    var vertices = [];\n    var colors = [];\n\n    var x, z;\n    var v, i, j, r, color;\n\n    // create the radials\n\n    for ( i = 0; i <= radials; i ++ ) {\n\n      v = ( i / radials ) * ( Math.PI * 2 );\n\n      x = Math.sin( v ) * radius;\n      z = Math.cos( v ) * radius;\n\n      vertices.push( 0, 0, 0 );\n      vertices.push( x, 0, z );\n\n      color = ( i & 1 ) ? color1 : color2;\n\n      colors.push( color.r, color.g, color.b );\n      colors.push( color.r, color.g, color.b );\n\n    }\n\n    // create the circles\n\n    for ( i = 0; i <= circles; i ++ ) {\n\n      color = ( i & 1 ) ? color1 : color2;\n\n      r = radius - ( radius / circles * i );\n\n      for ( j = 0; j < divisions; j ++ ) {\n\n        // first vertex\n\n        v = ( j / divisions ) * ( Math.PI * 2 );\n\n        x = Math.sin( v ) * r;\n        z = Math.cos( v ) * r;\n\n        vertices.push( x, 0, z );\n        colors.push( color.r, color.g, color.b );\n\n        // second vertex\n\n        v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n        x = Math.sin( v ) * r;\n        z = Math.cos( v ) * r;\n\n        vertices.push( x, 0, z );\n        colors.push( color.r, color.g, color.b );\n\n      }\n\n    }\n\n    var geometry = new BufferGeometry();\n    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n    var material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n    LineSegments.call( this, geometry, material );\n\n  }\n\n  PolarGridHelper.prototype = Object.create( LineSegments.prototype );\n  PolarGridHelper.prototype.constructor = PolarGridHelper;\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n  */\n\n  function FaceNormalsHelper( object, size, hex, linewidth ) {\n\n    // FaceNormalsHelper only supports THREE.Geometry\n\n    this.object = object;\n\n    this.size = ( size !== undefined ) ? size : 1;\n\n    var color = ( hex !== undefined ) ? hex : 0xffff00;\n\n    var width = ( linewidth !== undefined ) ? linewidth : 1;\n\n    //\n\n    var nNormals = 0;\n\n    var objGeometry = this.object.geometry;\n\n    if ( objGeometry && objGeometry.isGeometry ) {\n\n      nNormals = objGeometry.faces.length;\n\n    } else {\n\n      console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n    }\n\n    //\n\n    var geometry = new BufferGeometry();\n\n    var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n    geometry.addAttribute( 'position', positions );\n\n    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\n\n    //\n\n    this.matrixAutoUpdate = false;\n    this.update();\n\n  }\n\n  FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\n  FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\n\n  FaceNormalsHelper.prototype.update = ( function () {\n\n    var v1 = new Vector3();\n    var v2 = new Vector3();\n    var normalMatrix = new Matrix3();\n\n    return function update() {\n\n      this.object.updateMatrixWorld( true );\n\n      normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n      var matrixWorld = this.object.matrixWorld;\n\n      var position = this.geometry.attributes.position;\n\n      //\n\n      var objGeometry = this.object.geometry;\n\n      var vertices = objGeometry.vertices;\n\n      var faces = objGeometry.faces;\n\n      var idx = 0;\n\n      for ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n        var face = faces[ i ];\n\n        var normal = face.normal;\n\n        v1.copy( vertices[ face.a ] )\n          .add( vertices[ face.b ] )\n          .add( vertices[ face.c ] )\n          .divideScalar( 3 )\n          .applyMatrix4( matrixWorld );\n\n        v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n        position.setXYZ( idx, v1.x, v1.y, v1.z );\n\n        idx = idx + 1;\n\n        position.setXYZ( idx, v2.x, v2.y, v2.z );\n\n        idx = idx + 1;\n\n      }\n\n      position.needsUpdate = true;\n\n      return this;\n\n    };\n\n  }() );\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author mrdoob / http://mrdoob.com/\n   * @author WestLangley / http://github.com/WestLangley\n   */\n\n  function DirectionalLightHelper( light, size ) {\n\n    Object3D.call( this );\n\n    this.light = light;\n    this.light.updateMatrixWorld();\n\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    if ( size === undefined ) size = 1;\n\n    var geometry = new BufferGeometry();\n    geometry.addAttribute( 'position', new Float32BufferAttribute( [\n      - size,   size, 0,\n        size,   size, 0,\n        size, - size, 0,\n      - size, - size, 0,\n      - size,   size, 0\n    ], 3 ) );\n\n    var material = new LineBasicMaterial( { fog: false } );\n\n    this.add( new Line( geometry, material ) );\n\n    geometry = new BufferGeometry();\n    geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n    this.add( new Line( geometry, material ));\n\n    this.update();\n\n  }\n\n  DirectionalLightHelper.prototype = Object.create( Object3D.prototype );\n  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\n\n  DirectionalLightHelper.prototype.dispose = function () {\n\n    var lightPlane = this.children[ 0 ];\n    var targetLine = this.children[ 1 ];\n\n    lightPlane.geometry.dispose();\n    lightPlane.material.dispose();\n    targetLine.geometry.dispose();\n    targetLine.material.dispose();\n\n  };\n\n  DirectionalLightHelper.prototype.update = function () {\n\n    var v1 = new Vector3();\n    var v2 = new Vector3();\n    var v3 = new Vector3();\n\n    return function update() {\n\n      v1.setFromMatrixPosition( this.light.matrixWorld );\n      v2.setFromMatrixPosition( this.light.target.matrixWorld );\n      v3.subVectors( v2, v1 );\n\n      var lightPlane = this.children[ 0 ];\n      var targetLine = this.children[ 1 ];\n\n      lightPlane.lookAt( v3 );\n      lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n      targetLine.lookAt( v3 );\n      targetLine.scale.z = v3.length();\n\n    };\n\n  }();\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   * @author Mugen87 / https://github.com/Mugen87\n   *\n   *  - shows frustum, line of sight and up of the camera\n   *  - suitable for fast updates\n   *  - based on frustum visualization in lightgl.js shadowmap example\n   *    http://evanw.github.com/lightgl.js/tests/shadowmap.html\n   */\n\n  function CameraHelper( camera ) {\n\n    var geometry = new BufferGeometry();\n    var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\n\n    var vertices = [];\n    var colors = [];\n\n    var pointMap = {};\n\n    // colors\n\n    var colorFrustum = new Color( 0xffaa00 );\n    var colorCone = new Color( 0xff0000 );\n    var colorUp = new Color( 0x00aaff );\n    var colorTarget = new Color( 0xffffff );\n    var colorCross = new Color( 0x333333 );\n\n    // near\n\n    addLine( \"n1\", \"n2\", colorFrustum );\n    addLine( \"n2\", \"n4\", colorFrustum );\n    addLine( \"n4\", \"n3\", colorFrustum );\n    addLine( \"n3\", \"n1\", colorFrustum );\n\n    // far\n\n    addLine( \"f1\", \"f2\", colorFrustum );\n    addLine( \"f2\", \"f4\", colorFrustum );\n    addLine( \"f4\", \"f3\", colorFrustum );\n    addLine( \"f3\", \"f1\", colorFrustum );\n\n    // sides\n\n    addLine( \"n1\", \"f1\", colorFrustum );\n    addLine( \"n2\", \"f2\", colorFrustum );\n    addLine( \"n3\", \"f3\", colorFrustum );\n    addLine( \"n4\", \"f4\", colorFrustum );\n\n    // cone\n\n    addLine( \"p\", \"n1\", colorCone );\n    addLine( \"p\", \"n2\", colorCone );\n    addLine( \"p\", \"n3\", colorCone );\n    addLine( \"p\", \"n4\", colorCone );\n\n    // up\n\n    addLine( \"u1\", \"u2\", colorUp );\n    addLine( \"u2\", \"u3\", colorUp );\n    addLine( \"u3\", \"u1\", colorUp );\n\n    // target\n\n    addLine( \"c\", \"t\", colorTarget );\n    addLine( \"p\", \"c\", colorCross );\n\n    // cross\n\n    addLine( \"cn1\", \"cn2\", colorCross );\n    addLine( \"cn3\", \"cn4\", colorCross );\n\n    addLine( \"cf1\", \"cf2\", colorCross );\n    addLine( \"cf3\", \"cf4\", colorCross );\n\n    function addLine( a, b, color ) {\n\n      addPoint( a, color );\n      addPoint( b, color );\n\n    }\n\n    function addPoint( id, color ) {\n\n      vertices.push( 0, 0, 0 );\n      colors.push( color.r, color.g, color.b );\n\n      if ( pointMap[ id ] === undefined ) {\n\n        pointMap[ id ] = [];\n\n      }\n\n      pointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n    }\n\n    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n    LineSegments.call( this, geometry, material );\n\n    this.camera = camera;\n    if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n    this.matrix = camera.matrixWorld;\n    this.matrixAutoUpdate = false;\n\n    this.pointMap = pointMap;\n\n    this.update();\n\n  }\n\n  CameraHelper.prototype = Object.create( LineSegments.prototype );\n  CameraHelper.prototype.constructor = CameraHelper;\n\n  CameraHelper.prototype.update = function () {\n\n    var geometry, pointMap;\n\n    var vector = new Vector3();\n    var camera = new Camera();\n\n    function setPoint( point, x, y, z ) {\n\n      vector.set( x, y, z ).unproject( camera );\n\n      var points = pointMap[ point ];\n\n      if ( points !== undefined ) {\n\n        var position = geometry.getAttribute( 'position' );\n\n        for ( var i = 0, l = points.length; i < l; i ++ ) {\n\n          position.setXYZ( points[ i ], vector.x, vector.y, vector.z );\n\n        }\n\n      }\n\n    }\n\n    return function update() {\n\n      geometry = this.geometry;\n      pointMap = this.pointMap;\n\n      var w = 1, h = 1;\n\n      // we need just camera projection matrix\n      // world matrix must be identity\n\n      camera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n      // center / target\n\n      setPoint( \"c\", 0, 0, - 1 );\n      setPoint( \"t\", 0, 0,  1 );\n\n      // near\n\n      setPoint( \"n1\", - w, - h, - 1 );\n      setPoint( \"n2\",   w, - h, - 1 );\n      setPoint( \"n3\", - w,   h, - 1 );\n      setPoint( \"n4\",   w,   h, - 1 );\n\n      // far\n\n      setPoint( \"f1\", - w, - h, 1 );\n      setPoint( \"f2\",   w, - h, 1 );\n      setPoint( \"f3\", - w,   h, 1 );\n      setPoint( \"f4\",   w,   h, 1 );\n\n      // up\n\n      setPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n      setPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n      setPoint( \"u3\",         0, h * 2,   - 1 );\n\n      // cross\n\n      setPoint( \"cf1\", - w,   0, 1 );\n      setPoint( \"cf2\",   w,   0, 1 );\n      setPoint( \"cf3\",   0, - h, 1 );\n      setPoint( \"cf4\",   0,   h, 1 );\n\n      setPoint( \"cn1\", - w,   0, - 1 );\n      setPoint( \"cn2\",   w,   0, - 1 );\n      setPoint( \"cn3\",   0, - h, - 1 );\n      setPoint( \"cn4\",   0,   h, - 1 );\n\n      geometry.getAttribute( 'position' ).needsUpdate = true;\n\n    };\n\n  }();\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function BoxHelper( object, color ) {\n\n    if ( color === undefined ) color = 0xffff00;\n\n    var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n    var positions = new Float32Array( 8 * 3 );\n\n    var geometry = new BufferGeometry();\n    geometry.setIndex( new BufferAttribute( indices, 1 ) );\n    geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n    LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\n\n    if ( object !== undefined ) {\n\n      this.update( object );\n\n    }\n\n  }\n\n  BoxHelper.prototype = Object.create( LineSegments.prototype );\n  BoxHelper.prototype.constructor = BoxHelper;\n\n  BoxHelper.prototype.update = ( function () {\n\n    var box = new Box3();\n\n    return function update( object ) {\n\n      if ( object && object.isBox3 ) {\n\n        box.copy( object );\n\n      } else {\n\n        box.setFromObject( object );\n\n      }\n\n      if ( box.isEmpty() ) return;\n\n      var min = box.min;\n      var max = box.max;\n\n      /*\n        5____4\n      1/___0/|\n      | 6__|_7\n      2/___3/\n\n      0: max.x, max.y, max.z\n      1: min.x, max.y, max.z\n      2: min.x, min.y, max.z\n      3: max.x, min.y, max.z\n      4: max.x, max.y, min.z\n      5: min.x, max.y, min.z\n      6: min.x, min.y, min.z\n      7: max.x, min.y, min.z\n      */\n\n      var position = this.geometry.attributes.position;\n      var array = position.array;\n\n      array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n      array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n      array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n      array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n      array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n      array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n      array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n      array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n      position.needsUpdate = true;\n\n      this.geometry.computeBoundingSphere();\n\n    };\n\n  } )();\n\n  /**\n   * @author WestLangley / http://github.com/WestLangley\n   * @author zz85 / http://github.com/zz85\n   * @author bhouston / http://clara.io\n   *\n   * Creates an arrow for visualizing directions\n   *\n   * Parameters:\n   *  dir - Vector3\n   *  origin - Vector3\n   *  length - Number\n   *  color - color in hex value\n   *  headLength - Number\n   *  headWidth - Number\n   */\n\n  var lineGeometry;\n  var coneGeometry;\n\n  function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n    // dir is assumed to be normalized\n\n    Object3D.call( this );\n\n    if ( color === undefined ) color = 0xffff00;\n    if ( length === undefined ) length = 1;\n    if ( headLength === undefined ) headLength = 0.2 * length;\n    if ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n    if ( lineGeometry === undefined ) {\n\n      lineGeometry = new BufferGeometry();\n      lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n      coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n      coneGeometry.translate( 0, - 0.5, 0 );\n\n    }\n\n    this.position.copy( origin );\n\n    this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\n    this.line.matrixAutoUpdate = false;\n    this.add( this.line );\n\n    this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\n    this.cone.matrixAutoUpdate = false;\n    this.add( this.cone );\n\n    this.setDirection( dir );\n    this.setLength( length, headLength, headWidth );\n\n  }\n\n  ArrowHelper.prototype = Object.create( Object3D.prototype );\n  ArrowHelper.prototype.constructor = ArrowHelper;\n\n  ArrowHelper.prototype.setDirection = ( function () {\n\n    var axis = new Vector3();\n    var radians;\n\n    return function setDirection( dir ) {\n\n      // dir is assumed to be normalized\n\n      if ( dir.y > 0.99999 ) {\n\n        this.quaternion.set( 0, 0, 0, 1 );\n\n      } else if ( dir.y < - 0.99999 ) {\n\n        this.quaternion.set( 1, 0, 0, 0 );\n\n      } else {\n\n        axis.set( dir.z, 0, - dir.x ).normalize();\n\n        radians = Math.acos( dir.y );\n\n        this.quaternion.setFromAxisAngle( axis, radians );\n\n      }\n\n    };\n\n  }() );\n\n  ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n    if ( headLength === undefined ) headLength = 0.2 * length;\n    if ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n    this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n    this.line.updateMatrix();\n\n    this.cone.scale.set( headWidth, headLength, headWidth );\n    this.cone.position.y = length;\n    this.cone.updateMatrix();\n\n  };\n\n  ArrowHelper.prototype.setColor = function ( color ) {\n\n    this.line.material.color.copy( color );\n    this.cone.material.color.copy( color );\n\n  };\n\n  /**\n   * @author sroucheray / http://sroucheray.org/\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function AxisHelper( size ) {\n\n    size = size || 1;\n\n    var vertices = [\n      0, 0, 0,  size, 0, 0,\n      0, 0, 0,  0, size, 0,\n      0, 0, 0,  0, 0, size\n    ];\n\n    var colors = [\n      1, 0, 0,  1, 0.6, 0,\n      0, 1, 0,  0.6, 1, 0,\n      0, 0, 1,  0, 0.6, 1\n    ];\n\n    var geometry = new BufferGeometry();\n    geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n    geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n    var material = new LineBasicMaterial( { vertexColors: VertexColors } );\n\n    LineSegments.call( this, geometry, material );\n\n  }\n\n  AxisHelper.prototype = Object.create( LineSegments.prototype );\n  AxisHelper.prototype.constructor = AxisHelper;\n\n  /**\n   * @author zz85 https://github.com/zz85\n   *\n   * Centripetal CatmullRom Curve - which is useful for avoiding\n   * cusps and self-intersections in non-uniform catmull rom curves.\n   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n   *\n   * curve.type accepts centripetal(default), chordal and catmullrom\n   * curve.tension is used for catmullrom which defaults to 0.5\n   */\n\n\n  /*\n  Based on an optimized c++ solution in\n   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n   - http://ideone.com/NoEbVM\n\n  This CubicPoly class could be used for reusing some variables and calculations,\n  but for three.js curve use, it could be possible inlined and flatten into a single function call\n  which can be placed in CurveUtils.\n  */\n\n  function CubicPoly() {\n\n    var c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n    /*\n     * Compute coefficients for a cubic polynomial\n     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n     * such that\n     *   p(0) = x0, p(1) = x1\n     *  and\n     *   p'(0) = t0, p'(1) = t1.\n     */\n    function init( x0, x1, t0, t1 ) {\n\n      c0 = x0;\n      c1 = t0;\n      c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n      c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n    }\n\n    return {\n\n      initCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n        init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n      },\n\n      initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n        // compute tangents when parameterized in [t1,t2]\n        var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n        var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n        // rescale tangents for parametrization in [0,1]\n        t1 *= dt1;\n        t2 *= dt1;\n\n        init( x1, x2, t1, t2 );\n\n      },\n\n      calc: function ( t ) {\n\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return c0 + c1 * t + c2 * t2 + c3 * t3;\n\n      }\n\n    };\n\n  }\n\n  //\n\n  var tmp = new Vector3();\n  var px = new CubicPoly();\n  var py = new CubicPoly();\n  var pz = new CubicPoly();\n\n  function CatmullRomCurve3( p /* array of Vector3 */ ) {\n\n    this.points = p || [];\n    this.closed = false;\n\n  }\n\n  CatmullRomCurve3.prototype = Object.create( Curve.prototype );\n  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\n\n  CatmullRomCurve3.prototype.getPoint = function ( t ) {\n\n    var points = this.points;\n    var l = points.length;\n\n    if ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n    var point = ( l - ( this.closed ? 0 : 1 ) ) * t;\n    var intPoint = Math.floor( point );\n    var weight = point - intPoint;\n\n    if ( this.closed ) {\n\n      intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n    } else if ( weight === 0 && intPoint === l - 1 ) {\n\n      intPoint = l - 2;\n      weight = 1;\n\n    }\n\n    var p0, p1, p2, p3; // 4 points\n\n    if ( this.closed || intPoint > 0 ) {\n\n      p0 = points[ ( intPoint - 1 ) % l ];\n\n    } else {\n\n      // extrapolate first point\n      tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n      p0 = tmp;\n\n    }\n\n    p1 = points[ intPoint % l ];\n    p2 = points[ ( intPoint + 1 ) % l ];\n\n    if ( this.closed || intPoint + 2 < l ) {\n\n      p3 = points[ ( intPoint + 2 ) % l ];\n\n    } else {\n\n      // extrapolate last point\n      tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n      p3 = tmp;\n\n    }\n\n    if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n      // init Centripetal / Chordal Catmull-Rom\n      var pow = this.type === 'chordal' ? 0.5 : 0.25;\n      var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n      var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n      var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n      // safety check for repeated points\n      if ( dt1 < 1e-4 ) dt1 = 1.0;\n      if ( dt0 < 1e-4 ) dt0 = dt1;\n      if ( dt2 < 1e-4 ) dt2 = dt1;\n\n      px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n      py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n      pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n    } else if ( this.type === 'catmullrom' ) {\n\n      var tension = this.tension !== undefined ? this.tension : 0.5;\n      px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n      py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n      pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n    }\n\n    return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );\n\n  };\n\n  function CubicBezierCurve3( v0, v1, v2, v3 ) {\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n\n  }\n\n  CubicBezierCurve3.prototype = Object.create( Curve.prototype );\n  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\n\n  CubicBezierCurve3.prototype.getPoint = function ( t ) {\n\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n    return new Vector3(\n      CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n      CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n      CubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n    );\n\n  };\n\n  function QuadraticBezierCurve3( v0, v1, v2 ) {\n\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n\n  }\n\n  QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\n  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\n\n  QuadraticBezierCurve3.prototype.getPoint = function ( t ) {\n\n    var v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n    return new Vector3(\n      QuadraticBezier( t, v0.x, v1.x, v2.x ),\n      QuadraticBezier( t, v0.y, v1.y, v2.y ),\n      QuadraticBezier( t, v0.z, v1.z, v2.z )\n    );\n\n  };\n\n  function LineCurve3( v1, v2 ) {\n\n    this.v1 = v1;\n    this.v2 = v2;\n\n  }\n\n  LineCurve3.prototype = Object.create( Curve.prototype );\n  LineCurve3.prototype.constructor = LineCurve3;\n\n  LineCurve3.prototype.getPoint = function ( t ) {\n\n    if ( t === 1 ) {\n\n      return this.v2.clone();\n\n    }\n\n    var vector = new Vector3();\n\n    vector.subVectors( this.v2, this.v1 ); // diff\n    vector.multiplyScalar( t );\n    vector.add( this.v1 );\n\n    return vector;\n\n  };\n\n  function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n    EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n  }\n\n  ArcCurve.prototype = Object.create( EllipseCurve.prototype );\n  ArcCurve.prototype.constructor = ArcCurve;\n\n  /**\n   * @author alteredq / http://alteredqualia.com/\n   */\n\n  var SceneUtils = {\n\n    createMultiMaterialObject: function ( geometry, materials ) {\n\n      var group = new Group();\n\n      for ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n        group.add( new Mesh( geometry, materials[ i ] ) );\n\n      }\n\n      return group;\n\n    },\n\n    detach: function ( child, parent, scene ) {\n\n      child.applyMatrix( parent.matrixWorld );\n      parent.remove( child );\n      scene.add( child );\n\n    },\n\n    attach: function ( child, scene, parent ) {\n\n      var matrixWorldInverse = new Matrix4();\n      matrixWorldInverse.getInverse( parent.matrixWorld );\n      child.applyMatrix( matrixWorldInverse );\n\n      scene.remove( child );\n      parent.add( child );\n\n    }\n\n  };\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n\n  function Face4( a, b, c, d, normal, color, materialIndex ) {\n\n    console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n    return new Face3( a, b, c, normal, color, materialIndex );\n\n  }\n\n  var LineStrip = 0;\n\n  var LinePieces = 1;\n\n  function MeshFaceMaterial( materials ) {\n\n    console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );\n    return new MultiMaterial( materials );\n\n  }\n\n  function PointCloud( geometry, material ) {\n\n    console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n    return new Points( geometry, material );\n\n  }\n\n  function Particle( material ) {\n\n    console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\n    return new Sprite( material );\n\n  }\n\n  function ParticleSystem( geometry, material ) {\n\n    console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n    return new Points( geometry, material );\n\n  }\n\n  function PointCloudMaterial( parameters ) {\n\n    console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n    return new PointsMaterial( parameters );\n\n  }\n\n  function ParticleBasicMaterial( parameters ) {\n\n    console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n    return new PointsMaterial( parameters );\n\n  }\n\n  function ParticleSystemMaterial( parameters ) {\n\n    console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n    return new PointsMaterial( parameters );\n\n  }\n\n  function Vertex( x, y, z ) {\n\n    console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n    return new Vector3( x, y, z );\n\n  }\n\n  //\n\n  function DynamicBufferAttribute( array, itemSize ) {\n\n    console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n    return new BufferAttribute( array, itemSize ).setDynamic( true );\n\n  }\n\n  function Int8Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\n    return new Int8BufferAttribute( array, itemSize );\n\n  }\n\n  function Uint8Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\n    return new Uint8BufferAttribute( array, itemSize );\n\n  }\n\n  function Uint8ClampedAttribute( array, itemSize ) {\n\n    console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\n    return new Uint8ClampedBufferAttribute( array, itemSize );\n\n  }\n\n  function Int16Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\n    return new Int16BufferAttribute( array, itemSize );\n\n  }\n\n  function Uint16Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\n    return new Uint16BufferAttribute( array, itemSize );\n\n  }\n\n  function Int32Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\n    return new Int32BufferAttribute( array, itemSize );\n\n  }\n\n  function Uint32Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\n    return new Uint32BufferAttribute( array, itemSize );\n\n  }\n\n  function Float32Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\n    return new Float32BufferAttribute( array, itemSize );\n\n  }\n\n  function Float64Attribute( array, itemSize ) {\n\n    console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\n    return new Float64BufferAttribute( array, itemSize );\n\n  }\n\n  //\n\n  Curve.create = function ( construct, getPoint ) {\n\n    console.log( 'THREE.Curve.create() has been deprecated' );\n\n    construct.prototype = Object.create( Curve.prototype );\n    construct.prototype.constructor = construct;\n    construct.prototype.getPoint = getPoint;\n\n    return construct;\n\n  };\n\n  //\n\n  function ClosedSplineCurve3( points ) {\n\n    console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n    CatmullRomCurve3.call( this, points );\n    this.type = 'catmullrom';\n    this.closed = true;\n\n  }\n\n  ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n  //\n\n  function SplineCurve3( points ) {\n\n    console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\n\n    CatmullRomCurve3.call( this, points );\n    this.type = 'catmullrom';\n\n  }\n\n  SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\n\n  //\n\n  function Spline( points ) {\n\n    console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\n\n    CatmullRomCurve3.call( this, points );\n    this.type = 'catmullrom';\n\n  }\n\n  Spline.prototype = Object.create( CatmullRomCurve3.prototype );\n\n  Object.assign( Spline.prototype, {\n\n    initFromArray: function ( a ) {\n\n      console.error( 'THREE.Spline: .initFromArray() has been removed.' );\n\n    },\n    getControlPointsArray: function ( optionalTarget ) {\n\n      console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\n\n    },\n    reparametrizeByArcLength: function ( samplingCoef ) {\n\n      console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\n\n    }\n\n  } );\n\n  //\n  function BoundingBoxHelper( object, color ) {\n\n    console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\n    return new BoxHelper( object, color );\n\n  }\n\n  function EdgesHelper( object, hex ) {\n\n    console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\n    return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n  }\n\n  GridHelper.prototype.setColors = function () {\n\n    console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n  };\n\n  function WireframeHelper( object, hex ) {\n\n    console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\n    return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\n\n  }\n\n  //\n\n  function XHRLoader( manager ) {\n\n    console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\n    return new FileLoader( manager );\n\n  }\n\n  function BinaryTextureLoader( manager ) {\n\n    console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\n    return new DataTextureLoader( manager );\n\n  }\n\n  //\n\n  Object.assign( Box2.prototype, {\n\n    center: function ( optionalTarget ) {\n\n      console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\n      return this.getCenter( optionalTarget );\n\n    },\n    empty: function () {\n\n      console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n      return this.isEmpty();\n\n    },\n    isIntersectionBox: function ( box ) {\n\n      console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n      return this.intersectsBox( box );\n\n    },\n    size: function ( optionalTarget ) {\n\n      console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\n      return this.getSize( optionalTarget );\n\n    }\n  } );\n\n  Object.assign( Box3.prototype, {\n\n    center: function ( optionalTarget ) {\n\n      console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\n      return this.getCenter( optionalTarget );\n\n    },\n    empty: function () {\n\n      console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n      return this.isEmpty();\n\n    },\n    isIntersectionBox: function ( box ) {\n\n      console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n      return this.intersectsBox( box );\n\n    },\n    isIntersectionSphere: function ( sphere ) {\n\n      console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n      return this.intersectsSphere( sphere );\n\n    },\n    size: function ( optionalTarget ) {\n\n      console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\n      return this.getSize( optionalTarget );\n\n    }\n  } );\n\n  Line3.prototype.center = function ( optionalTarget ) {\n\n    console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\n    return this.getCenter( optionalTarget );\n\n  };\n\n  _Math.random16 = function () {\n\n    console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n    return Math.random();\n\n  };\n\n  Object.assign( Matrix3.prototype, {\n\n    flattenToArrayOffset: function ( array, offset ) {\n\n      console.warn( \"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n      return this.toArray( array, offset );\n\n    },\n    multiplyVector3: function ( vector ) {\n\n      console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n      return vector.applyMatrix3( this );\n\n    },\n    multiplyVector3Array: function ( a ) {\n\n      console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n      return this.applyToVector3Array( a );\n\n    },\n    applyToBuffer: function( buffer, offset, length ) {\n\n      console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n      return this.applyToBufferAttribute( buffer );\n\n    },\n    applyToVector3Array: function( array, offset, length ) {\n\n      console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\n\n    }\n\n  } );\n\n  Object.assign( Matrix4.prototype, {\n\n    extractPosition: function ( m ) {\n\n      console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n      return this.copyPosition( m );\n\n    },\n    flattenToArrayOffset: function ( array, offset ) {\n\n      console.warn( \"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\" );\n      return this.toArray( array, offset );\n\n    },\n    getPosition: function () {\n\n      var v1;\n\n      return function getPosition() {\n\n        if ( v1 === undefined ) v1 = new Vector3();\n        console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n        return v1.setFromMatrixColumn( this, 3 );\n\n      };\n\n    }(),\n    setRotationFromQuaternion: function ( q ) {\n\n      console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n      return this.makeRotationFromQuaternion( q );\n\n    },\n    multiplyVector3: function ( vector ) {\n\n      console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n      return vector.applyMatrix4( this );\n\n    },\n    multiplyVector4: function ( vector ) {\n\n      console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n      return vector.applyMatrix4( this );\n\n    },\n    multiplyVector3Array: function ( a ) {\n\n      console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n      return this.applyToVector3Array( a );\n\n    },\n    rotateAxis: function ( v ) {\n\n      console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n      v.transformDirection( this );\n\n    },\n    crossVector: function ( vector ) {\n\n      console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n      return vector.applyMatrix4( this );\n\n    },\n    translate: function () {\n\n      console.error( 'THREE.Matrix4: .translate() has been removed.' );\n\n    },\n    rotateX: function () {\n\n      console.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\n    },\n    rotateY: function () {\n\n      console.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\n    },\n    rotateZ: function () {\n\n      console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\n    },\n    rotateByAxis: function () {\n\n      console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\n    },\n    applyToBuffer: function( buffer, offset, length ) {\n\n      console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\n      return this.applyToBufferAttribute( buffer );\n\n    },\n    applyToVector3Array: function( array, offset, length ) {\n\n      console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\n\n    },\n    makeFrustum: function( left, right, bottom, top, near, far ) {\n\n      console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\n      return this.makePerspective( left, right, top, bottom, near, far );\n\n    }\n\n  } );\n\n  Plane.prototype.isIntersectionLine = function ( line ) {\n\n    console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n    return this.intersectsLine( line );\n\n  };\n\n  Quaternion.prototype.multiplyVector3 = function ( vector ) {\n\n    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n    return vector.applyQuaternion( this );\n\n  };\n\n  Object.assign( Ray.prototype, {\n\n    isIntersectionBox: function ( box ) {\n\n      console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n      return this.intersectsBox( box );\n\n    },\n    isIntersectionPlane: function ( plane ) {\n\n      console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n      return this.intersectsPlane( plane );\n\n    },\n    isIntersectionSphere: function ( sphere ) {\n\n      console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n      return this.intersectsSphere( sphere );\n\n    }\n\n  } );\n\n  Object.assign( Shape.prototype, {\n\n    extrude: function ( options ) {\n\n      console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\n      return new ExtrudeGeometry( this, options );\n\n    },\n    makeGeometry: function ( options ) {\n\n      console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\n      return new ShapeGeometry( this, options );\n\n    }\n\n  } );\n\n  Object.assign( Vector2.prototype, {\n\n    fromAttribute: function ( attribute, index, offset ) {\n\n      console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n      return this.fromBufferAttribute( attribute, index, offset );\n\n    }\n\n  } );\n\n  Object.assign( Vector3.prototype, {\n\n    setEulerFromRotationMatrix: function () {\n\n      console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\n    },\n    setEulerFromQuaternion: function () {\n\n      console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\n    },\n    getPositionFromMatrix: function ( m ) {\n\n      console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n      return this.setFromMatrixPosition( m );\n\n    },\n    getScaleFromMatrix: function ( m ) {\n\n      console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n      return this.setFromMatrixScale( m );\n\n    },\n    getColumnFromMatrix: function ( index, matrix ) {\n\n      console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n      return this.setFromMatrixColumn( matrix, index );\n\n    },\n    applyProjection: function ( m ) {\n\n      console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\n      return this.applyMatrix4( m );\n\n    },\n    fromAttribute: function ( attribute, index, offset ) {\n\n      console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n      return this.fromBufferAttribute( attribute, index, offset );\n\n    }\n\n  } );\n\n  Object.assign( Vector4.prototype, {\n\n    fromAttribute: function ( attribute, index, offset ) {\n\n      console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\n      return this.fromBufferAttribute( attribute, index, offset );\n\n    }\n\n  } );\n\n  //\n\n  Geometry.prototype.computeTangents = function () {\n\n    console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n  };\n\n  Object.assign( Object3D.prototype, {\n\n    getChildByName: function ( name ) {\n\n      console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n      return this.getObjectByName( name );\n\n    },\n    renderDepth: function () {\n\n      console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\n    },\n    translate: function ( distance, axis ) {\n\n      console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n      return this.translateOnAxis( axis, distance );\n\n    }\n\n  } );\n\n  Object.defineProperties( Object3D.prototype, {\n\n    eulerOrder: {\n      get: function () {\n\n        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n        return this.rotation.order;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n        this.rotation.order = value;\n\n      }\n    },\n    useQuaternion: {\n      get: function () {\n\n        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n      },\n      set: function () {\n\n        console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n      }\n    }\n\n  } );\n\n  Object.defineProperties( LOD.prototype, {\n\n    objects: {\n      get: function () {\n\n        console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n        return this.levels;\n\n      }\n    }\n\n  } );\n\n  //\n\n  PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n    console.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n        \"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n    if ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n    this.setFocalLength( focalLength );\n\n  };\n\n  //\n\n  Object.defineProperties( Light.prototype, {\n    onlyShadow: {\n      set: function () {\n\n        console.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\n      }\n    },\n    shadowCameraFov: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n        this.shadow.camera.fov = value;\n\n      }\n    },\n    shadowCameraLeft: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n        this.shadow.camera.left = value;\n\n      }\n    },\n    shadowCameraRight: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n        this.shadow.camera.right = value;\n\n      }\n    },\n    shadowCameraTop: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n        this.shadow.camera.top = value;\n\n      }\n    },\n    shadowCameraBottom: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n        this.shadow.camera.bottom = value;\n\n      }\n    },\n    shadowCameraNear: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n        this.shadow.camera.near = value;\n\n      }\n    },\n    shadowCameraFar: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n        this.shadow.camera.far = value;\n\n      }\n    },\n    shadowCameraVisible: {\n      set: function () {\n\n        console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\n      }\n    },\n    shadowBias: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n        this.shadow.bias = value;\n\n      }\n    },\n    shadowDarkness: {\n      set: function () {\n\n        console.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\n      }\n    },\n    shadowMapWidth: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n        this.shadow.mapSize.width = value;\n\n      }\n    },\n    shadowMapHeight: {\n      set: function ( value ) {\n\n        console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n        this.shadow.mapSize.height = value;\n\n      }\n    }\n  } );\n\n  //\n\n  Object.defineProperties( BufferAttribute.prototype, {\n\n    length: {\n      get: function () {\n\n        console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\n        return this.array.length;\n\n      }\n    }\n\n  } );\n\n  Object.assign( BufferGeometry.prototype, {\n\n    addIndex: function ( index ) {\n\n      console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n      this.setIndex( index );\n\n    },\n    addDrawCall: function ( start, count, indexOffset ) {\n\n      if ( indexOffset !== undefined ) {\n\n        console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\n      }\n      console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n      this.addGroup( start, count );\n\n    },\n    clearDrawCalls: function () {\n\n      console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n      this.clearGroups();\n\n    },\n    computeTangents: function () {\n\n      console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\n    },\n    computeOffsets: function () {\n\n      console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\n    }\n\n  } );\n\n  Object.defineProperties( BufferGeometry.prototype, {\n\n    drawcalls: {\n      get: function () {\n\n        console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n        return this.groups;\n\n      }\n    },\n    offsets: {\n      get: function () {\n\n        console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n        return this.groups;\n\n      }\n    }\n\n  } );\n\n  //\n\n  Object.defineProperties( Uniform.prototype, {\n\n    dynamic: {\n      set: function () {\n\n        console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\n\n      }\n    },\n    onUpdate: {\n      value: function () {\n\n        console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\n        return this;\n\n      }\n    }\n\n  } );\n\n  //\n\n  Object.defineProperties( Material.prototype, {\n\n    wrapAround: {\n      get: function () {\n\n        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\n      },\n      set: function () {\n\n        console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\n      }\n    },\n    wrapRGB: {\n      get: function () {\n\n        console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n        return new Color();\n\n      }\n    }\n\n  } );\n\n  Object.defineProperties( MeshPhongMaterial.prototype, {\n\n    metal: {\n      get: function () {\n\n        console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n        return false;\n\n      },\n      set: function () {\n\n        console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\n      }\n    }\n\n  } );\n\n  Object.defineProperties( ShaderMaterial.prototype, {\n\n    derivatives: {\n      get: function () {\n\n        console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n        return this.extensions.derivatives;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n        this.extensions.derivatives = value;\n\n      }\n    }\n\n  } );\n\n  //\n\n  Object.assign( WebGLRenderer.prototype, {\n\n    supportsFloatTextures: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n      return this.extensions.get( 'OES_texture_float' );\n\n    },\n    supportsHalfFloatTextures: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n      return this.extensions.get( 'OES_texture_half_float' );\n\n    },\n    supportsStandardDerivatives: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n      return this.extensions.get( 'OES_standard_derivatives' );\n\n    },\n    supportsCompressedTextureS3TC: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n      return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n    },\n    supportsCompressedTexturePVRTC: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n      return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n    },\n    supportsBlendMinMax: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n      return this.extensions.get( 'EXT_blend_minmax' );\n\n    },\n    supportsVertexTextures: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\n      return this.capabilities.vertexTextures;\n\n    },\n    supportsInstancedArrays: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n      return this.extensions.get( 'ANGLE_instanced_arrays' );\n\n    },\n    enableScissorTest: function ( boolean ) {\n\n      console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n      this.setScissorTest( boolean );\n\n    },\n    initMaterial: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\n    },\n    addPrePlugin: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\n    },\n    addPostPlugin: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\n    },\n    updateShadowMap: function () {\n\n      console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\n    }\n\n  } );\n\n  Object.defineProperties( WebGLRenderer.prototype, {\n\n    shadowMapEnabled: {\n      get: function () {\n\n        return this.shadowMap.enabled;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n        this.shadowMap.enabled = value;\n\n      }\n    },\n    shadowMapType: {\n      get: function () {\n\n        return this.shadowMap.type;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n        this.shadowMap.type = value;\n\n      }\n    },\n    shadowMapCullFace: {\n      get: function () {\n\n        return this.shadowMap.cullFace;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n        this.shadowMap.cullFace = value;\n\n      }\n    }\n  } );\n\n  Object.defineProperties( WebGLShadowMap.prototype, {\n\n    cullFace: {\n      get: function () {\n\n        return this.renderReverseSided ? CullFaceFront : CullFaceBack;\n\n      },\n      set: function ( cullFace ) {\n\n        var value = ( cullFace !== CullFaceBack );\n        console.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n        this.renderReverseSided = value;\n\n      }\n    }\n\n  } );\n\n  //\n\n  Object.defineProperties( WebGLRenderTarget.prototype, {\n\n    wrapS: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n        return this.texture.wrapS;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n        this.texture.wrapS = value;\n\n      }\n    },\n    wrapT: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n        return this.texture.wrapT;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n        this.texture.wrapT = value;\n\n      }\n    },\n    magFilter: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n        return this.texture.magFilter;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n        this.texture.magFilter = value;\n\n      }\n    },\n    minFilter: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n        return this.texture.minFilter;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n        this.texture.minFilter = value;\n\n      }\n    },\n    anisotropy: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n        return this.texture.anisotropy;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n        this.texture.anisotropy = value;\n\n      }\n    },\n    offset: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n        return this.texture.offset;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n        this.texture.offset = value;\n\n      }\n    },\n    repeat: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n        return this.texture.repeat;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n        this.texture.repeat = value;\n\n      }\n    },\n    format: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n        return this.texture.format;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n        this.texture.format = value;\n\n      }\n    },\n    type: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n        return this.texture.type;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n        this.texture.type = value;\n\n      }\n    },\n    generateMipmaps: {\n      get: function () {\n\n        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n        return this.texture.generateMipmaps;\n\n      },\n      set: function ( value ) {\n\n        console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n        this.texture.generateMipmaps = value;\n\n      }\n    }\n\n  } );\n\n  //\n\n  Audio.prototype.load = function ( file ) {\n\n    console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\n    var scope = this;\n    var audioLoader = new AudioLoader();\n    audioLoader.load( file, function ( buffer ) {\n\n      scope.setBuffer( buffer );\n\n    } );\n    return this;\n\n  };\n\n  AudioAnalyser.prototype.getData = function () {\n\n    console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n    return this.getFrequencyData();\n\n  };\n\n  //\n\n  var GeometryUtils = {\n\n    merge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n      console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n      var matrix;\n\n      if ( geometry2.isMesh ) {\n\n        geometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n        matrix = geometry2.matrix;\n        geometry2 = geometry2.geometry;\n\n      }\n\n      geometry1.merge( geometry2, matrix, materialIndexOffset );\n\n    },\n\n    center: function ( geometry ) {\n\n      console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n      return geometry.center();\n\n    }\n\n  };\n\n  var ImageUtils = {\n\n    crossOrigin: undefined,\n\n    loadTexture: function ( url, mapping, onLoad, onError ) {\n\n      console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n      var loader = new TextureLoader();\n      loader.setCrossOrigin( this.crossOrigin );\n\n      var texture = loader.load( url, onLoad, undefined, onError );\n\n      if ( mapping ) texture.mapping = mapping;\n\n      return texture;\n\n    },\n\n    loadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n      console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n      var loader = new CubeTextureLoader();\n      loader.setCrossOrigin( this.crossOrigin );\n\n      var texture = loader.load( urls, onLoad, undefined, onError );\n\n      if ( mapping ) texture.mapping = mapping;\n\n      return texture;\n\n    },\n\n    loadCompressedTexture: function () {\n\n      console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n    },\n\n    loadCompressedTextureCube: function () {\n\n      console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n    }\n\n  };\n\n  //\n\n  function Projector() {\n\n    console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n    this.projectVector = function ( vector, camera ) {\n\n      console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n      vector.project( camera );\n\n    };\n\n    this.unprojectVector = function ( vector, camera ) {\n\n      console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n      vector.unproject( camera );\n\n    };\n\n    this.pickingRay = function () {\n\n      console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n    };\n\n  }\n\n  //\n\n  function CanvasRenderer() {\n\n    console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n    this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n    this.clear = function () {};\n    this.render = function () {};\n    this.setClearColor = function () {};\n    this.setSize = function () {};\n\n  }\n\n  exports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n  exports.WebGLRenderTarget = WebGLRenderTarget;\n  exports.WebGLRenderer = WebGLRenderer;\n  exports.ShaderLib = ShaderLib;\n  exports.UniformsLib = UniformsLib;\n  exports.UniformsUtils = UniformsUtils;\n  exports.ShaderChunk = ShaderChunk;\n  exports.FogExp2 = FogExp2;\n  exports.Fog = Fog;\n  exports.Scene = Scene;\n  exports.LensFlare = LensFlare;\n  exports.Sprite = Sprite;\n  exports.LOD = LOD;\n  exports.SkinnedMesh = SkinnedMesh;\n  exports.Skeleton = Skeleton;\n  exports.Bone = Bone;\n  exports.Mesh = Mesh;\n  exports.LineSegments = LineSegments;\n  exports.LineLoop = LineLoop;\n  exports.Line = Line;\n  exports.Points = Points;\n  exports.Group = Group;\n  exports.VideoTexture = VideoTexture;\n  exports.DataTexture = DataTexture;\n  exports.CompressedTexture = CompressedTexture;\n  exports.CubeTexture = CubeTexture;\n  exports.CanvasTexture = CanvasTexture;\n  exports.DepthTexture = DepthTexture;\n  exports.Texture = Texture;\n  exports.CompressedTextureLoader = CompressedTextureLoader;\n  exports.DataTextureLoader = DataTextureLoader;\n  exports.CubeTextureLoader = CubeTextureLoader;\n  exports.TextureLoader = TextureLoader;\n  exports.ObjectLoader = ObjectLoader;\n  exports.MaterialLoader = MaterialLoader;\n  exports.BufferGeometryLoader = BufferGeometryLoader;\n  exports.DefaultLoadingManager = DefaultLoadingManager;\n  exports.LoadingManager = LoadingManager;\n  exports.JSONLoader = JSONLoader;\n  exports.ImageLoader = ImageLoader;\n  exports.FontLoader = FontLoader;\n  exports.FileLoader = FileLoader;\n  exports.Loader = Loader;\n  exports.Cache = Cache;\n  exports.AudioLoader = AudioLoader;\n  exports.SpotLightShadow = SpotLightShadow;\n  exports.SpotLight = SpotLight;\n  exports.PointLight = PointLight;\n  exports.RectAreaLight = RectAreaLight;\n  exports.HemisphereLight = HemisphereLight;\n  exports.DirectionalLightShadow = DirectionalLightShadow;\n  exports.DirectionalLight = DirectionalLight;\n  exports.AmbientLight = AmbientLight;\n  exports.LightShadow = LightShadow;\n  exports.Light = Light;\n  exports.StereoCamera = StereoCamera;\n  exports.PerspectiveCamera = PerspectiveCamera;\n  exports.OrthographicCamera = OrthographicCamera;\n  exports.CubeCamera = CubeCamera;\n  exports.Camera = Camera;\n  exports.AudioListener = AudioListener;\n  exports.PositionalAudio = PositionalAudio;\n  exports.AudioContext = AudioContext;\n  exports.AudioAnalyser = AudioAnalyser;\n  exports.Audio = Audio;\n  exports.VectorKeyframeTrack = VectorKeyframeTrack;\n  exports.StringKeyframeTrack = StringKeyframeTrack;\n  exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n  exports.NumberKeyframeTrack = NumberKeyframeTrack;\n  exports.ColorKeyframeTrack = ColorKeyframeTrack;\n  exports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n  exports.PropertyMixer = PropertyMixer;\n  exports.PropertyBinding = PropertyBinding;\n  exports.KeyframeTrack = KeyframeTrack;\n  exports.AnimationUtils = AnimationUtils;\n  exports.AnimationObjectGroup = AnimationObjectGroup;\n  exports.AnimationMixer = AnimationMixer;\n  exports.AnimationClip = AnimationClip;\n  exports.Uniform = Uniform;\n  exports.InstancedBufferGeometry = InstancedBufferGeometry;\n  exports.BufferGeometry = BufferGeometry;\n  exports.GeometryIdCount = GeometryIdCount;\n  exports.Geometry = Geometry;\n  exports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n  exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n  exports.InterleavedBuffer = InterleavedBuffer;\n  exports.InstancedBufferAttribute = InstancedBufferAttribute;\n  exports.Face3 = Face3;\n  exports.Object3D = Object3D;\n  exports.Raycaster = Raycaster;\n  exports.Layers = Layers;\n  exports.EventDispatcher = EventDispatcher;\n  exports.Clock = Clock;\n  exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n  exports.LinearInterpolant = LinearInterpolant;\n  exports.DiscreteInterpolant = DiscreteInterpolant;\n  exports.CubicInterpolant = CubicInterpolant;\n  exports.Interpolant = Interpolant;\n  exports.Triangle = Triangle;\n  exports.Math = _Math;\n  exports.Spherical = Spherical;\n  exports.Cylindrical = Cylindrical;\n  exports.Plane = Plane;\n  exports.Frustum = Frustum;\n  exports.Sphere = Sphere;\n  exports.Ray = Ray;\n  exports.Matrix4 = Matrix4;\n  exports.Matrix3 = Matrix3;\n  exports.Box3 = Box3;\n  exports.Box2 = Box2;\n  exports.Line3 = Line3;\n  exports.Euler = Euler;\n  exports.Vector4 = Vector4;\n  exports.Vector3 = Vector3;\n  exports.Vector2 = Vector2;\n  exports.Quaternion = Quaternion;\n  exports.Color = Color;\n  exports.MorphBlendMesh = MorphBlendMesh;\n  exports.ImmediateRenderObject = ImmediateRenderObject;\n  exports.VertexNormalsHelper = VertexNormalsHelper;\n  exports.SpotLightHelper = SpotLightHelper;\n  exports.SkeletonHelper = SkeletonHelper;\n  exports.PointLightHelper = PointLightHelper;\n  exports.RectAreaLightHelper = RectAreaLightHelper;\n  exports.HemisphereLightHelper = HemisphereLightHelper;\n  exports.GridHelper = GridHelper;\n  exports.PolarGridHelper = PolarGridHelper;\n  exports.FaceNormalsHelper = FaceNormalsHelper;\n  exports.DirectionalLightHelper = DirectionalLightHelper;\n  exports.CameraHelper = CameraHelper;\n  exports.BoxHelper = BoxHelper;\n  exports.ArrowHelper = ArrowHelper;\n  exports.AxisHelper = AxisHelper;\n  exports.CatmullRomCurve3 = CatmullRomCurve3;\n  exports.CubicBezierCurve3 = CubicBezierCurve3;\n  exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n  exports.LineCurve3 = LineCurve3;\n  exports.ArcCurve = ArcCurve;\n  exports.EllipseCurve = EllipseCurve;\n  exports.SplineCurve = SplineCurve;\n  exports.CubicBezierCurve = CubicBezierCurve;\n  exports.QuadraticBezierCurve = QuadraticBezierCurve;\n  exports.LineCurve = LineCurve;\n  exports.Shape = Shape;\n  exports.Path = Path;\n  exports.ShapePath = ShapePath;\n  exports.Font = Font;\n  exports.CurvePath = CurvePath;\n  exports.Curve = Curve;\n  exports.ShapeUtils = ShapeUtils;\n  exports.SceneUtils = SceneUtils;\n  exports.WireframeGeometry = WireframeGeometry;\n  exports.ParametricGeometry = ParametricGeometry;\n  exports.ParametricBufferGeometry = ParametricBufferGeometry;\n  exports.TetrahedronGeometry = TetrahedronGeometry;\n  exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\n  exports.OctahedronGeometry = OctahedronGeometry;\n  exports.OctahedronBufferGeometry = OctahedronBufferGeometry;\n  exports.IcosahedronGeometry = IcosahedronGeometry;\n  exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\n  exports.DodecahedronGeometry = DodecahedronGeometry;\n  exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\n  exports.PolyhedronGeometry = PolyhedronGeometry;\n  exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\n  exports.TubeGeometry = TubeGeometry;\n  exports.TubeBufferGeometry = TubeBufferGeometry;\n  exports.TorusKnotGeometry = TorusKnotGeometry;\n  exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\n  exports.TorusGeometry = TorusGeometry;\n  exports.TorusBufferGeometry = TorusBufferGeometry;\n  exports.TextGeometry = TextGeometry;\n  exports.SphereGeometry = SphereGeometry;\n  exports.SphereBufferGeometry = SphereBufferGeometry;\n  exports.RingGeometry = RingGeometry;\n  exports.RingBufferGeometry = RingBufferGeometry;\n  exports.PlaneGeometry = PlaneGeometry;\n  exports.PlaneBufferGeometry = PlaneBufferGeometry;\n  exports.LatheGeometry = LatheGeometry;\n  exports.LatheBufferGeometry = LatheBufferGeometry;\n  exports.ShapeGeometry = ShapeGeometry;\n  exports.ShapeBufferGeometry = ShapeBufferGeometry;\n  exports.ExtrudeGeometry = ExtrudeGeometry;\n  exports.EdgesGeometry = EdgesGeometry;\n  exports.ConeGeometry = ConeGeometry;\n  exports.ConeBufferGeometry = ConeBufferGeometry;\n  exports.CylinderGeometry = CylinderGeometry;\n  exports.CylinderBufferGeometry = CylinderBufferGeometry;\n  exports.CircleGeometry = CircleGeometry;\n  exports.CircleBufferGeometry = CircleBufferGeometry;\n  exports.BoxGeometry = BoxGeometry;\n  exports.BoxBufferGeometry = BoxBufferGeometry;\n  exports.ShadowMaterial = ShadowMaterial;\n  exports.SpriteMaterial = SpriteMaterial;\n  exports.RawShaderMaterial = RawShaderMaterial;\n  exports.ShaderMaterial = ShaderMaterial;\n  exports.PointsMaterial = PointsMaterial;\n  exports.MultiMaterial = MultiMaterial;\n  exports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n  exports.MeshStandardMaterial = MeshStandardMaterial;\n  exports.MeshPhongMaterial = MeshPhongMaterial;\n  exports.MeshToonMaterial = MeshToonMaterial;\n  exports.MeshNormalMaterial = MeshNormalMaterial;\n  exports.MeshLambertMaterial = MeshLambertMaterial;\n  exports.MeshDepthMaterial = MeshDepthMaterial;\n  exports.MeshBasicMaterial = MeshBasicMaterial;\n  exports.LineDashedMaterial = LineDashedMaterial;\n  exports.LineBasicMaterial = LineBasicMaterial;\n  exports.Material = Material;\n  exports.Float64BufferAttribute = Float64BufferAttribute;\n  exports.Float32BufferAttribute = Float32BufferAttribute;\n  exports.Uint32BufferAttribute = Uint32BufferAttribute;\n  exports.Int32BufferAttribute = Int32BufferAttribute;\n  exports.Uint16BufferAttribute = Uint16BufferAttribute;\n  exports.Int16BufferAttribute = Int16BufferAttribute;\n  exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n  exports.Uint8BufferAttribute = Uint8BufferAttribute;\n  exports.Int8BufferAttribute = Int8BufferAttribute;\n  exports.BufferAttribute = BufferAttribute;\n  exports.REVISION = REVISION;\n  exports.MOUSE = MOUSE;\n  exports.CullFaceNone = CullFaceNone;\n  exports.CullFaceBack = CullFaceBack;\n  exports.CullFaceFront = CullFaceFront;\n  exports.CullFaceFrontBack = CullFaceFrontBack;\n  exports.FrontFaceDirectionCW = FrontFaceDirectionCW;\n  exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\n  exports.BasicShadowMap = BasicShadowMap;\n  exports.PCFShadowMap = PCFShadowMap;\n  exports.PCFSoftShadowMap = PCFSoftShadowMap;\n  exports.FrontSide = FrontSide;\n  exports.BackSide = BackSide;\n  exports.DoubleSide = DoubleSide;\n  exports.FlatShading = FlatShading;\n  exports.SmoothShading = SmoothShading;\n  exports.NoColors = NoColors;\n  exports.FaceColors = FaceColors;\n  exports.VertexColors = VertexColors;\n  exports.NoBlending = NoBlending;\n  exports.NormalBlending = NormalBlending;\n  exports.AdditiveBlending = AdditiveBlending;\n  exports.SubtractiveBlending = SubtractiveBlending;\n  exports.MultiplyBlending = MultiplyBlending;\n  exports.CustomBlending = CustomBlending;\n  exports.AddEquation = AddEquation;\n  exports.SubtractEquation = SubtractEquation;\n  exports.ReverseSubtractEquation = ReverseSubtractEquation;\n  exports.MinEquation = MinEquation;\n  exports.MaxEquation = MaxEquation;\n  exports.ZeroFactor = ZeroFactor;\n  exports.OneFactor = OneFactor;\n  exports.SrcColorFactor = SrcColorFactor;\n  exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n  exports.SrcAlphaFactor = SrcAlphaFactor;\n  exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n  exports.DstAlphaFactor = DstAlphaFactor;\n  exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n  exports.DstColorFactor = DstColorFactor;\n  exports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n  exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n  exports.NeverDepth = NeverDepth;\n  exports.AlwaysDepth = AlwaysDepth;\n  exports.LessDepth = LessDepth;\n  exports.LessEqualDepth = LessEqualDepth;\n  exports.EqualDepth = EqualDepth;\n  exports.GreaterEqualDepth = GreaterEqualDepth;\n  exports.GreaterDepth = GreaterDepth;\n  exports.NotEqualDepth = NotEqualDepth;\n  exports.MultiplyOperation = MultiplyOperation;\n  exports.MixOperation = MixOperation;\n  exports.AddOperation = AddOperation;\n  exports.NoToneMapping = NoToneMapping;\n  exports.LinearToneMapping = LinearToneMapping;\n  exports.ReinhardToneMapping = ReinhardToneMapping;\n  exports.Uncharted2ToneMapping = Uncharted2ToneMapping;\n  exports.CineonToneMapping = CineonToneMapping;\n  exports.UVMapping = UVMapping;\n  exports.CubeReflectionMapping = CubeReflectionMapping;\n  exports.CubeRefractionMapping = CubeRefractionMapping;\n  exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n  exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n  exports.SphericalReflectionMapping = SphericalReflectionMapping;\n  exports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n  exports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n  exports.RepeatWrapping = RepeatWrapping;\n  exports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n  exports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n  exports.NearestFilter = NearestFilter;\n  exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n  exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n  exports.LinearFilter = LinearFilter;\n  exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n  exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n  exports.UnsignedByteType = UnsignedByteType;\n  exports.ByteType = ByteType;\n  exports.ShortType = ShortType;\n  exports.UnsignedShortType = UnsignedShortType;\n  exports.IntType = IntType;\n  exports.UnsignedIntType = UnsignedIntType;\n  exports.FloatType = FloatType;\n  exports.HalfFloatType = HalfFloatType;\n  exports.UnsignedShort4444Type = UnsignedShort4444Type;\n  exports.UnsignedShort5551Type = UnsignedShort5551Type;\n  exports.UnsignedShort565Type = UnsignedShort565Type;\n  exports.UnsignedInt248Type = UnsignedInt248Type;\n  exports.AlphaFormat = AlphaFormat;\n  exports.RGBFormat = RGBFormat;\n  exports.RGBAFormat = RGBAFormat;\n  exports.LuminanceFormat = LuminanceFormat;\n  exports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n  exports.RGBEFormat = RGBEFormat;\n  exports.DepthFormat = DepthFormat;\n  exports.DepthStencilFormat = DepthStencilFormat;\n  exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n  exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n  exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n  exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n  exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n  exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n  exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n  exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n  exports.RGB_ETC1_Format = RGB_ETC1_Format;\n  exports.LoopOnce = LoopOnce;\n  exports.LoopRepeat = LoopRepeat;\n  exports.LoopPingPong = LoopPingPong;\n  exports.InterpolateDiscrete = InterpolateDiscrete;\n  exports.InterpolateLinear = InterpolateLinear;\n  exports.InterpolateSmooth = InterpolateSmooth;\n  exports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n  exports.ZeroSlopeEnding = ZeroSlopeEnding;\n  exports.WrapAroundEnding = WrapAroundEnding;\n  exports.TrianglesDrawMode = TrianglesDrawMode;\n  exports.TriangleStripDrawMode = TriangleStripDrawMode;\n  exports.TriangleFanDrawMode = TriangleFanDrawMode;\n  exports.LinearEncoding = LinearEncoding;\n  exports.sRGBEncoding = sRGBEncoding;\n  exports.GammaEncoding = GammaEncoding;\n  exports.RGBEEncoding = RGBEEncoding;\n  exports.LogLuvEncoding = LogLuvEncoding;\n  exports.RGBM7Encoding = RGBM7Encoding;\n  exports.RGBM16Encoding = RGBM16Encoding;\n  exports.RGBDEncoding = RGBDEncoding;\n  exports.BasicDepthPacking = BasicDepthPacking;\n  exports.RGBADepthPacking = RGBADepthPacking;\n  exports.CubeGeometry = BoxGeometry;\n  exports.Face4 = Face4;\n  exports.LineStrip = LineStrip;\n  exports.LinePieces = LinePieces;\n  exports.MeshFaceMaterial = MeshFaceMaterial;\n  exports.PointCloud = PointCloud;\n  exports.Particle = Particle;\n  exports.ParticleSystem = ParticleSystem;\n  exports.PointCloudMaterial = PointCloudMaterial;\n  exports.ParticleBasicMaterial = ParticleBasicMaterial;\n  exports.ParticleSystemMaterial = ParticleSystemMaterial;\n  exports.Vertex = Vertex;\n  exports.DynamicBufferAttribute = DynamicBufferAttribute;\n  exports.Int8Attribute = Int8Attribute;\n  exports.Uint8Attribute = Uint8Attribute;\n  exports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n  exports.Int16Attribute = Int16Attribute;\n  exports.Uint16Attribute = Uint16Attribute;\n  exports.Int32Attribute = Int32Attribute;\n  exports.Uint32Attribute = Uint32Attribute;\n  exports.Float32Attribute = Float32Attribute;\n  exports.Float64Attribute = Float64Attribute;\n  exports.ClosedSplineCurve3 = ClosedSplineCurve3;\n  exports.SplineCurve3 = SplineCurve3;\n  exports.Spline = Spline;\n  exports.BoundingBoxHelper = BoundingBoxHelper;\n  exports.EdgesHelper = EdgesHelper;\n  exports.WireframeHelper = WireframeHelper;\n  exports.XHRLoader = XHRLoader;\n  exports.BinaryTextureLoader = BinaryTextureLoader;\n  exports.GeometryUtils = GeometryUtils;\n  exports.ImageUtils = ImageUtils;\n  exports.Projector = Projector;\n  exports.CanvasRenderer = CanvasRenderer;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"
		],
		[
			"Init",
			"var renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );\nrenderer.autoClear = false;\nrenderer.setSize( FRAME.getDOM().clientWidth, FRAME.getDOM().clientHeight );\nFRAME.getDOM().appendChild( renderer.domElement );\n\nFRAME.addResource( 'renderer', renderer );"
		]
	],
	"effects": [
		[
			"Clear",
			"var renderer = FRAME.getResource( 'renderer' );\n\n// function init(){}\n\nfunction start(){}\n\nfunction update( progress ){\n\n\trenderer.clear();\n\n}"
		],
		[
			"Cube",
			"var parameters = {\n\tsize: new FRAME.Parameters.Float( 'Size', 1.0 )\n};\n\nvar\trenderer = FRAME.getResource( 'renderer' );\n\nvar camera = new THREE.PerspectiveCamera( 50, FRAME.getDOM().clientWidth / FRAME.getDOM().clientHeight, 0.1, 100 );\ncamera.position.z = 5;\n\nvar scene = new THREE.Scene();\n\nvar mesh = new THREE.Mesh(\n\tnew THREE.CubeGeometry( 1, 1, 1, 2, 2, 2 ),\n\tnew THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } )\n);\nscene.add( mesh );\n\n// function init(){}\n\nfunction start(){}\n\nfunction update( progress ){\n\t\n\tcamera.position.z = 5.0 * progress;\n\tcamera.rotation.z = progress;\n\tmesh.rotation.y = progress * Math.PI * 2;\n\tmesh.scale.y = parameters.size.value;\n\trenderer.render( scene, camera );\n\n}"
		],
		[
			"Fade Out",
			"var parameters = {\n\tcolor:   new FRAME.Parameters.Color( 'Color', 0xffffff ),\n\topacity: new FRAME.Parameters.Float( 'Opacity', 1, 0, 1 )\n};\n\nvar\trenderer = FRAME.getResource( 'renderer' );\n\nvar camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\nvar scene = new THREE.Scene();\nvar mesh = new THREE.Mesh(\n\tnew THREE.PlaneGeometry( 2, 2 ),\n\tnew THREE.MeshBasicMaterial( { transparent: true } )\n);\nscene.add( mesh );\n\n// function init(){}\n\nfunction start(){}\n\nfunction update( progress ){\n\t\n\tmesh.material.color.setHex( parameters.color.value );\n\tmesh.material.opacity = parameters.opacity.value * ( 1 - progress );\n\trenderer.render( scene, camera );\n\n}"
		],
		[
			"Effect",
			"var parameters = {};\n\nvar\trenderer = FRAME.getResource( 'renderer' );\n\nvar camera = new THREE.PerspectiveCamera( 50, FRAME.getDOM().clientWidth / FRAME.getDOM().clientHeight, 0.1, 100 );\ncamera.position.z = 5;\n\nvar scene = new THREE.Scene();\n\nvar mesh = new THREE.Mesh(\n\tnew THREE.SphereGeometry( 1 ),\n\tnew THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } )\n);\nscene.add( mesh );\n\n// function init(){}\n\nfunction start(){}\n\nfunction update( progress ){\n\t\n\tcamera.position.z = 5.0 * progress;\n\tcamera.rotation.z = progress;\n\tmesh.rotation.y = progress * Math.PI * 2;\n\trenderer.render( scene, camera );\n\n}"
		],
		[
			"Effect",
			"var parameters = {\n\tvalue: new FRAME.Parameters.Float( 'Value', 1.0 )\n};\n\n// function init(){}\n\nfunction start(){}\n\nfunction update( progress ){}"
		]
	],
	"animations": [
		[
			"Animation",
			0,
			25.71875,
			0,
			0
		],
		[
			"Animation",
			0,
			10.226407284768202,
			1,
			1
		],
		[
			"Animation",
			10.23096026490065,
			21.730960264900652,
			1,
			3
		],
		[
			"Animation",
			10.65625,
			15.78125,
			2,
			2
		],
		[
			"Animation",
			21.786249999999875,
			33.86624999999983,
			1,
			1
		]
	]
}